<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.2 $ -->
<!-- $Author: gregory $ -->
<!-- EN-Revision: 1.49 Maintainer: Gregory  Status: ready -->
 <chapter id="security">
  <title>安全</title>

  <simpara>
   PHP 是一种非常强大的语言，其解释器不管是作为 WEB 服务器的模块还是单独地以 <acronym>CGI</acronym> 程序的形式运行，都能够访问文件，执行命令，或者建立到服务器的网络连接。在默认情况下，这些特性给在 WEB 上运行的机制带来了安全隐患。针对这一问题，PHP 被设计成一种更加安全的语言，使得其跟 Perl 和 C 语言比起来，更适合用来编写 CGI 程序。加上其有良好的编译时和运行时设置选项以及适当的代码编写规则，PHP 能够为您找到您真正需要的自由与安全的结合点。
  </simpara>
  <simpara>
   由于我们可以在很多不同的方面利用 PHP，因此它有很多设置选项来控制其行为。一组庞大的可选参数能够保证您可以将 PHP 用于许多不同的目的，但这同时也意味着这些参数和服务端配置的组合会带来一些安全问题。
  </simpara>
  <simpara>
   PHP 的配置与其代码相比，有着同样的灵活性。PHP 可以用来建立完整的服务端应用程序，拥有所有外壳用户的权限；它也可以在被严格控制的环境下用作一个简单的服务端包含，仅承担很小的风险。您如何建立该环境，以及其安全性如何，在很大程度上取决于 PHP 的开发者。
  </simpara>
  <simpara>
   本章将以一些总的安全建议开始，解释不同的配置选项组合以及它们能够被安全的使用的情况，然后针对不同的安全等级要求，描述一些在编写代码过程中采取的安全策略。
  </simpara>

  <sect1 id="security.general">
   <title>一般策略</title>
   <simpara>
    一个绝对安全的系统是不可能实现的，因此一个安全策略的核心通常都是寻求风险与可用性之间的平衡点。如果用户提交的每个变量都需要两种生物统计学的校验（例如视网膜扫描和指纹检验），那么我们将会需要进行极其高阶的计算。这还可能造成我们需要花费半个小时来填写一个及其繁琐的表单，使得用户更倾向于寻找一些捷径来绕过这些安全机制。
   </simpara>
   <simpara>
    最好的安全策略通常能够不那么明显地适应环境的需求，它不会妨碍用户完成他们的工作，也不会使代码编写员面过分负担复杂的情形。实际上，一些安全攻击的成功正是这种过分冗杂的安全机制随着时间逐渐毁坏的结果。
   </simpara>
   <simpara>
    我们应该记住这样一句很有价值得话：一个系统充其量仅相当于一条锁链中最薄弱的环节。如果所有的事务的时间、地点、类型等信息都被详细的写入日志，但对用户的认证紧紧只是基于一个单一的 cookie，那么讲用户记入事务日志的有效性就被严重地削弱了。
   </simpara>
   <simpara>
    在测试的时候，请记住，即时是对最简单的页面，您也不可能测试到所有的可能性。您所预料到的输入可能和来自于一个不满的雇员，一个黑客用数月时间或者一只不小心踩到键盘的猫的输入完全没有关系。这也是为什么说我们最好能够从逻辑的全局上来审视我们的代码，从而辨别哪里出现不可预料的数据，然后再考虑如何修改、减少或者放大它们。
   </simpara>
   <simpara>
    Internet 上充满了想试图通过破坏你的代码、黑掉你的网站、发布不适合的内容等途径来扬名立万的人。不管你的网站是大还是小，只要你在线，有一部可以连接得到的服务器，你就能成为目标。许多黑客程序并不分辩网站的大小，他们只是简单地在一大片 IP 范围内搜罗牺牲者。我们要尽可能不要使自己成为其中的一员。
   </simpara>
  </sect1>

  <sect1 id="security.cgi-bin">
   <title>安装为 CGI 程序</title>

   <sect2 id="security.cgi-bin.attacks">
    <title>可能受到的攻击</title>
    <simpara>
	 如果您不希望将 PHP 以模块的方式集成到服务器软件（例如 Apache）中，或者希望将 PHP 用于不同的 CGI 外壳来建立安全的 chroot 和 setuid 脚本环境，将 PHP 用作 <acronym>CGI</acronym> 程序是安装时的一种选择。这样的安装通常都需要将可执行的 PHP 程序放置到 cgi-bin 目录。CERT 顾问 <ulink url="&url.cert;">CA-96.11</ulink> 的建议反对将任何解释器放入 cgi-bin 目录。尽管 PHP 的可执行程序能够被用作独立的解释器，PHP 的安全机制也能防止由这样的安装所导致的可能的攻击：
    </simpara>
    <itemizedlist>
     <listitem>
      <simpara>
       访问系统文件：<filename
       role="url">http://my.host/cgi-bin/php?/etc/passwd</filename>
      </simpara>
      <simpara>
	   在 URL 中问号（?）后面的查询信息将被 CGI 接口作为命令行参数传给解释器。通常情况下，解释器会打开并运行由命令行第一个参数所指明的文件。
      </simpara>
      <simpara>
	   当 PHP 以 CGI 程序的方式被激活时，它将拒绝解释该命令行参数。
      </simpara>
     </listitem>
     <listitem>
      <simpara>
	   访问服务器上的任何 WEB 文档：<filename
       role="url">http://my.host/cgi-bin/php/secret/doc.html</filename>
      </simpara>
      <simpara>
	   URL 中 PHP 程序名称后面的路径信息 <filename role="uri">/secret/doc.html</filename> 习惯上是用来指明由 <acronym>CGI</acronym> 程序打开并解释的文件名。通常 WEB 服务器会通过一些的配置选项（Apache: Action）将对类似于 <filename role="url">http://my.host/secret/script.php</filename> 文档的请求重定向到 PHP 解释器。WEB 服务器先检查目录 <filename
       role="uri">/secret</filename> 的访问权限，然后再建立请求的重定向 <filename
       role="url">http://my.host/cgi-bin/php/secret/script.php</filename>。但不幸的是，如果请求直接以这种形式给出，那么 WEB 服务器就不会执行对文件 <filename role="uri">/secret/script.php</filename> 的访问权限检查，而仅仅只检查文件 <filename role="uri">/cgi-bin/php</filename> 的访问权限。这样一来，任何可以访问 <filename role="uri">/cgi-bin/php</filename> 的用户都可以访问任何 WEB 服务器上收到保护的文档。
      </simpara>
      <simpara>
	   在 PHP 中，编译时设置选项 <link
       linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link> 以及运行时设置选项 <link
       linkend="ini.doc-root">doc_root</link> 和 <link linkend="ini.user-dir">user_dir</link> 能够用来防止这种攻击，如果服务端的目录树存在有访问限制的目录。以下将详细解释各种不同的组合。
      </simpara>
     </listitem>
    </itemizedlist>
   </sect2>

   <sect2 id="security.cgi-bin.default">
    <title>方法一：仅就公众文件提供服务</title>

    <simpara>
	 如果您的服务器上没有任何不被密码或者基于 IP 访问限制控制的内容，则这些选项配置对您并没有作用。如果您的 WEB 服务器不允许您进行重定向，或者服务器无法和 PHP 程序通信以识别安全的重定向请求，您可以在运行配置脚本的时候使用 <link
     linkend="install.configure.enable-force-cgi-redirect">--enable-force-cgi-redirect</link> 参数。您还需要确认您的 PHP 脚本不仅仅只依赖某一种方法来调用脚本，不管是直接调用 <filename
     role="php">http://my.host/cgi-bin/php/dir/script.php</filename>，还是重定向到 <filename
     role="php">http://my.host/dir/script.php</filename>。
    </simpara>
    <simpara>
	 在 Apache 中重定向可以使用选项 AddHandler 和 Action 来配置（请参考下文）。
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.force-redirect">
    <title>方法二：使用 --enable-force-cgi-redirect 参数</title>
    <simpara>
	 该编译时参数防止任何人通过直接访问类似于 <filename
     role="php">http://my.host/cgi-bin/php/secretdir/script.php</filename> 的 URL 来调用 PHP。也就是说，只有当脚本基于合法的重定向规则被访问时，PHP 才对它们进行解析。
    </simpara>
    <simpara>
	 通常 Apache 的重定向设置是通过以下选项完成的：
    </simpara>
    <programlisting role="apache-conf">
<![CDATA[
Action php-script /cgi-bin/php
AddHandler php-script .php
]]>
    </programlisting>
    <simpara>
	 该选项仅仅在 Apache WEB 服务器下做过测试，并且依赖 Apache 为被重定向的请求设置非标准的 CGI 环境变量 <envar>REDIRECT_STATUS</envar>。如果您的 WEB 服务器不支持任何方式以获悉请求是直接的还是被重定向的，您将无法使用该选项。您必须使用本文提及的其它运行 CGI 版本的方法。
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.doc-root">
    <title>方法三：设置 doc_root 或者 user_dir</title>
    <simpara>
	 在 WEB 服务器的文档目录中放置诸如脚本和可执行程序等主动的内容，常常被认为是一种不安全的做法。如果由于一些设置的错误，这些脚本没有被执行而像通常的 HTML 文档一样被显示，这将可能导致知识产权或者诸如密码等安全信息的泄漏。因此很多系统管理员宁愿为脚本建立另外一个只能被 PHP CGI 访问的目录结构，使得它们能够被正确解析，又不会出现上述的问题。
    </simpara>
    <simpara>
	 同样，如果如前面章节描述的确保请求不被重定向的方法无效，那么我们就有必要建立一个区别于 WEB 文档根目录脚本的 doc_root 目录。
    </simpara>
    <simpara>
	 您可以通过<link linkend="configuration.file">配置文件</link>中的选项 <link linkend="ini.doc-root">doc_root</link> 或者环境变量 <envar>PHP_DOCUMENT_ROOT</envar> 来设置 PHP 脚本文档的根目录。如果该选项被设置，那么 PHP 的 CGI 版本将总是只通过 <parameter>doc_root</parameter> 和请求的路径信息来打开文档，这样您就可以确保脚本不会在该目录以外执行（除了以下将提及的 <parameter>user_dir</parameter> 目录）。
    </simpara>
    <simpara>
	 另外一个这里可能用得到的选项是 <link linkend="ini.user-dir">user_dir</link>。如果 user_dir 没有被设置，那么唯一控制被打开的文件名的选项就是 <parameter>doc_root</parameter>。打开一个类似于 <filename
     role="url">http://my.host/~user/doc.php</filename> 将不会导致打开一个用户主目录中的文件，而是 doc_root 下一个名为 <filename role="uri">~user/doc.php</filename> 的文件（即一个以波浪号[<literal>~</literal>]开头的目录名）。
    </simpara>
    <simpara>
	 如果 user_dir 被设置为，例如， <filename role="dir">public_php</filename>，那么类似于 <filename role="url">http://my.host/~user/doc.php</filename> 地请求将打开一个该用户主目录下名为 <filename role="dir">public_php</filename> 的目录下的名为 <filename>doc.php</filename> 的文件。如果用户的主目录是 <filename role="dir">/home/user</filename>，那么被执行的文件是 <filename>/home/user/public_php/doc.php</filename>。
    </simpara>
    <simpara>
	 <parameter>user_dir</parameter> 扩展并不依赖于 <parameter>doc_root</parameter> 选项的设定，因此您可以独立控制文档根目录和用户访问目录。
    </simpara>
   </sect2>

   <sect2 id="security.cgi-bin.shell">
    <title>方法四：在 WEB 目录树以外进行 PHP 解析</title>
    <para>
	 一种安全性非常高的方法是把 PHP 解析程序放置到 WEB 文件目录树以外的某个地方，例如，放置到 <filename
     role="dir">/usr/local/bin</filename>。这种做法唯一的弊病就是您现在需要在所有含有 PHP 标记符文件的第一行添加类似于以下的内容：
     <informalexample>
      <programlisting>
<![CDATA[
#!/usr/local/bin/php
]]>
      </programlisting>
     </informalexample>
     您需要使得这些文件成为可执行文件。也就是说，像对待任何其它 CGI 脚本一样来对待它们。这些 CGI 脚本可能是用 Perl、sh 或者任何其它使用的 <literal>#!</literal> shell-escape 机制来启动它们自身的脚本语言来编写的。
    </para>
    <para>
	 要使这个方法中 PHP 能够正确处理 <envar>PATH_INFO</envar> 和 <envar>PATH_TRANSLATED</envar> 信息，在编译 PHP 解析器时必须使用配置参数 <link linkend="install.configure.enable-discard-path">--enable-discard-path</link>。
    </para>
   </sect2>

  </sect1>

  <sect1 id="security.apache">
   <title>安装为 Apache 模块</title>
   <simpara>
    当 PHP 被用作 Apache 的模块时，它将继承 Apache 的用户权限（典型情况为用户“nobody”）。
    这将对安全及授权机制产生一些冲击。例如，如果您使用 PHP 来访问数据库，除非数据库本身有内建的访问控制，否则您将使得数据库能够被用户“nobody”访问。这意味着恶意的脚本能够访问并修改数据库，甚至不需要用户名和密码。网络黑客无意中访问到了数据库管理员的 WEB 页面并通过这里删除所有的数据库是完全有可能发生的。您可以利用 Apache 的认证机制来防止这些的发生，或者也可以利用 LDAP 或 .htaccess 文件等来设计您自己的访问模式，并将这些代码包含为您 PHP 脚本的一部分。
   </simpara>
   <simpara>
    通常，一旦安全机制建立并使得 PHP 的用于（在这种情况下，为 Apache 用户）仅为此承担很小的风险时，我们发现 PHP 此时被禁止往用户目录写入任何文件，或者还有可能被禁止访问和更改数据库。无论防止的对象中写入文件的好坏以及进入的数据库事务的好坏，其安全性都是同等的。
   </simpara>
   <simpara>
    在这个时候，一个频繁出现的安全错误是给 Apache root 权限，或者用其它方法提升 Apache 的能力。
   </simpara>
   <simpara>
    给 Apache 用户赋予 root 权限是及其危险的，而且有可能会连累整个系统。因此，进行 sudo、chroot，或者以 root 账号运行等操作不应该考虑让那些非安全专家来执行。
   </simpara>
   <simpara>
    还有一些更简单的情况。您可以使用 <link linkend="ini.open-basedir">open_basedir</link> 来控制和限制 PHP 能够使用的目录。您还可以建立 Apache 的专用区域，以将所有基于 WEB 的活动都限制到非用户、系统和文件。
   </simpara>
  </sect1>

  <sect1 id="security.filesystem">
   <title>文件系统安全</title>
   <simpara>
    PHP 受大多数服务器系统安全机制的控制，这些安全机制通常是基于文件和目录许可基础的。这使得您可以控制文件系统中的哪些文件可以被读取。您需要特别注意所有全局可读的文件，要保证所有访问该文件系统的用户对它们的读取是安全的。
   </simpara>
   <simpara>
    由于 PHP 在设计的时候，允许用户级访问文件系统，因此编写一个 PHP 脚本使得您能够读取诸如 /etc/passwd，更改您的以太网连接，发送繁重的打印机任务等是完全有可能的。这里有一些明显的关联，您需要保证您读取和写入的是正确的文件。
   </simpara>
   <simpara>
    在以下脚本中，一个用户希望该脚本能够删除它们主目录中的一个文件。这仅仅是假设了一种 PHP WEB 接口通常被用作文件管理的情况，因此 Apache 用户被允许删除用户主目录的文件。
   </simpara>
   <para>
    <example>
     <title>薄弱的变量检验将导致……</title>
     <programlisting role="php">
<![CDATA[
<?php
// remove a file from the user's home directory
$username = $_POST['user_submitted_name'];
$homedir = "/home/$username";
$file_to_delete = "$userfile";
unlink ($homedir/$userfile);
echo "$file_to_delete has been deleted!";
?>
]]>
     </programlisting>
    </example>
   由于用户名是可以从用户表单发送的，因此他们可以提交一个用户名和属于其他人的文件，使得这些文件被删除。在该情况下，您会需要使用另外的表单来授权。考虑一下如果被提交的变量是“../etc/”和“passwd”将会发生什么？这个时候其代码可以被理解为：
    <example>
     <title>一个文件系统攻击</title>
     <programlisting role="php">
<![CDATA[
<?php
// removes a file from anywhere on the hard drive that
// the PHP user has access to. If PHP has root access:
$username = "../etc/";
$homedir = "/home/../etc/";
$file_to_delete = "passwd";
unlink ("/home/../etc/passwd");
echo "/home/../etc/passwd has been deleted!";
?>
]]>
     </programlisting>
    </example>
	有两种您必须采取的措施来避免这些问题。
    <itemizedlist>
     <listitem>
      <simpara>
	   对 PHP WEB 用户仅赋予有限的权限。
      </simpara>
     </listitem>
     <listitem>
      <simpara>
	   检验所有提交的变量。
      </simpara>
     </listitem>
    </itemizedlist>
	以下是经过改进的脚本：
    <example>
     <title>更加安全的文件名检验</title>
     <programlisting role="php">
<![CDATA[
<?php
// removes a file from the hard drive that
// the PHP user has access to.
$username = $_SERVER['REMOTE_USER']; // using an authentication mechanisim

$homedir = "/home/$username";

$file_to_delete = basename("$userfile"); // strip paths
unlink ($homedir/$file_to_delete);

$fp = fopen("/home/logging/filedelete.log","+a"); //log the deletion
$logstring = "$username $homedir $file_to_delete";
fputs ($fp, $logstring);
fclose($fp);

echo "$file_to_delete has been deleted!";
?>
]]>
     </programlisting>
    </example>
	尽管如此，该脚本还是有一些问题。如果您的授权系统允许用户建立他们自己的用户登录，而某用户选择登录“../etc/”，系统将被再次暴露。基于这一点，您可能更愿意编写一个更好的检验：
    <example>
     <title>更安全的文件名检验</title>
     <programlisting role="php">
<![CDATA[
<?php
$username = $_SERVER['REMOTE_USER']; // using an authentication mechanisim
$homedir = "/home/$username";

if (!ereg('^[^./][^/]*$', $userfile))
     die('bad filename'); //die, do not process

if (!ereg('^[^./][^/]*$', $username))
     die('bad username'); //die, do not process
//etc...
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    根据您的操作系统的不同，您需要考虑许多各种各样的文件，包括设备项目（/dev/ 或 COM1），设置文件（/etc/ 文件和 .ini 文件），通常的文件存储区（/home/，My Documents）等。基于这一点，建立一个策略禁止所有除了您明确的授权的行为可能要更简单一些。
   </para>
  </sect1>

  <sect1 id="security.database">
   <title>数据库安全</title>

   <simpara>
    Nowadays, databases are cardinal components of any web based application by
    enabling websites to provide varying dynamic content. Since very sensitive
    or secret informations  can be stored in such database, you should strongly
    consider to protect them somehow.
   </simpara>
   <simpara>
    To retrieve or to store any information you need to connect to the database,
    send a legitimate query, fetch the result, and close the connecion.
    Nowadays, the commonly used query language in this interaction is the
    Structured Query Language (SQL). See how an attacker can <link
    linkend="security.database.sql-injection">tamper with an SQL query</link>.
   </simpara>
   <simpara>
    As you can realize, PHP cannot protect your database by itself. The
    following sections aim to be an introduction into the very basics of how to
    access and manipulate databases within PHP scripts.
   </simpara>
   <simpara>
    Keep in mind this simple rule: defence in depth. In the more place you
    take the more action to increase the protection of your database, the less
    probability of that an attacker succeeds, and exposes or abuse any stored
    secret information. Good design of the database schema and the application
    deals with your greatest fears.
   </simpara>

   <sect2 id="security.database.design">
    <title>设计数据库</title>
     <simpara>
      The first step is always to create the database, unless you want to use
      an existing third party's one. When a database is created, it is
      assigned to an owner, who executed the creation statement. Usually, only
      the owner (or a superuser) can do anything with the objects in that
      database, and in order to allow other users to use it, privileges must be
      granted.
     </simpara>
     <simpara>
      Applications should never connect to the database as its owner or a
      superuser, because these users can execute any query at will, for
      example, modifying the schema (e.g. dropping tables) or deleting its
      entire content.
     </simpara>
     <simpara>
      You may create different database users for every aspect of your
      application with very limited rights to database objects. The most
      required privileges should be granted only, and avoid that the same user
      can interact with the database in different use cases. This means that if
      intruders gain access to your database using one of these credentials,
      they can only effect as many changes as your application can.
     </simpara>
     <simpara>
      You are encouraged not to implement all the business logic in the web
      application (i.e. your script), instead to do it in the database schema
      using views, triggers or rules. If the system evolves, new ports will be
      intended to open to the database, and you have to reimplement the logic
      in each separate database client. Over and above, triggers can be used
      to transparently and automatically handle fields, which often provides
      insight when debugging problems with your application or tracing back
      transactions.
     </simpara>
   </sect2>

   <sect2 id="security.database.connection">
    <title>连接数据库</title>
    <simpara>
     You may want to estabilish the connections over SSL to encrypt
     client/server communications for increased security, or you can use ssh
     to encrypt the network connection between clients and the database server.
     If either of them is done, then monitoring your traffic and gaining
     informations in this way will be a hard work.
    </simpara>
    <!--simpara>
     If your database server native SSL support, consider to use <link
     linkend="ref.openssl">OpenSSL functions</link> in communication between
     PHP and database via SSL.
    </simpara-->
   </sect2>

   <sect2 id="security.database.storage">
    <title>加密存储模型</title>
    <simpara>
     SSL/SSH protects data travelling from the client to the server, SSL/SSH
     does not protect the persistent data stored in a database. SSL is an
     on-the-wire protocol.
    </simpara>
    <simpara>
     Once an attacker gains access to your database directly (bypassing the
     webserver), the stored sensitive data may be exposed or misused, unless
     the information is protected by the database itself. Encrypting the data
     is a good way to mitigate this threat, but very few databases offer this
     type of data encryption.
    </simpara>
    <simpara>
     The easiest way to work around this problem is to first create your own
     encryption package, and then use it from within your PHP scripts. PHP
     can assist you in this case with its several extensions, such as <link
     linkend="ref.mcrypt">Mcrypt</link> and <link
     linkend="ref.mhash">Mhash</link>, covering a wide variety of encryption
     algorithms. The script encrypts the data be stored first, and decrypts
     it when retrieving. See the references for further examples how
     encryption works.
    </simpara>
    <simpara>
     In case of truly hidden data, if its raw representation is not needed
     (i.e. not be displayed), hashing may be also taken into consideration.
     The well-known example for the hashing is storing the MD5 hash of a
     password in a database, instead of the password itself. See also
     <function>crypt</function> and <function>md5</function>.
    </simpara>
    <example>
     <title>使用经过哈希运算的密码字段</title>
     <programlisting role="php">
<![CDATA[
// storing password hash
$query  = sprintf("INSERT INTO users(name,pwd) VALUES('%s','%s');",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

// querying if user submitted the right password
$query = sprintf("SELECT 1 FROM users WHERE name='%s' AND pwd='%s';",
            addslashes($username), md5($password));
$result = pg_exec($connection, $query);

if (pg_numrows($result) > 0) {
    echo "Welcome, $username!";
}
else {
    echo "Authentication failed for $username.";
}
]]>
     </programlisting>
    </example>
   </sect2>

   <sect2 id="security.database.sql-injection">
    <title>SQL 攻击</title>
    <simpara>
     Many web developers are unaware of how SQL queries can be tampered with,
     and assume that an SQL query is a trusted command. It means that SQL
     queries are able to circumvent access controls, thereby bypassing standard
     authentication and authorization checks, and sometimes SQL queries even
     may allow access to host operating system level commands.
    </simpara>
    <simpara>
     Direct SQL Command Injection is a technique where an attacker creates or
     alters existing SQL commands to expose hidden data, or to override valuable
     ones, or even to execute dangerous system level commands on the database
     host. This is accomplished by the application taking user input and
     combining it with static parameters to build a SQL query. The following
     examples are based on true stories, unfortunately.
    </simpara>
    <para>
     Owing to the lack of input validation and connecting to the database on
     behalf of a superuser or the one who can create users, the attacker
     may create a superuser in your database.
     <example>
      <title>
	   将结果集分离到页面中，然后创造超级用户(PostgreSQL and MySQL)
      </title>
      <programlisting role="php">
<![CDATA[
$offset = argv[0]; // beware, no input validation!
$query  = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";
// with PostgreSQL 
$result = pg_exec($conn, $query);
// with MySQL
$result = mysql_query($query);
]]>
      </programlisting>
     </example>
      Normal users click on the 'next', 'prev' links where the <varname>$offset</varname>
      is encoded into the URL. The script expects that the incoming
      <varname>$offset</varname> is decimal number. However, someone tries to
      break in with appending <function>urlencode</function>'d form of the
      following to the URL 
      <informalexample>
       <programlisting>
<![CDATA[
// in case of PostgreSQL
0;
insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)
    select 'crack', usesysid, 't','t','crack'
    from pg_shadow where usename='postgres';
--

// in case of MySQL
0;
UPDATE user SET Password=PASSWORD('crack') WHERE user='root';
FLUSH PRIVILEGES;
]]>
       </programlisting>
      </informalexample>
      If it happened, then the script would present a superuser access to him.
      Note that <literal>0;</literal> is to supply a valid offset to the
      original query and to terminate it.
    </para>
    <note>
     <para>
      It is common technique to force the SQL parser to ignore the rest of the
      query written by the developer with <literal>--</literal> which is the
      comment sign in SQL.
     </para>
    </note>
    <para>
     A feasible way to gain passwords is to circumvent your search result pages.
     What the attacker needs only is to try if there is any submitted variable
     used in SQL statement which is not handled properly. These filters can be set 
     commonly in a preceding form to customize <literal>WHERE, ORDER BY, 
     LIMIT</literal> and <literal>OFFSET</literal> clauses in <literal>SELECT</literal>
     statements. If your database supports the <literal>UNION</literal> construct, 
     the attacker may try to append an entire query to the original one to list 
     passwords from an arbitrary table. Using encrypted password fields is 
     strongly encouraged.
     <example>
      <title>
	   列出文章，以及一些密码（任何数据库服务器）
      </title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT id, name, inserted, size FROM products
                  WHERE size = '$size'
                  ORDER BY $order LIMIT $limit, $offset;";
$result = odbc_exec($conn, $query);
]]>
      </programlisting>
     </example>
     The static part of the query can be combined with another
     <literal>SELECT</literal> statement which reveals all passwords:
     <informalexample>
      <programlisting>
<![CDATA[
'
union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;
--
]]>
      </programlisting>
     </informalexample>
     If this query (playing with the <literal>'</literal> and
     <literal>--</literal>) were assigned to one of the variables used in
     <varname>$query</varname>, the query beast awakened.
    </para>
    <para>
     SQL UPDATEs are also subject to attacking your database. These queries are
     also threatened by chopping and appending an entirely new query to it. But
     the attacker might fiddle with the <literal>SET</literal> clause. In this
     case some schema information must be possessed to manipulate the query
     successfully. This can be acquired by examing the form variable names, or
     just simply brute forcing. There are not so many naming convention for
     fields storing passwords or usernames.
     <example>
     <title>
	  利用重设密码来获取更多的权限（任何数据库服务器）
     </title>
      <programlisting role="php">
<![CDATA[
$query = "UPDATE usertable SET pwd='$pwd' WHERE uid='$uid';";
]]>
      </programlisting>
     </example>
     But a malicious user sumbits the value
     <literal>' or uid like'%admin%'; --</literal> to <varname>$uid</varname> to
     change the admin's password, or simply sets <varname>$pwd</varname> to
     <literal>"hehehe', admin='yes', trusted=100 "</literal> (with a trailing
     space) to gain more privileges. Then, the query will be twisted:
     <informalexample>
      <programlisting role="php">
<![CDATA[
// $uid == ' or uid like'%admin%'; --
$query = "UPDATE usertable SET pwd='...' WHERE uid='' or uid like '%admin%'; --";

// $pwd == "hehehe', admin='yes', trusted=100 "
$query = "UPDATE usertable SET pwd='hehehe', admin='yes', trusted=100 WHERE ...;"
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     A frightening example how operating system level commands can be accessed
     on some database hosts.
     <example>
     <title>攻击数据库主机的操作系统 (MSSQL Server)</title>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products WHERE id LIKE '%$prod%'";
$result = mssql_query($query);
]]>
      </programlisting>
     </example>
     If attacker submits the value
     <literal>a%' exec master..xp_cmdshell 'net user test testpass /ADD' --</literal>
     to <varname>$prod</varname>, then the <varname>$query</varname> will be:
     <informalexample>
      <programlisting role="php">
<![CDATA[
$query  = "SELECT * FROM products
                    WHERE id LIKE '%a%'
                    exec master..xp_cmdshell 'net user test testpass /ADD'--";
$result = mssql_query($query);
]]>
      </programlisting>
     </informalexample>
     MSSQL Server executes the SQL statements in the batch including a command
     to add a new user to the local accounts database. If this application
     were running as <literal>sa</literal> and the MSSQLSERVER service is
     running with sufficient privileges, the attacker would now have an
     account with which to access this machine.
    </para>
    <note>
     <para>
      Some of the examples above is tied to a specific database server. This
      does not mean that a similar attack is impossible against other products.
      Your database server may be so vulnerable in other manner.
     </para>
    </note>

    <sect3 id="security.database.avoiding">
     <title>预防的技巧</title>
     <simpara>
      You may plead that the attacker must possess a piece of information
      about the database schema in most examples. You are right, but you
      never know when and how it can be taken out, and if it happens,
      your database may be exposed. If you are using an open source, or
      publicly available database handling package, which may belong to a
      content management system or forum, the intruders easily produce
      a copy of a piece of your code. It may be also a security risk if it
      is a poorly designed one.
     </simpara>
     <simpara>
      These attacks are mainly based on exploiting the code not being written
      with security in mind. Never trust on any kind of input, especially
      which comes from the client side, even though it comes from a select box,
      a hidden input field or a cookie. The first example shows that such a
      blameless query can cause disasters.
     </simpara>

     <itemizedlist>
      <listitem>
       <simpara>
        Never connect to the database as a superuser or as the database owner.
        Use always customized users with very limited privileges.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Check if the given input has the expected data type. PHP has
        a wide range of input validating functions, from the simplest ones
        found in <link linkend="ref.variables">Variable Functions</link> and
        in <link linkend="ref.ctype">Character Type Functions</link>
        (e.g. <function>is_numeric</function>, <function>ctype_digit</function>
        respectively) onwards the
        <link linkend="ref.pcre">Perl compatible Regular Expressions</link>
        support.
       </simpara>
      </listitem>
      <listitem>
       <para>
        If the application waits for numerical input, consider to verify data
        with <function>is_numeric</function>, or silently change its type
        using <function>settype</function>, or use its numeric representation
        by <function>sprintf</function>.
        <example>
         <title>更加安全的分页查询语句</title>
         <programlisting role="php">
<![CDATA[
settype($offset, 'integer');
$query = "SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET $offset;";

// please note %d in the format string, using %s would be meaningless
$query = sprintf("SELECT id, name FROM products ORDER BY name LIMIT 20 OFFSET %d;",
                 $offset);
]]>
         </programlisting>
        </example>
       </para>
      </listitem>
      <listitem>
       <simpara>
        Quote each non numeric user input which is passed to the database with
        <function>addslashes</function> or <function>addcslashes</function>.
        See <link linkend="security.database.storage">the first example</link>.
        As the examples shows, quotes burnt into the static part of the query
        is not enough, and can be easily hacked.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        Do not print out any database specific information, especially
        about the schema, by fair means or foul. See also <link
        linkend="security.errors">Error Reporting</link> and <link
        linkend="ref.errorfunc">Error Handling and Logging Functions</link>.
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        You may use stored procedures and previously defined cursors to abstract
        data access so that users do not directly access tables or views, but
        this solution has another impacts.
       </simpara>
      </listitem>
     </itemizedlist>

     <simpara>
      Besides these, you benefit from logging queries either within your script
      or by the database itself, if it supports. Obviously, the logging is unable
      to prevent any harmful attempt, but it can be helpful to trace back which
      application has been circumvented. The log is not useful by itself, but
      through the information it contains. The more detail is generally better.
     </simpara>
    </sect3>
   </sect2>
  </sect1>

  <sect1 id="security.errors">
   <title>错误报告</title>
   <para>
    With PHP security, there are two sides to error reporting. One is
    beneficial to increasing security, the other is detrimental.
   </para>
   <para>
    A standard attack tactic involves profiling a system by feeding
    it improper data, and checking for the kinds, and contexts, of the
    errors which are returned. This allows the system cracker to probe
    for information about the server, to determine possible weaknesses.
    For example, if an attacker had gleaned information about a page
    based on a prior form submission, they may attempt to override
    variables, or modify them:
    <example>
     <title>用自定义的 HTML 页面来攻击变量</title>
     <programlisting role="php">
<![CDATA[
<form method="post" action="attacktarget?username=badfoo&password=badfoo">
<input type="hidden" name="username" value="badfoo">
<input type="hidden" name="password" value="badfoo">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    The PHP errors which are normally returned can be quite helpful to a
    developer who is trying to debug a script, indicating such things
    as the function or file that failed, the PHP file it failed in,
    and the line number which the failure occured in. This is all
    information that can be exploited.  It is not uncommon for a php
    developer to use <function>show_source</function>,
    <function>highlight_string</function>, or
    <function>highlight_file</function> as a debugging measure, but in
    a live site, this can expose hidden variables, unchecked syntax,
    and other dangerous information. Especially dangerous is running
    code from known sources with built-in debugging handlers, or using
    common debugging techniques. If the attacker can determine what
    general technique you are using, they may try to brute-force a page,
    by sending various common debugging strings:
    <example>
     <title>利用普通的调试变量</title>
     <programlisting role="php">
<![CDATA[
<form method="post" action="attacktarget?errors=Y&amp;showerrors=1"&debug=1">
<input type="hidden" name="errors" value="Y">
<input type="hidden" name="showerrors" value="1">
<input type="hidden" name="debug" value="1">
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    Regardless of the method of error handling, the ability to probe a
    system for errors leads to providing an attacker with more
    information.
   </para>
   <para>
    For example, the very style of a generic PHP error indicates a system
    is running PHP. If the attacker was looking at an .html page, and
    wanted to probe for the back-end (to look for known weaknesses in
    the system), by feeding it the wrong data they may be able to
    determine that a system was built with PHP.
   </para>
   <para>
    A function error can indicate whether a system may be running a
    specific database engine, or give clues as to how a web page or
    programmed or designed. This allows for deeper investigation into
    open database ports, or to look for specific bugs or weaknesses
    in a web page. By feeding different pieces of bad data, for example,
    an attacker can determine the order of authentication in a script,
    (from the line number errors) as well as probe for exploits that
    may be exploited in different locations in the script.
   </para>
   <para>
    A filesystem or general PHP error can indicate what permissions
    the webserver has, as well as the structure and organization of
    files on the web server. Developer written error code can aggravate
    this problem, leading to easy exploitation of formerly "hidden"
    information.
   </para>
   <para>
    There are three major solutions to this issue. The first is to
    scrutinize all functions, and attempt to compensate for the bulk
    of the errors. The second is to disable error reporting entirely
    on the running code. The third is to use PHP's custom error
    handling functions to create your own error handler. Depending
    on your security policy, you may find all three to be applicable
    to your situation.
   </para>
   <para>
    One way of catching this issue ahead of time is to make use of
    PHP's own <function>error_reporting</function>, to help you
    secure your code and find variable usage that may be dangerous.
    By testing your code, prior to deployment, with E_ALL, you can
    quickly find areas where your variables may be open to poisoning
    or modification in other ways. Once you are ready for deployment,
    by using E_NONE, you insulate your code from probing.
    <example>
     <title>利用 E_ALL 来找出危险的变量</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($username) {  // Not initialized or checked before usage
    $good_login = 1;
}
if ($good_login == 1) { // If above test fails, not initialized or checked before usage
    fpassthru ("/highly/sensitive/data/index.html");
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect1>

  <sect1 id="security.registerglobals">
   <title>利用全局变量注册（Register Globals）</title>
   <para>
    One feature of PHP that can be used to enhance security is configuring PHP with
    <link linkend="ini.register-globals">register_globals</link> = off.
    By turning off the ability for any user-submitted variable to be injected
    into PHP code, you can reduce the amount of variable
    poisoning a potential attacker may inflict. They will have
    to take the additional time to forge submissions, and your
    internal variables are effectively isolated from user
    submitted data.
   </para>
   <para>
    While it does slightly increase the amount of effort required
    to work with PHP, it has been argued that the benefits far
    outweigh the effort.
    <example>
     <title>在 register_globals = on 的情况下工作</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($username) {  // can be forged by a user in get/post/cookies
    $good_login = 1;
}

if ($good_login == 1) { // can be forged by a user in get/post/cookies,
    fpassthru ("/highly/sensitive/data/index.html");
}
?>
]]>
     </programlisting>
    </example>
    <example>
     <title>在 register_globals = off 的情况下工作</title>
     <programlisting role="php">
<![CDATA[
<?php
if($_COOKIE['username']){
    // can only come from a cookie, forged or otherwise
    $good_login = 1;
    fpassthru ("/highly/sensitive/data/index.html");
}
?>
]]>
     </programlisting>
    </example>
    By using this wisely, it's even possible to take preventative
    measures to warn when forging is being attempted. If you know
    ahead of time exactly where a variable should be coming from,
    you can check to see if submitted data is coming from an
    inappropriate kind of submission. While it doesn't guarantee
    that data has not been forged, it does require an attacker
    to guess the right kind of forging.
    <example>
     <title>探测简单的变量攻击</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($_COOKIE['username'] &&
    !$_POST['username'] &&
    !$_GET['username'] ) {
    // Perform other checks to validate the user name...
    $good_login = 1;
    fpassthru ("/highly/sensitive/data/index.html");
} else {
   mail("admin@example.com", "Possible breakin attempt", $_SERVER['REMOTE_ADDR']);
   echo "Security violation, admin has been alerted.";
   exit;
}
?>
]]>
     </programlisting>
    </example>
    Of course, simply turning off register_globals does not mean code
    is secure. For every piece of data that is submitted, it
    should also be checked in other ways.
   </para>
  </sect1>


  <sect1 id="security.variables">
   <title>用户提交的数据</title>
   <para>
    The greatest weakness in many PHP programs is not inherent in the
    language itself, but merely an issue of code not being written with
    security in mind. For this reason, you should always take the time
    to consider the implications of a given piece of code, to ascertain
    the possible damage if an unexpected variable is submitted to it.
    <example>
     <title>危险的变量用法</title>
     <programlisting role="php">
<![CDATA[
<?php
// remove a file from the user's home directory... or maybe
// somebody else's?
unlink ($evil_var);

// Write logging of their access... or maybe an /etc/passwd entry?
fputs ($fp, $evil_var);

// Execute something trivial.. or rm -rf *?
system ($evil_var);
exec ($evil_var);

?>
]]>
     </programlisting>
    </example>
    You should always carefully examine your code to make sure that any
    variables being submitted from a web browser are being properly
    checked, and ask yourself the following questions:
    <itemizedlist>
     <listitem>
      <simpara>
       Will this script only affect the intended files?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Can unusual or undesirable data be acted upon?
      </simpara>
     </listitem>
     <listitem>
     <simpara>
       Can this script be used in unintended ways?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Can this be used in conjunction with other scripts in a negative
       manner?
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       Will any transactions be adequately logged?
      </simpara>
     </listitem>
    </itemizedlist>
    By adequately asking these questions while writing the script,
    rather than later, you prevent an unfortunate re-write when you
    need to increase your security. By starting out with this mindset,
    you won't guarantee the security of your system, but you can help
    improve it.
   </para>
   <para>
    You may also want to consider turning off register_globals,
    magic_quotes, or other convenience settings which may confuse
    you as to the validity, source, or value of a given variable.
    Working with PHP in error_reporting(E_ALL) mode can also help warn
    you about variables being used before they are checked or
    initialized (so you can prevent unusual data from being
    operated upon).
   </para>
  </sect1>

  <sect1 id="security.hiding">
   <title>隐藏 PHP</title>
   <para>
    In general, security by obscurity is one of the weakest forms of security.
    But in some cases, every little bit of extra security is desirable.
   </para>
   <para>
    A few simple techniques can help to hide PHP, possibly slowing
    down an attacker who is attempting to discover weaknesses in your
    system. By setting expose_php = off in your &php.ini; file, you
    reduce the amount of information available to them.
   </para>
   <para>
    Another tactic is to configure web servers such as apache to
    parse different filetypes through PHP, either with an .htaccess
    directive, or in the apache configuration file itself. You can
    then use misleading file extensions:
    <example>
     <title>将 PHP 隐藏为另一种语言</title>
     <programlisting role="apache-conf">
<![CDATA[
# Make PHP code look like other code types
AddType application/x-httpd-php .asp .py .pl
]]>
     </programlisting>
    </example>
	或者完全地隐藏：
    <example>
     <title>对 PHP 使用未知扩展名</title>
     <programlisting role="apache-conf">
<![CDATA[
# Make PHP code look like unknown types
AddType application/x-httpd-php .bop .foo .133t
]]>
     </programlisting>
    </example>
    Or hide it as html code, which has a slight performance hit because
    all html will be parsed through the PHP engine:
    <example>
     <title>对 PHP 使用 HTML 扩展名</title>
     <programlisting role="apache-conf">
<![CDATA[
# Make all PHP code look like html
AddType application/x-httpd-php .htm .html
]]>
     </programlisting>
    </example>
    For this to work effectively, you must rename your PHP files with
    the above extensions. While it is a form of security through
    obscurity, it's a minor preventative measure with few drawbacks.
   </para>
  </sect1>

  <sect1 id="security.current">
   <title>更新到最新版本</title>
   <simpara>
    PHP, like any other large system, is under constant scrutiny and
    improvement. Each new version will often include both major and
    minor changes to enhance and repair security flaws, configuration
    mishaps, and other issues that will affect the overall security
    and stability of your system.
   </simpara>
   <simpara>
    Like other system-level scripting languages and programs, the best
    approach is to update often, and maintain awareness of the latest
    versions and their changes.
   </simpara>
  </sect1>
 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
