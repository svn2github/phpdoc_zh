<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.6 $ -->
<!-- $Author: gregory $ -->
<!-- EN-Revision: 1.44 Maintainer: dallas Status: ready -->
 <chapter id="language.operators">
  <title>运算符</title>
  <simpara>
  </simpara>
  
  <sect1 id="language.operators.precedence">
   <title>运算符优先级</title>
   <para>
    运算符优先级指定了两个表达式绑定得有多“紧密”。例如，表达式 <literal>1 + 5 *
    3</literal> 的结果是 <literal>16</literal> 而不是 <literal>18</literal> 是因为乘号（“*”）的优先级比加号（“+”）高。必要时可以用括号来强制改变优先级。例如：<literal>(1 + 5) * 3</literal> 的值为 <literal>18</literal>。
   </para>
   <para>
    下表从低到高列出了运算符的优先级。
    <table>
     <title>运算符优先级</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>结合方向</entry>
        <entry>运算符</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>左</entry>
        <entry>,</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>or</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>xor</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>and</entry>
       </row>
       <row>
        <entry>右</entry>
        <entry>print</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>
         = += -= *= /= .= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;=
        </entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>? :</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>||</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>&amp;&amp;</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>|</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>^</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>&amp;</entry>
       </row>
       <row>
        <entry>无</entry>
        <entry>== != === !==</entry>
       </row>
       <row>
        <entry>无</entry>
        <entry>&lt; &lt;= &gt; &gt;=</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>&lt;&lt; &gt;&gt;</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>+ - .</entry>
       </row>
       <row>
        <entry>左</entry>
        <entry>* / %</entry>
       </row>
       <row>
        <entry>右</entry>
        <entry>! ~ ++ -- (int) (float) (string) (array) (object) @</entry>
       </row>
       <row>
        <entry>右</entry>
        <entry>[</entry>
       </row>
       <row>
        <entry>无</entry>
        <entry>new</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
   </para>
   <note>
    <para>
     尽管 <literal>!</literal> 比 <literal>=</literal> 的优先级高，PHP
     仍旧允许类似如下的表达式：<literal>if (!$a = foo())</literal>，在此例中
     <literal>foo()</literal> 的输出被赋给了 <varname>$a</varname>。
    </para>
   </note>
  </sect1>

  <sect1 id="language.operators.arithmetic">
   <title>算术运算符</title>
   <simpara>
    还记得学校里学到的基本数学知识吗？就和它们一样。
   </simpara>
   <table>
    <title>算术运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a + $b</entry>
       <entry>加法</entry>
       <entry>$a 和 $b 的和。</entry>
      </row>
      <row>
       <entry>$a - $b</entry>
       <entry>减法</entry>
       <entry>$a 和 $b 的差。</entry>
      </row>
      <row>
       <entry>$a * $b</entry>
       <entry>乘法</entry>
       <entry>$a 和 $b 的积。</entry>
      </row>
      <row>
       <entry>$a / $b</entry>
       <entry>除法</entry>
       <entry>$a 除以 $b 的商。</entry>
      </row>
      <row>
       <entry>$a % $b</entry>
       <entry>取模</entry>
       <entry>$a 除以 $b 的余数。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    除号（“/”）总是返回浮点数，即使两个运算数是整数（或由字符串转换成的整数）也是这样。
   </simpara>

   <!--
   <simpara>
    The division operator ("/") returns an integer value (the 结果
    of an integer division) if the two operands are integers (or
    strings that get converted to integers) and the quotient is an
    integer. If either operand is a floating-point value, or the
    operation 结果s in a non-integer value, a floating-point value
    is returned.
   </simpara>
   -->
  </sect1>
  
  <sect1 id="language.operators.assignment">
   <title>赋值运算符</title>
   <simpara>
    基本的赋值运算符是“=”。你一开始可能会以为它是“等于”，其实不是的。它实际上意味着把右边表达式的值赋给左运算数。
   </simpara>
   <para>
    赋值运算表达式的值也就是所赋的值。也就是说，“$a = 3”的值是 3。这样就可以使你做一些小技巧：
    <informalexample>
     <programlisting role="php"> 
<![CDATA[
$a = ($b = 4) + 5; // $a is equal to 9 now, and $b has been set to 4.
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    在基本赋值运算符之外，还有适合于所有二元算术和字符串运算符的“组和运算符”，这可以让你在一个表达式中使用它的值并把表达式的结果赋给它，例如：
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = 3;
$a += 5; // sets $a to 8, as if we had said: $a = $a + 5;
$b = "Hello ";
$b .= "There!"; // sets $b to "Hello There!", just like $b = $b . "There!";
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    注意赋值运算将原变量的值拷贝到新变量中（传值赋值），所以改变其中一个并不影响另一个。这也适合于你在在紧密循环中拷贝一些值例如大数值。PHP 4 支持引用赋值，用 <computeroutput>$var =
    &amp;$othervar;</computeroutput> 语法，但在 PHP 3 中不可能这样做。“引用赋值”意味着两个变量都指向同一个数据，没有任何数据的拷贝。有关引用的更多信息见<link 
    linkend="language.references">引用的说明</link>。
   </para>
  </sect1>

  <sect1 id="language.operators.bitwise">
   <title>位运算符</title>
   <simpara>
    位运算符允许对整型数中指定的位进行置位。如果左右参数都是字符串，则位运算符将操作这个字符串中的字符。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
    echo 12 ^ 9; // Outputs '5'

    echo "12" ^ "9"; // Outputs the Backspace character (ascii 8)
                     // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8

    echo "hallo" ^ "hello"; // Outputs the ascii values #0 #4 #0 #0 #0
                            // 'a' ^ 'e' = #4
?>
]]>
     </programlisting>
    </informalexample> 
   </para>

   <table>
    <title>位运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a &amp; $b</entry>
       <entry>And（按位与）</entry>
       <entry>将在 $a 和 $b 中都为 1 的位设为 1。</entry>
      </row>
      <row>
       <entry>$a | $b</entry>
       <entry>Or（按位或）</entry>
       <entry>将在 $a 或者 $b 中为 1 的位设为 1。</entry>
      </row>
      <row>
       <entry>$a ^ $b</entry>
       <entry>Xor（按位异或）</entry>
       <entry>将在 $a 和 $b 中不同的位设为 1。</entry>
      </row>
      <row>
       <entry>~ $a</entry>
       <entry>Not（按位非）</entry>
       <entry>将 $a 中为 0 的位设为 1，反之亦然。</entry>
      </row>
      <row>
       <entry>$a &lt;&lt; $b</entry>
       <entry>Shift left（左移）</entry>
       <entry>将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。</entry>
      </row>
      <row>
       <entry>$a &gt;&gt; $b</entry>
       <entry>Shift right（右移）</entry>
       <entry>将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect1>

  <sect1 id="language.operators.comparison">
   <title>比较运算符</title>
   <simpara>
    比较运算符，如同它们名称所暗示的，允许你对两个值进行比较。
   </simpara>
   <table>
    <title>比较运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a == $b</entry>
       <entry>等于</entry>
       <entry>&true;，如果 $a 等于 $b。</entry>
      </row>
      <row>
       <entry>$a === $b</entry>
       <entry>全等</entry>
       <entry>&true;，如果 $a 等于 $b，并且它们的类型也相同。(PHP 4 only)</entry>
      </row>
      <row>
       <entry>$a != $b</entry>
       <entry>不等</entry>
       <entry>&true;，如果 $a 不等于 $b。</entry>
      </row>
      <row>
       <entry>$a &lt;&gt; $b</entry>
       <entry>不等</entry>
       <entry>&true;，如果 $a 不等于 $b。</entry>
      </row>
      <row>
       <entry>$a !== $b</entry>
       <entry>非全等</entry>
       <entry>&true;，如果 $a 不等于 $b，或者它们的类型不同。(PHP 4 only)</entry>
      </row>
      <row>
       <entry>$a &lt; $b</entry>
       <entry>小与</entry>
       <entry>&true;，如果 $a 严格小于 $b。</entry>
      </row>
      <row>
       <entry>$a &gt; $b</entry>
       <entry>大于</entry>
       <entry>&true;，如果 $a 严格 $b。</entry>
      </row>
      <row>
       <entry>$a &lt;= $b</entry>
       <entry>小于等于</entry>
       <entry>&true;，如果 $a 小于或者等于 $b。</entry>
      </row>
      <row>
       <entry>$a &gt;= $b</entry>
       <entry>大于等于</entry>
       <entry>&true;，如果 $a 大于或者等于 $b。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    另外一个条件运算符是“?:”（或三元）运算符，它和 C 以及很多其它语言的操作一样。
    <informalexample>
     <programlisting role="php">
<![CDATA[
(expr1) ? (expr2) : (expr3);
]]>
     </programlisting>
    </informalexample> 
    如果 <replaceable>expr1</replaceable> 的值为 &true;，则此表达式的值为 <replaceable>expr2</replaceable>，如果 <replaceable>expr1</replaceable> 的值为 &false;，则此表达式的值为 <replaceable>expr3</replaceable>。
   </para>
  </sect1>

  <sect1 id="language.operators.errorcontrol">
   <title>错误控制运算符</title>
   <simpara>
    PHP 支持一个错误控制运算符：@。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。
   </simpara>
   <simpara>
    如果激活了 <link linkend="ini.track-errors">track_errors</link> 特性，表达式所产生的任何错误信息都被存放在变量 <link linkend="reserved.variables.phperrormsg">$php_errormsg</link> 中。此变量在每次出错时都会被覆盖，所以如果想用它的话就要尽早检查。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* Intentional file error */
$my_file = @file ('non_existent_file') or
    die ("Failed opening file: error was '$php_errormsg'");

// this works for any expression, not just functions:
$value = @$cache[$key]; 
// will not issue a notice if the index $key doesn't exist.

?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <simpara>
     @ 运算符只对<link linkend="language.expressions">表达式</link>有效。对新手来说一个简单的规则就是：如果你能从某处得到值，你就能在它前面加上 @ 运算符。例如，你可以把它放在变量，函数和 <function>include</function> 调用，常量，等等之前。不能把它放在函数或类的定义之前，也不能用于条件结构例如 <literal>if</literal> 和 <literal>foreach</literal> 等。
    </simpara>
   </note>
   <simpara>
    参见 <function>error_reporting</function>。
   </simpara>
   <note>
    <para>
	 错误控制前缀“@”不会屏蔽解析错误的信息。
    </para>
   </note>
   <warning>
    <para>
     目前的“@”错误控制运算符前缀甚至使导致脚本终止的严重错误的错误报告也失效。这意味着如果你在某个不存在或类型错误的函数调用前用了“@”来抑制错误信息，那脚本会没有任何迹象显示原因而死在那里。
    </para>
   </warning>
  </sect1>
  
  <sect1 id="language.operators.execution">
   <title>执行运算符</title>
   <para>
    PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为外壳命令来执行，并将其输出信息返回（例如，可以赋给一个变量而不是简单地丢弃到标准输出）。
    <informalexample>
     <programlisting role="php">
<![CDATA[
$output = `ls -al`;
echo "<pre>$output</pre>";
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     反引号运算符在激活了 &safemode; 或者关闭了 <function>shell_exec</function> 时是无效的。
    </para>
   </note>
   <para>
    参见 <function>escapeshellcmd</function>，<function>exec</function>，<function>passthru</function>，<function>popen</function>，<function>shell_exec</function> 和 <function>system</function>。
   </para>
  </sect1>

  <sect1 id="language.operators.increment">
   <title>加一／减一运算符</title>
   <para>
    PHP 支持 C 风格的前／后加一与减一运算符。
   </para>
   <table>
    <title>加一／减一运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>效果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>++$a</entry>
       <entry>前加</entry>
       <entry>$a 的值加一，然后返回 $a。</entry>
      </row>
      <row>
       <entry>$a++</entry>
       <entry>后加</entry>
       <entry>返回 $a，然后将 $a 的值加一。</entry>
      </row>
      <row>
       <entry>--$a</entry>
       <entry>前减</entry>
       <entry>$a 的值减一， 然后返回 $a。</entry>
      </row>
      <row>
       <entry>$a--</entry>
       <entry>后减</entry>
       <entry>返回 $a，然后将 $a 的值减一。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <para>
    一个简单的示例脚本：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "<h3>Postincrement</h3>";
$a = 5;
echo "Should be 5: " . $a++ . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Preincrement</h3>";
$a = 5;
echo "Should be 6: " . ++$a . "<br />\n";
echo "Should be 6: " . $a . "<br />\n";

echo "<h3>Postdecrement</h3>";
$a = 5;
echo "Should be 5: " . $a-- . "<br />\n";
echo "Should be 4: " . $a . "<br />\n";

echo "<h3>Predecrement</h3>";
$a = 5;
echo "Should be 4: " . --$a . "<br />\n";
echo "Should be 4: " . $a . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>

  <sect1 id="language.operators.logical">
   <title>逻辑运算符</title>

   <table>
    <title>逻辑运算符</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>例子</entry>
       <entry>名称</entry>
       <entry>结果</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>$a and $b</entry>
       <entry>And（逻辑与）</entry>
       <entry>&true;，如果 $a 与 $b 都为 &true;。</entry>
      </row>
      <row>
       <entry>$a or $b</entry>
       <entry>Or（逻辑或）</entry>
       <entry>&true;，如果 $a 或 $b 任一为 &true;。</entry>
      </row>
      <row>
       <entry>$a xor $b</entry>
       <entry>Xor（逻辑异或）</entry>
       <entry>&true;，如果 $a 或 $b 任一为 &true;，但不同时是。</entry>
      </row>
      <row>
       <entry>! $a</entry>
       <entry>Not（逻辑非）</entry>
       <entry>&true;，如果 $a 不为 &true;。</entry>
      </row>
      <row>
       <entry>$a &amp;&amp; $b</entry>
       <entry>And（逻辑与）</entry>
       <entry>&true;，如果 $a 与 $b 都为 &true;。</entry>
      </row>
      <row>
       <entry>$a || $b</entry>
       <entry>Or（逻辑或）</entry>
       <entry>&true;，如果 $a 或 $b 任一为 &true;。</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
   <simpara>
    “与”和“或”有两种不同形式运算符的原因是它们操作的优先级不同。（见<link linkend="language.operators.precedence">运算符优先级</link>。）
   </simpara>
  </sect1>

  <sect1 id="language.operators.string">
   <title>字符串运算符</title>
   <simpara>
    有两个字符串运算符。第一个是连接运算符（“.”），它返回其左右参数连接后的字符串。第二个是连接赋值运算符（“.=”），它将右边参数附加到左边的参数后。更多信息见<link
    linkend="language.operators.assignment">赋值运算符</link>。
   </simpara>

   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = "Hello ";
$b = $a . "World!"; // now $b contains "Hello World!"

$a = "Hello ";
$a .= "World!";     // now $a contains "Hello World!"
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
  
  <sect1 id="language.operators.array">
   <title>数组运算符</title>
   <simpara>
    PHP 仅有的一个数组运算符是 <literal>+</literal> 运算符。它把右边的数组附加到左边的数组后，但是重复的键值不会被覆盖。
   </simpara>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$a = array("a" => "apple", "b" => "banana");
$b = array("a" =>"pear", "b" => "strawberry", "c" => "cherry");

$c = $a + $b;

var_dump($c);
]]>
     </programlisting>
     <screen role="php">
<![CDATA[
array(3) {
  ["a"]=>
  string(5) "apple"
  ["b"]=>
  string(6) "banana"
  ["c"]=>
  string(6) "cherry"
}

]]>
       </screen>
    </informalexample>
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
