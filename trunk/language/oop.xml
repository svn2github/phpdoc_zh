<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.3 $ -->
 <chapter id="language.oop">
  <title>类与对象</title>

  <sect1 id="keyword.class">
   <title><literal>类</literal></title>
   <para>
	类是变量与作用于这些变量的函数的集合。使用下面的语法定义一个类：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Cart
{
    var $items;  // Items in our shopping cart
   
    // Add $num articles of $artnr to the cart
 
    function add_item ($artnr, $num)
    {
        $this->items[$artnr] += $num;
    }
   
    // Take $num articles of $artnr out of the cart
 
    function remove_item ($artnr, $num)
    {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } else {
            return false;
        }   
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <para>
	上面的例子定义了一个 Cart 类，这个类由购物车中的商品构成的数组和两个用于
	从购物车中添加和删除商品的函数组成。
   </para>

   <caution>
    <simpara>
	 下面的警告注解对 PHP4 有效。
    </simpara>
    
    <simpara>
	 名称 <literal>stdClass</literal> 已经被 Zend 使用并保留。您不能在您的 PHP 代码
	 中定义名为 <literal>stdClass</literal> 的类。
    </simpara>
    
    <simpara>
      The function names <literal>__sleep</literal> and
      <literal>__wakeup</literal> are magical in PHP classes. You
      cannot have functions with these names in any of your
      classes unless you want the magic functionality associated
      with them. See below for more information.
    </simpara>
    
    <simpara>
      PHP reserves all function names starting with __ as magical.
      It is recommended that you do not use function names with
      __ in PHP unless you want some documented magic functionality.
    </simpara>
   </caution>

   <note>
    <simpara>
	 在 PHP 4 中，<literal>var</literal> 变量的值只能初始化为常量。用非常量值初始化变量，
	 您需要一个初始化函数，该函数在对象被创建时自动被调用。这样一个函数被称之为构造函数
     （见下面）。
    </simpara>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
/* None of these will work in PHP 4. */
class Cart
{
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
    var $items = array("VCR", "TV");
}

/* This is how it should be done. */
class Cart
{
    var $todays_date;
    var $name;
    var $owner;
    var $items;

    function Cart()
    {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* etc. . . */
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </note>

   <para>
    Classes are types, that is, they are blueprints for actual
    variables. You have to create a variable of the desired type with
    the <literal>new</literal> operator.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$cart = new Cart;
$cart->add_item("10", 1);

$another_cart = new Cart;
$another_cart->add_item("0815", 3);
]]>
    </programlisting>
   </informalexample>
 
   <para>
    上述代码创建了两个 Cart 类的对象 $cart 和 $another_cart, 对象 $cart 的方法 add_item()
    被调用时，添加了1件10号商品。对于对象 $another_cart, 3件0815号商品被添加到购物车中。
   </para>
   
   <para>
    $cart 和 $another_cart 都有方法 add_item(), remove_item() 和一个 items 变量。
    它们都是明显的函数和变量。你可以把它们当作文件系统中的某些类似目录的东西来考虑。
    在文件系统中，你可以拥有两个不同的 README.TXT 文件，只要不在相同的目录中。
    正如从为了根目录访问每个文件你需要输入该文件的完整的路径名一样，你必须指定需
    要调用的函数的完整名称：在 PHP 术语中，根目录将是全局名称空间，路径名符号将是
    -&gt;。因而，名称 $cart-&gt;items 和 $another_cart-&gt;items 命名了两个不同的
    变量。注意变量 $cart-&gt;items，不是 $cart-&gt;$items，那是因为在 PHP 中一个变量
    名只有一个单独的美元符号。
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
// correct, single $
$cart->items = array("10" => 1); 

// invalid, because $cart->$items becomes $cart->""
$cart->$items = array("10" => 1);

// correct, but may or may not be what was intended:
// $cart->$myvar becomes $cart->items
$myvar = 'items';
$cart->$myvar = array("10" => 1);  
]]>
    </programlisting>
   </informalexample>

   <para>
    在一个类的定义内部，你无法得知使用何种名称的对象是可以访问的：在编写 Cart 类时，并
	不知道之后对象的名称将会命名为 $cart 或者 $another_cart。因而你不能在类中使用
	$cart-&gt;items。然而为了类定义的内部访问自身的函数和变量， 可以使用伪变量 $this
	来达到这个目的。$this 变量可以理解为‘我自己的’或者‘当前对象’。因而
	‘$this->&gt;items[$artnr] += $num’ 可以理解为‘我自己的物品数组的 $artnr 计数器加 $num’
	或者 ‘在当前对象的物品数组的 $artnr 计数器加 $num’。
   </para>

   <note>
    <para>
    有一些不错的函数用来处理类和对象。你应该关注一下 
    <link linkend="ref.classobj">类/对象 函数</link>。
    </para>
   </note>
  </sect1>
  
  <sect1 id="keyword.extends">
   <title><literal>继承</literal></title>

   <para>
	通常你需要这样一些类，这些类与其它现有的类拥有相同变量和函数。实际上，定义一个
	通用类，用于你所有的项目，并且不断丰富这个类以适应你的每个具体项目，将是一个不错
	的练习。为了使这一点变得更加容易，类可以从其它的类中扩展出来。扩展或派生出来的类
	拥有其基类（this is called 'inheritance' despite the fact that nobody died）
	的所有变量和函数，并包含所有你在派生类中定义的部分。类中的元素不可能减少，就是说，
	不可以注销任何存在的函数或者变量。一个扩充类总是依赖一个单独的基类，也就是说，
	多继承是不支持的。使用关键字‘extends’来扩展一个类。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
class Named_Cart extends Cart
{
    var $owner;
  
    function set_owner ($name)
    {
        $this->owner = $name;
    }
}
]]>
    </programlisting>
   </informalexample>
 
   <para>
	上述示例定义了名为 Named_Cart 的类，该类拥有 Cart 类的所有变量和函数，加上
	附加的变量 $owner 和一个附加函数 set_owner()。现在，你以正常的方式创建了一
	个 named cart，并且可以设置并取得 carts 的所有者。而正常的 cart 类的函数依旧
	可以在 named carts 中使用：
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
$ncart = new Named_Cart;    // Create a named cart
$ncart->set_owner("kris");  // Name that cart
print $ncart->owner;        // print the cart owners name
$ncart->add_item("10", 1);  // (inherited functionality from cart)
]]>
    </programlisting>
   </informalexample>

   <para>
	这个也可以叫做“父－子”关系。你创建一个类，父类，并使用 <literal>extends</literal>
	来创建一个 <emphasis>基于</emphasis> 父类的新类：子类。你甚至可以使用这个新的子类来
	创建另外一个基于这个子类的类。
   </para>
   <note>
    <para>
	 类只有在定义后才可以使用！如果你须要类 <literal>Named_Cart</literal> 继承类 <literal>Cart</literal>，
	 你必须首先定义 <literal>Cart</literal> 类。如果你须要创建另一个基于 <literal>Named_Cart</literal> 类
	 的 <literal>Yellow_named_cart </literal> 类，你必须首先定义 <literal>Named_Cart</literal> 类。
	 简捷的说：类定义的顺序是非常重要的。
    </para>
   </note>
  </sect1>

  <sect1 id="language.oop.constructor">
   <title><literal>构造函数</literal></title>

   <caution>
    <simpara>
	 PHP 3 和 PHP4 的构造函数有所不同。PHP 4 的语义更可取。
    </simpara>
   </caution>

   <para>
	构造函数是类中的一个特殊函数，当使用 <literal>new</literal> 操作符
	创建一个类的实例时，构造函数将会自动调用。PHP 3 中，当函数于类同名时，
	这个函数将成为构造函数。PHP 4 ，类中定义的函数与类同名时，这个函数将
	成为一个构造函数－区别很微妙，但非常关键（见下文）。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
// Works in PHP 3 and PHP 4.
class Auto_Cart extends Cart
{
    function Auto_Cart()
    {
        $this->add_item ("10", 1);
    }
}
]]>
    </programlisting>
   </informalexample>
 
   <para>
	上文定义了一个 Auto_Cart 类，即 Cart 类加上一个构造函数，当每次使用 "new" 创建
	一个新的 Auto_Cart 类实例时，构造函数将自动调用并将一件商品的数目初始化为 “10”。
	构造函数可以使用参数，而且这些参数可选的，它们可以使构造函数更加有用。为了依然可以
	不带参数的使用类，所有构造函数的参数应该提供默认值，使其可选。
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
// Works in PHP 3 and PHP 4.
class Constructor_Cart extends Cart
{
    function Constructor_Cart($item = "10", $num = 1)
    {
        $this->add_item ($item, $num);
    }
}
 
// Shop the same old boring stuff.
 
$default_cart = new Constructor_Cart;
 
// Shop for real...
 
$different_cart = new Constructor_Cart("20", 17);
]]>
    </programlisting>
   </informalexample>

   <para>
    你也可以使用 <literal>@</literal> 操作符来 <emphasis>消除</emphasis> 发生在构造函数中的错误。e.g.
    <literal>@new</literal>.

   </para>

   <caution>
    <simpara>
	 PHP 3，派生类和构造函数有许多限制。仔细阅读下列范例以理解这些限制。
    </simpara> 
   </caution>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function A()
    {
      echo "I am the constructor of A.<br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "I am a regular function.<br>\n";
    }
}

// no constructor is being called in PHP 3.
$b = new B;
]]>
    </programlisting>
   </informalexample>

   <para>
	PHP 3，在上面的示例中将不会有构造函数被调用。PHP 3 的规则是：“构造函数是与类
	同名的函数”。这里，类的名字是 B，但是类 B 中没有函数 B()。什么也不会发生。
   </para>
   
   <para>
	PHP 4 修正了这个问题，并介绍了另外的新规则：如果一个类没有构造函数，如果父类有构造
	函数的话，父类的构造函数将会被调用。PHP 4 中，上面的例子将会输出“I am the constructor of A.&lt;br&gt”。
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function A()
    {
        echo "I am the constructor of A.<br>\n";
    }

    function B()
    {
        echo "I am a regular function named B in class A.<br>\n";
        echo "I am not a constructor in A.<br>\n";
    }
}

class B extends A
{
    function C()
    {
        echo "I am a regular function.<br>\n";
    }
}

// This will call B() as a constructor.
$b = new B;
]]>
    </programlisting>
   </informalexample>
   
   <para>
	如果是 PHP 3，A 类中的函数 B() 将立即成为类 B 中的构造函数，虽然并不是有意如此。
	PHP 3 中的规则是：“构造函数是与类同名的函数”。PHP 3 并不关心函数是不是在 B 类
	中定义的，或者是否已经被继承。
   </para>
   
   <para>
	PHP 4 修改了规则：“构造函数与定义其自身的类同名”。因而在 PHP 4 中，类 B 将
	不会有属于自身的构造函数，并且父类的构造函数将会被调用，打印出
	“I am the constructor of A.&lt;br&gt;”。
	
	[译者注,by Verdana: 这里似乎有问题，实际输出的结果，并不象这里说的那样。实际输出的
	内容是“I am a regular function named B in class A......”，输出的是 B() 的内容
	也就是说，例子中的注释“This will call B() as a constructor”是正确的。如果从 A 类
	中移除函数 B()，那么将输出 A() 的内容。]
   </para>
   
   <caution>
    <simpara>
	 不管是 PHP 3 还是 PHP 4 都不能从派生类的构造函数中自动调用基类的构造函数。
	 It is your reponsibility to prapagater the call to constructors 
	 upstream where appropriate.
    </simpara>
   </caution>
   
   <note>
    <simpara>
	 PHP 3 或者 PHP 4 中都没有析构函数。你可以使用 <function>register_shutdown_function</function>
	 函数来模拟多数析构函数的效果。
    </simpara>
   </note>
   
   <para>
	当对象被销毁，使用 <function>unset</function> 或者简单的脱离范围，析构函数都会自动调用。
	但 PHP 中没有析构函数。
   </para>
  </sect1>

 <sect1 id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title><literal>::</literal></title>

   <caution>
    <simpara>
	 下列内容仅在 PHP 4 中有效。
    </simpara>
   </caution>

   <para>
	有时，在没有声明任何实例的情况下访问类中的函数或者基类中的函数和变量很有用处。
	而 :: 操作符即用于此情况。
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
class A
{
    function example()
    {
        echo "I am the original function A::example().<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "I am the redefined function B::example().<br>\n";
        A::example();
    }
}

// there is no object of class A.
// this will print
//   I am the original function A::example().<br>
A::example();

// create an object of class B.
$b = new B;

// this will print 
//   I am the redefined function B::example().<br>
//   I am the original function A::example().<br>
$b->example();
]]>
    </programlisting>
   </informalexample>

   <para>
	上面的例子调用了 A 类的函数 example()，但是这里并不存在 A 类的对象，
	因此不能这样用 $a->example() 或者类似的方法调用 example()。反而我们
	将 example() 作为一个类函数来调用，也就是说，作为一个类自身的函数来调用
	，而不是这个类的任何对象。
   </para>
   
   <para>
	这里有类函数，但没有类的变量。实际上，在调用函数时完全没有任何对象。因而
	一个类的函数可以不使用任何对象（但可以使用局部或者全局变量），并且可以根本
	不使用 $this 变量。
   </para>

   <para>
	上面的例子中，类 B 重新定义了函数 example()。A 类中原始定义的函数 example() 
	将被屏蔽并且不再生效，除非你使用 :: 操作符来访问 A 类中的 example() 函数。
	如： A::example() （实际上，你必须编写 parent::example()，下一章介绍该内容。）
   </para>
   
   <para>
	就此而论，对于当前对象，它可能有对象变量。因而，你可以在对象函数的内部
	使用 $this 和对象变量。
   </para>

 </sect1>

 <sect1 id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   当你发现自己正在写一些访问基类的变量和函数的代码时，这充分说明了
   你的派生类非常的精练、专业。
  </para>
  
  <para>
   Instead of using the literal name of the base class in your
   code, you should be using the special name
   <literal>parent</literal>, which refers to the name of your
   base class as given in the <literal>extends</literal>
   declaration of your class. By doing this, you avoid using the
   name of your base class in more than one place. Should
   your inheritance tree change during implementation, the
   change is easily made by simply changing the 
   <literal>extends</literal> declaration of your class.

   你应该在代码中使用专用名称 <literal>parent</literal> 替代基类的名称，
   来访问
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
class A
{
    function example()
    {
        echo "I am A::example() and provide basic functionality.<br>\n";
    }
}

class B extends A
{
    function example()
    {
        echo "I am B::example() and provide additional functionality.<br>\n";
        parent::example();
    }
}

$b = new B;

// This will call B::example(), which will in turn call A::example().
$b->example();
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 id="language.oop.serialization">
  <title>序列化对象－会话中的对象</title>

  <note>
   <simpara>
    In PHP 3, objects will lose their class association
    throughout the process of serialization and unserialization. 
    The resulting variable is of type object, but has no class
    and no methods, thus it is pretty useless (it has become
    just like an array with a funny syntax).
   </simpara>
  </note>

  <caution>
   <simpara>
    The following information is valid for PHP 4 only. 
   </simpara>
  </caution>

  <para>
   <function>serialize</function> returns a string containing a
   byte-stream representation of any value that can be stored in
   PHP. <function>unserialize</function> can use this string to
   recreate the original variable values. Using serialize to
   save an object will save all variables in an object.  The
   functions in an object will not be saved, only the name of
   the class.
  </para>
  
  <para>
   In order to be able to <function>unserialize</function> an
   object, the class of that object needs to be defined. That
   is, if you have an object $a of class A on page1.php and
   serialize this, you'll get a string that refers to class A
   and contains all values of variabled contained in $a. If
   you want to be able to unserialize this on page2.php,
   recreating $a of class A, the definition of class A must
   be present in page2.php. This can be done for example
   by storing the class defintion of class A in an include
   file and including this file in both page1.php and page2.php.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
classa.inc:
  class A 
  {
      var $one = 1;
    
      function show_one()
      {
          echo $this->one;
      }
  }
  
page1.php:
  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // store $s somewhere where page2.php can find it.
  $fp = fopen("store", "w");
  fputs($fp, $s);
  fclose($fp);

page2.php:
  // this is needed for the unserialize to work properly.
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // now use the function show_one() of the $a object.  
  $a->show_one();
]]>
   </programlisting>
  </informalexample>
  
  <para>
   If you are using sessions and use <function>session_register</function>
   to register objects, these objects are serialized automatically
   at the end of each PHP page, and are unserialized automatically on
   each of the following pages. This basically means that these objects
   can show up on any of your pages once they become part of your
   session.
  </para>
  
  <para>
   It is strongly recommended that you include the class
   definitions of all such registered objects on all of your
   pages, even if you do not actually use these classes on all
   of your pages. If you don't and an object is being
   unserialized without its class definition being present, it
   will lose its class association and become an object of class
   <literal>stdClass</literal> without any functions available
   at all, that is, it will become quite useless.
  </para>
  
  <para>
   So if in the example above $a became part of a session by
   running <literal>session_register("a")</literal>, you should
   include the file <literal>classa.inc</literal> on all of your
   pages, not only page1.php and page2.php.
  </para>
 </sect1>

 <sect1 id="language.oop.magic-functions">
  <title>The magic functions <literal>__sleep</literal> and <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> checks if your class has a function with
   the magic name <literal>__sleep</literal>. If so, that function is
   being run prior to any serialization. It can clean up the object
   and is supposed to return an array with the names of all variables
   of that object that should be serialized.
  </para>
  
  <para>
   The intended use of <literal>__sleep</literal> is to close any
   database connections that object may have, committing pending
   data or perform similar cleanup tasks. Also, the function is
   useful if you have very large objects which need not be
   saved completely.
  </para>
  
  <para>
   Conversely, <function>unserialize</function> checks for the
   presence of a function with the magic name 
   <literal>__wakeup</literal>. If present, this function can
   reconstruct any resources that object may have.
  </para>
  
  <para>
    The intended use of <literal>__wakeup</literal> is to
    reestablish any database connections that may have been lost
    during serialization and perform other reinitialization
    tasks.
  </para>
 </sect1>
  
 <sect1 id="language.oop.newref">
   <title>References inside the constructor</title>
   <para>
    Creating references within the constructor can lead to confusing
    results. This tutorial-like section helps you to avoid problems.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
class Foo
{
    function Foo($name)
    {
        // create a reference inside the global array $globalref
        global $globalref;
        $globalref[] = &$this;
        // set name to passed value
        $this->setName($name);
        // and put it out
        $this->echoName();
    }

    function echoName()
    {
        echo "<br>",$this->name;
    }
	
    function setName($name)
    {
        $this->name = $name;
    }
}
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    Let us check out if there is a difference between
    <varname>$bar1</varname> which has been created using
    the copy <literal>=</literal> operator and
    <varname>$bar2</varname> which has been created using
    the reference <literal>=&amp;</literal> operator...

    <informalexample>
     <programlisting role="php">
<![CDATA[
$bar1 = new Foo('set in constructor');
$bar1->echoName();
$globalref[0]->echoName();

/* output:
set in constructor
set in constructor
set in constructor */

$bar2 =& new Foo('set in constructor');
$bar2->echoName();
$globalref[1]->echoName();

/* output:
set in constructor
set in constructor
set in constructor */
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Apparently there is no difference, but in fact there is a
    very significant one: <varname>$bar1</varname> and
    <varname>$globalref[0]</varname> are _NOT_ referenced, they
    are NOT the same variable. This is because "new" does not
    return a reference by default, instead it returns a copy.
    <note>
     <simpara>
      There is no performance loss (since PHP 4 and up use reference
      counting) returning copies instead of references. On the
      contrary it is most often better to simply work with copies
      instead of references, because creating references takes some
      time where creating copies virtually takes no time (unless none
      of them is a large array or object and one of them gets changed
      and the other(s) one(s) subsequently, then it would be wise to
      use references to change them all concurrently).
     </simpara>
    </note>
    To prove what is written above let us watch the code below.

    <informalexample>
     <programlisting role="php">
<![CDATA[
// now we will change the name. what do you expect?
// you could expect that both $bar1 and $globalref[0] change their names...
$bar1->setName('set from outside');

// as mentioned before this is not the case.
$bar1->echoName();
$globalref[0]->echoName();

/* output:
set from outside
set in constructor */

// let us see what is different with $bar2 and $globalref[1]
$bar2->setName('set from outside');

// luckily they are not only equal, they are the same variable
// thus $bar2->name and $globalref[1]->name are the same too
$bar2->echoName();
$globalref[1]->echoName();

/* output:
set from outside
set from outside */
]]>
     </programlisting>
    </informalexample>   
   </para>   
   <para>
   Another final example, try to understand it.
   
    <informalexample>
     <programlisting role="php">
<![CDATA[
class A
{
    function A($i)
    {
        $this->value = $i;
        // try to figure out why we do not need a reference here
        $this->b = new B($this);
    }

    function createRef()
    {
        $this->c = new B($this);
    }

    function echoValue()
    {
        echo "<br>","class ",get_class($this),': ',$this->value;
    }
}


class B
{
    function B(&$a)
    {
        $this->a = &$a;
    }

    function echoValue()
    {
        echo "<br>","class ",get_class($this),': ',$this->a->value;
    }
}

// try to undestand why using a simple copy here would yield
// in an undesired result in the *-marked line
$a =& new A(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();

/*
output:
class A: 10
class B: 10
class B: 10
class A: 11
class B: 11
class B: 11
*/
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
