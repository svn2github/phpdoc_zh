<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.5 $ -->
<!-- $Author: dallas $ -->
<!-- EN-Revision: 1.88 Maintainer: dallas Status: ready -->
 <chapter id="language.types">
  <title>类型</title>

  <sect1 id="language.types.intro">
  <title>介绍</title>
  
  <simpara>
   PHP 支持八种原始类型。<!-- (all types are primitive in php) -->
  </simpara>
  
  <para>
   四种标量类型： <!-- (basic, can't be split into parts) -->

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.boolean">布尔型（boolean）</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.integer">整型（integer）</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.float">浮点型（float）</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.string">字符串（string）</link>
     </simpara>
    </listitem>

   </itemizedlist>

   两种复合类型：

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.array">数组（array）</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.object">对象（object）</link>
     </simpara>
    </listitem>

   </itemizedlist>

   最后是两种特殊类型：

   <itemizedlist>

    <listitem>
     <simpara>
      <link linkend="language.types.resource">资源（resource）</link>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <link linkend="language.types.null">NULL</link>
     </simpara>
    </listitem>

   </itemizedlist>
  </para>
  
  <note>
   <simpara>
    本手册中你经常会碰到 <literal>mixed</literal> 参数。这个伪类型表示该参数有多种可能的类型。
   </simpara>
   <!--
   
   Just an idea, maybe useful for some func-defs?
   (at least it is for the operator-defs)
   
   <simpara>
    In parameter definitions you can also encounter the 'number' pseudo-type,
    that indicates a parameter that is either <type>integer</type> or 
    <type>float</type>.
   </simpara>
   -->
  </note>


  <simpara>
   变量的类型通常不是由程序员设定的，确切地说，是由 PHP 根据该变量使用的上下文在运行时决定的。
  </simpara>
  <note>
   <simpara>
    如果你想查看某个<link linkend="language.expressions">表达式</link>的值和类型，用 <function>var_dump</function>。
   </simpara>
   <simpara>
    如果你只是想得到一个易读懂的类型的表达方式用于调试，用 <function>gettype</function>。要查看某个类型，<emphasis>不要</emphasis>用 <function>gettype</function>，而用 <literal>is_<replaceable>type</replaceable></literal> 函数。
   </simpara>
   <!-- TODO: example(s) would be great -->
  </note>
  <simpara>
   如果你要将一个变量强制转换为某类型，可以对其使用<link
   linkend="language.types.typecasting">强制转换</link>或者 <function>settype</function> 函数。
  </simpara>
  <simpara>
   注意变量根据其当时的类型在特定场合下会表现出不同的风格。更多信息见<link linkend="language.types.type-juggling">类型戏法</link>。
  </simpara>
  
   
   </sect1>
   
   <sect1 id="language.types.boolean">
    <title>布尔型</title>
    
    <simpara>
     这是最简单的类型。<type>boolean</type> 表达了真值，可以为 &true; 或 &false;。
    </simpara>

    <note>
     <simpara>
      布尔类型是 PHP 4 引进的。
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>语法</title>
     <para>
      要指定一个布尔值，使用关键字 &true; 或 &false;。两个都是大小写不敏感的。
      <!-- technically they are just constants -->
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo = True; // assign the value TRUE to $foo     
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      通常你用某些<link linkend="language.operators">运算符</link>返回 <type>boolean</type> 值，并将其传递给<link
      linkend="control-structures">流程控制</link>。
      <informalexample>
       <programlisting role="php">
<![CDATA[
// == is an operator which returns a boolean
if ($action == "show_version") {
    echo "The version is 1.23";
}

// this is not necessary:
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// because you can simply type this:
if ($show_separators) {
    echo "<hr>\n";
}
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>转换为布尔值</title>
      <simpara>
       要明示地将一个值转换成 <type>boolean</type>，用 <literal>(bool)</literal> 或者 <literal>(boolean)</literal> 来强制转换。但是很多情况下不需要用强制转换，因为当运算符，函数或者流程控制需要一个 <type>boolean</type> 参数时，该值会被自动转换。
      </simpara>
      <simpara>
       参见<link linkend="language.types.type-juggling">类型戏法</link>。
      </simpara>
      
      <para>
       当转换为 <type>boolean</type> 时，以下值被认为是 &false;：
  
       <itemizedlist>
        <listitem>
         <simpara><link linkend="language.types.boolean">布尔</link>值 &false;</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.integer">整型</link>值 0（零）</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.float">浮点型</link>值 0.0（零）</simpara>
        </listitem>
        <listitem>
         <simpara>空白<link linkend="language.types.string">字符串</link>和<link
         linkend="language.types.string">字符串</link> "0"</simpara>
        </listitem>
        <listitem>
         <simpara>没有单元的<link linkend="language.types.array">数组</link></simpara>
        </listitem>
        <listitem>
         <simpara>没有单元的<link linkend="language.types.object">对象</link></simpara>
        </listitem>
        <listitem>
         <simpara>特殊类型<link linkend="language.types.null">NULL</link>（包括尚未设定的变量）</simpara>
        </listitem>
       </itemizedlist>
       
       所有其它值都被认为是 &true;（包括任何<link linkend="language.types.resource">资源</link>）。
       <warning>
        <simpara>
         <literal>-1</literal> 和其它非零值（不论正负）一样，被认为是 &true;！
        </simpara>
       </warning>
       <!-- TODO: add a few examples, for the people only looking at 
            the examples... -->
      </para>
     
    </sect2>

   </sect1>

   <sect1 id="language.types.integer">
    <title>整型</title>
    
    <simpara>
     一个 <type>integer</type> 是集合 Z = {..., -2, -1, 0, 1, 2, ...} 中的一个数。
    </simpara>
     
    <para>
     参见<link linkend="ref.gmp">任意长度整数</link>和<link linkend="language.types.float">浮点数</link>。
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>语法</title>
     <simpara>
      整型值可以用十进制，十六进制或八进制符号指定，前面可以加上可选的符号（- 或者 +）。
     </simpara>
     <para>
      如果用八进制符号，数字前必须加上 <literal>0</literal>（零），用十六进制符号数字前必须加上 <literal>0x</literal>。
      <example>
       <title>整数文字表达</title>
       <programlisting role="php">
<![CDATA[
$a = 1234; # 十进制数
$a = -123; # 一个负数
$a = 0123; # 八进制数（等于十进制的 83）
$a = 0x1A; # 十六进制数（等于十进制的 26）
]]>
       </programlisting>
      </example>
      <!--

       decimal     : [1-9][0-9]*
                   | 0
       
       hexadecimal : 0[xX][0-9a-fA-F]+
       
       octal       : 0[0-7]+
       
       integer     : [+-]?decimal
                   | [+-]?hexadecimal
                   | [+-]?octal
       
       -->
      整型数的字长和平台有关，尽管通常最大值是大约二十亿（32 位有符号）。PHP 不支持无符号整数。
     </para>
    </sect2>
   
    <sect2 id="language.types.integer.overflow">
     <title>整数溢出</title>
     <para>
      如果你指定一个数超出了 <type>integer</type> 的范围，将会被解释为 <type>float</type>。同样如果你执行的运算结果超出了 <type>integer</type> 范围，也会返回 <type>float</type>。
      <informalexample>
       <programlisting role="php">
<![CDATA[
$large_number =  2147483647;
var_dump($large_number);
// 输出为：int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// 输出为：float(2147483648)

// 同样也适用于十六进制表示的整数：
var_dump( 0x80000000 );
// 输出为：float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// 输出为：float(50000000000)
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        不幸的是 PHP 中有个 bug，因此当有负数参与时结果并不总是正确。例如当运算 <literal>-50000 *
        $million</literal> 时结果是 <literal>-429496728</literal>。不过当两个运算数都是正数时就没问题。
       </simpara>
       <simpara>
        这个问题已经在 PHP 4.1.0 中解决了。
       </simpara>
      </warning>
     </para>
     <para>
      PHP 中没有整除的运算符。<literal>1/2</literal> 产生出 <type>float</type> <literal>0.5</literal>。
      <informalexample>
       <programlisting role="php">
<![CDATA[
var_dump( 25/7 );
// 输出为：float(3.5714285714286)
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   

    <sect2 id="language.types.integer.casting">
     <title>转换为整形</title>
      <simpara>
       要明示地将一个值转换为 <type>integer</type>，用 <literal>(int)</literal> 或 <literal>(integer)</literal> 强制转换。不过大多数情况下都不需要强制转换，因为当运算符，函数或流程控制需要一个 <type>integer</type> 参数时，值会自动转换。
      </simpara>
      <simpara>
       参见<link linkend="language.types.type-juggling">类型戏法</link>。
      </simpara>
      
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>从<link linkend="language.types.boolean">布尔值</link>转换</title>
       <simpara>
        &false; 将产生出 <literal>0</literal>（零），&true; 将产生出 <literal>1</literal>（壹）。
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title>从<link linkend="language.types.float">浮点数</link>转换</title> 
       <simpara>
        当从浮点数转换成整数时，数字将被取整（<emphasis>丢弃小数位</emphasis>）。
       </simpara>
       
       <para>
        如果浮点数超出了整数范围（通常为 <literal>+/- 2.15e+9 = 2^31</literal>），则结果不确定，因为没有足够的精度使浮点数给出一个确切的整数结果。在此情况下没有警告，甚至没有任何通知！
       </para>

       <para>
        （译者注：）在 Linux 下返回结果是最小负数（-2147483648），而在 Windows 下返回结果是零（0）。
       </para>
       
       <warning><para>
        决不要将未知的分数强制转换为 <type>integer</type>，这样有时会导致意外的结果。
        <informalexample>
         <programlisting role="php">
<![CDATA[
echo (int) ( (0.1+0.7) * 10 ); // echoes 7!
]]>
         </programlisting>
        </informalexample>
        更多信息见<link linkend="warn.float-precision">浮点数精度</link>。
       </para></warning>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-string">
       <title>从字符串转换</title>
       <simpara>
        参见<link linkend="language.types.string.conversion">字符串转换</link>。
       </simpara>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-other">
       <title>从其它类型转换</title>
       <para>
        <caution>
         <simpara>
          没有定义从其它类型转换为整型的行为。目前的行为和值先<link
          linkend="language.types.boolean.casting">转换为布尔值</link>一样。不过<emphasis>不要</emphasis>依靠此行为，因为它会未加通知地改变。
         </simpara>
        </caution>
       </para>
       <!--
        
        IMO, it would more sense as (int) $arr returned the 
        number of elements in $arr. This won't break anything,
        since this behaviour was never defined before, and 
        (bool)(int) $arr will still behave the same.
        
        -->
      </sect3>
      
    </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>浮点型</title>
   <para>
    浮点数（也叫“floats”，“doubles”或“real numbers”）可以用以下任何语法定义：
    <synopsis>
$a = 1.234; $a = 1.2e3; $a = 7E-10;
    </synopsis>
    <!--  
    
LNUM	[0-9]+
DNUM	([0-9]*[\.][0-9]+)|([0-9]+[\.][0-9]*)
EXPONENT_DNUM	(({LNUM}|{DNUM})[eE][+-]?{LNUM})
    
    -->
    浮点数的字长和平台相关，尽管通常最大值是 1.8e308 并具有 14 位十进制数字的精度（64 位 IEEE 格式）。
   </para>
   <warning id="warn.float-precision">
    <title>浮点数精度</title>
    <para>
     显然简单的十进制分数如同 <literal>0.1</literal> 或 <literal>0.7</literal> 不能在不丢失一点点精度的情况下转换为内部二进制的格式。这就会造成混乱的结果：例如，<literal>floor((0.1+0.7)*10)</literal> 通常会返回 <literal>7</literal> 而不是预期中的 <literal>8</literal>，因为该结果内部的表示其实是类似 <literal>7.9999999999...</literal>。
    </para>
    <para>
     这和一个事实有关，那就是不可能精确的用有限位数表达某些十进制分数。例如，十进制的 <literal>1/3</literal> 变成了 <literal>0.3333333. . .</literal>。
    </para>
    <para>
     所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用<link
     linkend="ref.bc">任意精度数学函数库</link>或者 <link linkend="ref.gmp">gmp 函数库</link>。
    </para>
   </warning>
  </sect1>

  <sect1 id="language.types.string">
   <title>字符串</title>
   <para>
    <type>string</type> 是一系列字符。在 PHP 中，字符和字节一样，也就是说，一共有 256 种不同字符的可能性。这也暗示 PHP 对 Unicode 没有本地支持。
    <!-- how about unicode? will we support that eventually? Are
    there current any ways to work with unicode?
    -->
   </para>
   <note>
    <simpara>
     一个字符串变得非常巨大也没有问题，PHP 没有给字符串的大小强加实现范围，所以完全没有理由担心长字符串。
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>语法</title>
    <para>
     字符串可以用三种字面上的方法定义。
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">单引号</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">双引号</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">定界符</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>单引号</title>
     <para>
      指定一个简单字符串的最简单的方法是用单引号（字符 <literal>'</literal>）括起来。
     </para>
     <para>
      要表示一个单引号，需要用反斜线（<literal>\</literal>）转义，和很多其它语言一样。如果在单引号之前或字符串结尾需要出现一个反斜线，需要用两个反斜线表示。注意如果你试图转义任何其它字符，反斜线本身也会被显示出来！所以通常不需要转义反斜线本身。
      <note>
       <simpara>
        在 PHP 3 中，此情况下将发出一个 <literal>E_NOTICE</literal> 级的警告。
       </simpara>
      </note>
      <note>
       <simpara>
        和其他两种语法不同，单引号字符串中出现的变量<emphasis>不会</emphasis>被变量的值替代。
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo 'this is a simple string';
echo 'You can also have embedded newlines in strings,
like this way.';
echo 'Arnold once said: "I\'ll be back"';
// output: ... "I'll be back"
echo 'Are you sure you want to delete C:\\*.*?';
// output: ... delete C:\*.*?
echo 'Are you sure you want to delete C:\*.*?';
// output: ... delete C:\*.*?
echo 'I am trying to include at this point: \n a newline';
// output: ... this point: \n a newline
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>双引号</title>
     <para>
      如果用双引号（"）括起字符串，PHP 懂得更多特殊字符的转义序列：
     </para>
     <table>
      <title>转义字符</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>序列</entry>
         <entry>含义</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>换行（LF 或 ASCII 字符 0x0A（10））</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>回车（CR 或 ASCII 字符 0x0D（13））</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>水平制表符（HT 或 ASCII 字符 0x09（9））</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>反斜线</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>美元符号</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>双引号</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          此正则表达式序列匹配一个用八进制符号表示的字符
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          此正则表达式序列匹配一个用十六进制符号表示的字符
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      此外，如果试图转义任何其它字符，反斜线本身也会被显示出来！
     </para>
     <para>
      双引号字符串最重要的一点是其中的变量名会被变量值替代。细节参见<link linkend="language.types.string.parsing">字符串解析</link>。
     </para>
    </sect3>
    
    <sect3 id="language.types.string.syntax.heredoc">
     <title>定界符</title>
     <simpara>
      另一种给字符串定界的方法使用定界符语法（“&lt;&lt;&lt;”）。应该在 <literal>&lt;&lt;&lt;</literal> 之后提供一个标识符，然后是字符串，然后是同样的标识符结束字符串。
     </simpara>     
     <simpara>
      结束标识符<emphasis>必须</emphasis>从行的第一列开始。同样，标识符也必须遵循 PHP 中其它任何标签的命名规则：只能包含字母数字下划线，而且必须以下划线或非数字字符开始。
     </simpara>
     
     <warning>
      <simpara>
       很重要的一点必须指出，结束标识符所在的行不能包含任何其它字符，<emphasis>可能</emphasis>除了一个分号（<literal>;</literal>）之外。这尤其意味着该标识符<emphasis>不能被缩进</emphasis>，而且在分号之前和之后都不能有任何空格或制表符。
      </simpara>
     </warning>

     <para>
      定界符文本表现的就和双引号字符串一样，只是没有双引号。这意味着在定界符文本中不需要转义引号，不过仍然可以用以上列出来的转义代码。变量会被展开，但当在定界符文本中表达复杂变量时和字符串一样同样也要注意。
      <example> 
       <title>定界符字符串例子</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* More complex example, with variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>
  
     <note>
      <para>
       定界符支持是 PHP 4 中加入的。
      </para>
     </note>
  
    </sect3>
    <sect3 id="language.types.string.parsing">
     <title>变量解析</title>
     <simpara>
      当用双引号或者定界符指定字符串时，其中的变量会被解析。
     </simpara>
     <simpara>
      有两种语法，一种<link linkend="language.types.string.parsing.simple">简单的</link>和一种<link
      linkend="language.types.string.parsing.complex">复杂的</link>。简单语法最通用和方便，它提供了解析变量，数组值，或者对象属性的方法。
     </simpara>
     <simpara>
      复杂语法是 PHP 4 引进的，可以用花括号括起一个表达式。
      <!-- XXX was it? and starting with what version exactly? -->
     </simpara>
     <sect4 id="language.types.string.parsing.simple">
      <title>简单语法</title>
      <simpara>
       如果遇到美元符号（<literal>$</literal>），解析器会尽可能多地取得后面的字符以组成一个合法的变量名。如果你想明示指定名字的结束，用花括号把变量名括起来。
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$beer = 'Heineken';
echo "$beer's taste is great"; // works, "'" is an invalid character for varnames
echo "He drank some $beers"; // won't work, 's' is a valid character for varnames
echo "He drank some ${beer}s"; // works
]]>
       </programlisting>
      </informalexample>
      <simpara>
       同样也可以解析数组索引或者对象属性。对于数组索引，右方括号（<literal>]</literal>）标志着索引的结束。对象属性则和简单变量适用同样的规则，尽管对于对象属性没有像变量那样的小技巧。
       <!-- XXX isn't &true; :(, this would be the trick
       Also,
       the same trick with curly-braces works if you
       want to limit the greediness of parsers (aren't they
       paying them enough or something?).
       -->
      
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
$fruits = array( 'strawberry' => 'red' , 'banana' => 'yellow' );

// note that this works differently outside string-quotes.
echo "A banana is $fruits[banana].";

echo "This square is $square->width meters broad.";

// Won't work. For a solution, see the complex syntax.
echo "This square is $square->width00 centimeters broad.";

]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       对于任何更复杂的情况，应该使用复杂语法。
      </simpara>
     </sect4>
     <sect4 id="language.types.string.parsing.complex">
      <title>复杂（花括号）语法</title>
      <simpara>
       不是因为语法复杂而称其为复杂，而是因为用此方法可以包含复杂的表达式。
     </simpara>
     <simpara>
      事实上，用此语法你可以在字符串中包含任何在名字空间的值。仅仅用和在字符串之外同样的方法写一个表达式，然后用 { 和 } 把它包含进来。因为不能转义“{”，此语法仅在 $ 紧跟在 { 后面时被识别（用“{\$”或者“\{$”来得到一个字面上的“{$”）。用一些例子可以更清晰：
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
$great = 'fantastic';
echo "This is { $great}"; // 不行，输出为：This is { fantastic}
echo "This is {$great}";  // 可以，输出为：This is fantastic
echo "This square is {$square->width}00 centimeters broad."; 
echo "This works: {$arr[4][3]}";     

// This is wrong for the same reason
// as $foo[bar] is wrong outside a string. 
echo "This is wrong: {$arr[foo][3]}"; 

echo "You should do it this way: {$arr['foo'][3]}";
echo "You can even write {$obj->values[3]->name}";
echo "This is the value of the var named $name: {${$name}}";
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>访问字符串中的字符</title>
     <para>
      字符串中的字符可以通过在字符串之后用花括号指定所要字符从零开始的偏移量来访问。
     </para>
     <note>
      <simpara>
       为了向下兼容，仍然可以用方括号。不过此语法在 PHP 4 中不赞成使用。
      </simpara>
     </note>
     <para>
      <example>
       <title>一些字符串例子</title>
       <programlisting role="php">
<!-- TODO: either move these examples to a example section,
as with arrays, or distribute them under the applicable
sections. -->
<![CDATA[
<?php
/* Assigning a string. */
$str = "This is a string";

/* Appending to it. */
$str = $str . " with some more text";

/* Another way to append, includes an escaped newline. */
$str .= " and a newline at the end.\n";

/* This string will end up being '<p>Number: 9</p>' */
$num = 9;
$str = "<p>Number: $num</p>";

/* This one will be '<p>Number: $num</p>' */
$num = 9;
$str = '<p>Number: $num</p>';

/* Get the first character of a string  */
$str = 'This is a test.';
$first = $str{0};

/* Get the last character of a string. */
$str = 'This is still a test.';
$last = $str{strlen($str)-1};
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>实用函数</title><!-- and operators -->
    <para>
     字符串可以用“.”（点）运算符连接。注意这里不能用“+”（加）运算符。更多信息参见<link
     linkend="language.operators.string">字符串运算符</link>。
    </para>
    <para>
     有很多实用函数来改变字符串。
    </para>
    <simpara>
     普通函数见<link linkend="ref.strings">字符串函数库</link>一节，高级搜索和替换见正则表达式函数（两种口味：<link
     linkend="ref.pcre">Perl</link> 和 <link linkend="ref.regex">POSIX 扩展</link>）。
    </simpara>
    <simpara>
     还有 <link linkend="ref.url">URL 字符串函数</link>，以及加密／解密字符串的函数（<link
     linkend="ref.mcrypt">mcrypt</link> 和 <link linkend="ref.mhash">mhash</link>）。
    </simpara>
    <simpara>
     最后，如果还是找不到你要的函数，参见<link linkend="ref.ctype">字符类型函数库</link>。
    </simpara>
   </sect2>
   <sect2 id="language.types.string.conversion">
    <title>字符串转换</title>

    <simpara>
     当一个字符串被当作数字来求值时，根据以下规则来决定结果的类型和值。
    </simpara>
    <simpara>
     如果包括“.”，“e”或“E”其中任何一个字符的话，字符串被当作 <type>float</type> 来求值。否则就被当作整数。
    </simpara>
    <para>
     该值由字符串最前面的部分决定。如果字符串以合法的数字数据开始，就用该数字作为其值，否则其值为 0（零）。合法数字数据由可选的正负号开始，后面跟着一个或多个数字（可选地包括十进制分数），后面跟着可选的指数。指数是一个“e”或者“E”后面跟着一个或多个数字。
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
$foo = 1 + "10.5";              // $foo is float (11.5)
$foo = 1 + "-1.3e3";            // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";         // $foo is integer (1)
$foo = 1 + "bob3";              // $foo is integer (1)
$foo = 1 + "10 Small Pigs";     // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;        // $foo is float (11)
$foo = "10.0 pigs " + 1.0;      // $foo is float (11)     
]]>
     </programlisting>
    </informalexample>
    <simpara>
     此转换的更多信息见 Unix 手册中关于 strtod(3) 的部分。
    </simpara>
    <para>
     如果你想测试本节中的任何例子，可以拷贝和粘贴这些例子并且加上下面这一行自己看看会发生什么：
     <informalexample>
      <programlisting role="php">
<![CDATA[
echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";
]]>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>数组</title>

   <para>
    PHP 中的数组实际上是一个有序图。图是一种把 <emphasis>values</emphasis> 映射到 <emphasis>keys</emphasis> 的类型。此类型在很多方面做了优化，因此你可以把它当成真正的数组来使用，或列表（矢量），散列表（是图的一种实现），字典，集合，栈，队列以及更多可能性。因为可以用另一个 PHP 数组作为值，也可以很容易地模拟树。
   </para>
   <para>
    解释这些结构超出了本手册的范围，但对于每种结构你至少会发现一个例子。要得到这些结构的更多信息，我们建议你参考有关此广阔主题的外部著作。
    <!-- like goodrich&tamassia: datastructures and algorithmes.
    Only, the subtitle is: in Java, and it's quite academic too -->
   </para>
   
   <sect2 id="language.types.array.syntax">
    <title>语法</title>
    
    <sect3 id="language.types.array.syntax.array-func">
     <title>定义 <function>array</function></title>
     <para>
      可以用 <function>array</function> 语言结构来新建一个 <type>array</type>。它接受一定数量用逗号分隔的
      <literal><replaceable>key</replaceable> =&gt; <replaceable>value</replaceable></literal> 参数对。
     </para>
     <para>
      <varname>key</varname> 可以是 <type>integer</type> 或者 <type>string</type>。如果键名是一个
      <type>integer</type> 的标准表达方法，则被解释为整数（例如 <literal>"8"</literal> 将被解释为
      <literal>8</literal>，而 <literal>"08"</literal> 将被解释为 <literal>"08"</literal>）。
     </para>
     <para>
      值可以是任何值。
     </para>
     <para>
      如果省略键名，则取当前最大的整数索引，而新的键名将是该值加一。整数可以为负，所以对于负的索引也是这样。例如最大的索引是
      <literal>-6</literal> 将导致新的键名是 <literal>-5</literal>。如果还不存在整数索引，则键名将为
      <literal>0</literal>（零）。如果你指定的键名已经有了值，则该值会被覆盖。
     </para>
     <para>
      使用 <literal>true</literal> 作为键名将使 <type>integer</type> <literal>1</literal> 成为键名。使用
      <literal>false</literal> 作为键名将使 <type>integer</type> <literal>0</literal> 成为键名。使用
      <literal>NULL</literal> 作为键名将等同于使用空字符串。使用空字符串作为键名将新建（或覆盖）一个用空字符串作为键名的值，这和用空的方括号不一样。
     </para>
     <para>
      不能用数组和对象作为键名。这样做会导致一个警告：<literal>Illegal offset type</literal>。
     </para>
     
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable
>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> is either <type>string</type
                        > or nonnegative <type>integer</type>
// <replaceable>value</replaceable> can be anything
      </synopsis>
     </para>
    </sect3>
    
    <sect3 id="language.types.array.syntax.modifying">
     <title>用方括号的语法新建／修改</title>
     <para>
      可以通过明示地设定值来改变一个现有的数组。
     </para>
     <para>
      这是通过在方括号内指定键名来给数组赋值实现的。也可以省略键名，在这种情况下给变量名加上一对空的方括号（“<literal>[]</literal>”）。
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> is either <type>string</type> or nonnegative <type>integer</type>
// <replaceable>value</replaceable> can be anything
      </synopsis>
      如果 <varname>$arr</varname> 还不存在，将会新建一个。这也是一种定义数组的替换方法。要改变一个值，只要给它赋一个新值。如果要删除一个键名／值对，要对它用 <function>unset</function>。
     </para>

    </sect3>
    

   </sect2><!-- end syntax -->
   
   <sect2 id="language.types.array.useful-funcs">
    <title>实用函数</title>
    <para>
     有相当多的实用函数作用于数组，参见<link linkend="ref.array">数组函数库</link>一节。
    </para>
    <note>
     <para>
      <function>unset</function> 函数允许取消一个数组中的键名。要注意数组将不会重建索引。
      <informalexample>
       <programlisting role="php">
<![CDATA[
$a = array( 1 => 'one', 2 => 'two', 3 => 'three' );
unset( $a[2] );
/* 将产生一个数组，定义为
   $a = array( 1=>'one', 3=>'three');
   而不是
   $a = array( 1 => 'one', 2 => 'three');
*/   
]]>
      </programlisting>
     </informalexample>
     
     </para>    
    </note> 
    <para>
     <link linkend="control-structures.foreach">foreach</link> 控制结构是专门用于数组的。它提供了一个简单的方法来遍历数组。
    </para>
    
   </sect2>
   
   <sect2 id="language.types.array.donts">
    <title>数组做什么和不做什么</title>

    <sect3 id="language.types.array.foo-bar">
     <title>为什么 <literal>$foo[bar]</literal> 错了？</title>
     <para>
      应该始终在数组的索引上加上引号。例如用 $foo['bar'] 而不是 $foo[bar]。但是为什么 $foo[bar] 错了呢？你可能在老的脚本中见过如下语法：
      <informalexample>
       <programlisting role="php">
<![CDATA[
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
]]>
       </programlisting>
      </informalexample>
      这样是错的，但可以起作用。那么为什么错了呢？原因是此代码中有一个未定义的常量（bar）而不是字符串（'bar'－注意引号），而 PHP 可能会在以后定义此常量，不幸的是你的代码中有同样的名字。它可以起作用，因为未定义常量会被转换为同样名字的字符串。
     </para>
     <para>
      和在<link linkend="language.types.array.syntax">语法</link>一节中规定的一样，在方括号（“<literal>[</literal>”和“<literal>]</literal>”）之间必须有一个表达式。这意味着你可以这样写：
      <informalexample>
       <programlisting role="php">
<![CDATA[
echo $arr[ foo(true) ];        
]]>
       </programlisting>
      </informalexample>
      这是一个用函数返回值作为数组索引的例子。PHP 也可以用已知常量，你可能之前已经见过 <literal>E_*</literal>。
      <informalexample>
       <programlisting role="php">
<![CDATA[
$error_descriptions[E_ERROR] = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE] = "This is just an informal notice";
]]>
       </programlisting>
      </informalexample>
      注意 <literal>E_ERROR</literal> 也是个合法的标识符，就和第一个例子中的 <literal>bar</literal> 一样。但是上一个例子实际上和如下写法是一样的：
      <informalexample>
       <programlisting role="php">
<![CDATA[
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
]]>
       </programlisting>
      </informalexample>
      因为 <literal>E_ERROR</literal> 等于 <literal>1</literal>，等等。
     </para>
     <para>
      那么 <literal>$foo[bar]</literal> 怎么可能起作用的呢？它起作用是因为根据语法的预期，<literal>bar</literal> 被当成了一个常量表达式。然而，在这个例子中不存在名为
      <literal>bar</literal> 的常量。PHP 就假定你指的是字面上的 <literal>bar</literal>，也就是字符串
      <literal>"bar"</literal>，但你忘记写引号了。
     </para>
     <sect4>
      <title>那么为什么这样做不好？</title>
      <para>
       在未来的某一时刻，PHP 开发小组可能会想新增一个常量或者关键字，那你就有麻烦了。例如你已经不能这样用
       <literal>empty</literal> 和 <literal>default</literal> 这两个词了，因为他们是<link linkend="reserved">保留字</link>。
      </para>
      <note>
       <simpara>
        当你把 <link linkend="function.error-reporting">error_reporting</link> 设为
        <literal>E_ALL</literal> 时，你将会看到无论何时使用了未定义的
        <literal>index</literal> 时，PHP 都会产生通知（在你的脚本中加入一行 <literal>error_reporting(E_ALL);</literal>）。
       </simpara>
      </note>
      <note>
       <simpara>
        在双引号 <type>string</type> 中，另一种语法是合法的。细节见<link linkend="language.types.string.parsing">字符串中的变量解析</link>。
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.examples">
    <title>例子</title>
    <para>
     PHP 中的数组类型有非常多的用途，因此这里有一些例子展示数组的完整威力。
    </para>
    <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
// this
$a = array( 'color' => 'red'
          , 'taste' => 'sweet'
          , 'shape' => 'round'
          , 'name'  => 'apple'
          ,            4        // key will be 0
          );

// is completely equivalent with
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name'] = 'apple';
$a[]        = 4;        // key will be 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// will result in the array array( 0 => 'a' , 1 => 'b' , 2 => 'c' ),
// or simply array('a', 'b', 'c')
]]>
       </programlisting>
      </informalexample>
     </para>
    
    <example>
     <title>使用 array()</title>
     <programlisting role="php">
<![CDATA[
// Array as (property-)map
$map = array( 'version'    => 4
            , 'OS'         => 'Linux'
            , 'lang'       => 'english'
            , 'short_tags' => true
            );
            
// strictly numerical keys
$array = array( 7
              , 8
              , 0
              , 156
              , -10
              );
// this is the same as array( 0 => 7, 1 => 8, ...)

$switching = array(         10 // key = 0
                  , 5    =>  6
                  , 3    =>  7 
                  , 'a'  =>  4
                  ,         11 // key = 6 (maximum of integer-indices was 5)
                  , '8'  =>  2 // key = 8 (integer!)
                  , '02' => 77 // key = '02'
                  , 0    => 12 // the value 10 will be overwritten by 12
                  );
                  
// empty array
$empty = array();         
]]>
<!-- TODO example of
- mixed keys
- overwriting keys
- integer keys as string
- using vars/functions as key/values
- mixed skipping
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>集合</title>
     <programlisting role="php">
<![CDATA[
$colors = array('red','blue','green','yellow');

foreach ( $colors as $color ) {
    echo "Do you like $color?\n";
}

/* output:
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
*/
]]>
     </programlisting>
    </example>
    
    <para>
     注意目前不可能在这样一个循环中直接改变数组的值。可以改变的例子如下：
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &$color )
      
       See bug#3074
      -->
     <example id="language.types.array.examples.changeloop">
      <title>集合</title>
      <programlisting role="php">
<![CDATA[
foreach ($colors as $key => $color) {
    // won't work:
    //$color = strtoupper($color);
    
    //works:
    $colors[$key] = strtoupper($color);
}
print_r($colors);

/* output:
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
*/
]]>
      </programlisting>
     </example>
    </para>
    <para>
     本例产生一个基于一的数组。
     <example>
      <title>基于一的数组</title>
      <programlisting role="php">
<![CDATA[
$firstquarter  = array(1 => 'January', 'February', 'March');
print_r($firstquarter);

/* output:
Array 
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
*/
]]>   
      </programlisting>
     </example>
    </para>
    <example>
     <title>填充真正的数组</title>
     <programlisting role="php">
<![CDATA[
// fill an array with all items from a directory
$handle = opendir('.');
while ($file = readdir($handle)) 
{
    $files[] = $file;
}
closedir($handle); 
]]>
     </programlisting>
    </example>
    <para>
     数组是有序的。你也可以使用不同的排序函数来改变顺序。更多信息参见<link linkend="ref.array">数组函数库</link>。
    </para>
    <example>
     <title>数组排序</title>
     <programlisting role="php">
<![CDATA[
sort($files);
print_r($files);
]]>
     </programlisting>
    </example>
    <para>
     因为数组中的值可以为任意值，也可是另一个数组。这样你可以产生递归或多维数组。
    </para>
    <example>
     <title>递归和多维数组</title>
     <programlisting role="php">
<![CDATA[
$fruits = array ( "fruits"  => array ( "a" => "orange"
                                     , "b" => "banana"
                                     , "c" => "apple"
                                     )
                , "numbers" => array ( 1
                                     , 2
                                     , 3
                                     , 4
                                     , 5
                                     , 6
                                     )
                , "holes"   => array (      "first"
                                     , 5 => "second"
                                     ,      "third"
                                     )
                );
]]>
<!-- quite duplicate...
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);
-->
     </programlisting>
    </example>

   </sect2>
   
   <!-- TODO
   <sect2>
    <title>Misc</title>
   
   </sect2>
   
   - example multi-dim with $arr[bla][bla] syntax
   - converting to array
   - warning about references
   - note that assigning is copy (usually...)
   
   
   -->  

<!-- there is no such thing as multi/singel dim arrays (at least in PHP4) 
   <sect2 id="language.types.array.single-dim">
    <title>Single Dimension Arrays</title>

    <para>
     PHP supports both scalar and associative arrays. In fact, there
     is no difference between the two.  You can create an array using
     the 
     
     <function>list</function> 
     
     Nope
     
     
     
     
     or <function>array</function>
     functions, or you can explicitly set each array element value.
     <informalexample>
      <programlisting role="php"> 
$a[0] = "abc"; 
$a[1] = "def"; 
$b["foo"] = 13;
      </programlisting>
     </informalexample>
    </para>
    <para>
     You can also create an array by simply adding values to the
     array. When you assign a value to an array variable using empty
     brackets, the value will be added onto the end of the array.
     <informalexample>
      <programlisting role="php"> 
$a[] = "hello"; // $a[2] == "hello"
$a[] = "world"; // $a[3] == "world" 
      </programlisting>
     </informalexample>
    </para>
    <para>
     Arrays may be sorted using the <function>asort</function>,
     <function>arsort</function>, <function>ksort</function>,
     <function>rsort</function>, <function>sort</function>,
     <function>uasort</function>, <function>usort</function>, and
     <function>uksort</function> functions depending on the type of
     sort you want.
    </para>
    <para>
     You can count the number of items in an array using the
     <function>count</function> function.
    </para>
    <para>
     You can traverse an array using <function>next</function> and
     <function>prev</function> functions.  Another common way to
     traverse an array is to use the <function>each</function>
     function.
    </para>
   </sect2>

   <sect2 id="language.types.array.multi-dim">
    <title>Multi-Dimensional Arrays</title>

    <para>
     Multi-dimensional arrays are actually pretty simple.  For each
     dimension of the array, you add another [key] value to the end:
     <informalexample>
      <programlisting role="php"> 
$a[1]      = $f;               # one dimensional examples
$a["foo"]  = $f;   

$a[1][0]     = $f;             # two dimensional
$a["foo"][2] = $f;             # (you can mix numeric and associative indices)
$a[3]["bar"] = $f;             # (you can mix numeric and associative indices)

$a["foo"][4]["bar"][0] = $f;   # four dimensional!
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP 3 it is not possible to reference multidimensional arrays
     directly within strings. For instance, the following will not
     have the desired result:
     <informalexample>
      <programlisting role="php"> 
$a[3]['bar'] = 'Bob';
echo "This won't work: $a[3][bar]";
      </programlisting>
     </informalexample>
     In PHP 3, the above will output <computeroutput>This won't work:
     Array[bar]</computeroutput>. The string concatenation operator,
     however, can be used to overcome this:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This will work: " . $a[3]['bar'];
      </programlisting>
     </informalexample>
    </para>
    <para>
     In PHP 4, however, the whole problem may be circumvented by
     enclosing the array reference (inside the string) in curly
     braces:
     <informalexample>
      <programlisting role="php">
$a[3]['bar'] = 'Bob';
echo "This will work: {$a[3][bar]}";
      </programlisting>
     </informalexample>
    </para>
    <para>
     You can "fill up" multi-dimensional arrays in many ways, but the
     trickiest one to understand is how to use the
     <function>array</function> command for associative arrays.  These
     two snippets of code fill up the one-dimensional array in the
     same way:
     <informalexample>
      <programlisting role="php"> 
# Example 1:

$a["color"]	= "red";
$a["taste"]	= "sweet";
$a["shape"]	= "round";
$a["name"]	= "apple";
$a[3]		= 4;

# Example 2:
$a = array(
     "color" => "red",
     "taste" => "sweet",
     "shape" => "round",
     "name"  => "apple",
     3       => 4
);
      </programlisting>
     </informalexample>
    </para>
    <para>
     The <function>array</function> function can be nested for
     multi-dimensional arrays:
     <informalexample>
      <programlisting role="php"> 
&lt;?php
$a = array(
     "apple"  => array(
          "color"  => "red",
          "taste"  => "sweet",
          "shape"  => "round"
     ),
     "orange"  => array(
          "color"  => "orange",
          "taste"  => "tart",
          "shape"  => "round"
     ),
     "banana"  => array(
          "color"  => "yellow",
          "taste"  => "paste-y",
          "shape"  => "banana-shaped"
     )
);

echo $a["apple"]["taste"];    # will output "sweet"
?>
      </programlisting>
     </informalexample>
    </para>

   </sect2>
   
   -->
  </sect1>

  <sect1 id="language.types.object">
   <title>对象</title>

   <sect2 id="language.types.object.init">
    <title>对象初始化</title>

    <para>
     要初始化一个对象，用 <literal>new</literal> 语句将对象实例到一个变量中。

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     完整的讨论见<link linkend="language.oop">类与对象</link>一章。
    </simpara>

   </sect2>
  </sect1>

  <sect1 id="language.types.resource">
   <title>资源</title>
    
    <para>
     一个资源是一个特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。所有这些函数及其相应资源类型见<link linkend="resource">附录</link>。
    </para>
    
    <note>
     <simpara>
      资源类型是 PHP 4 引进的。
     </simpara>
    </note>

    <sect2 id="language.types.resource.self-destruct">
     <title>释放资源</title>
    
    <para>
     由于 PHP4 Zend 引擎引进了资源计数系统，可以自动检测到一个资源不再被引用了（和 Java 一样）。这种情况下此资源使用的所有外部资源都会被垃圾回收系统释放。由此原因，很少需要用某些 free-result 函数来手工释放内存。
     <note>
      <simpara>
       持久数据库连接比较特殊，它们<emphasis>不会</emphasis>被垃圾回收系统破坏。参见<link
       linkend="features.persistent-connections">数据库永久连接</link>一章。
      </simpara>
     </note>
    </para>
    
   </sect2>
  </sect1>
    
  <sect1 id="language.types.null">
   <title>NULL</title>
    
   <para>
    特殊的 &null; 值表示一个变量没有值。<type>NULL</type> 类型唯一可能的值就是 &null;。
   </para>
    <note>
     <simpara>
      <type>NULL</type> 类型是 PHP 4 引进的。
     </simpara>
    </note>
    <para>
     在下列情况下一个变量被认为是 &null;：
     <itemizedlist>
      <listitem>
       <para>
        被赋值为 &null;。
       </para>
      </listitem>
      <listitem>
       <para>
        尚未被赋值。
       </para>
      </listitem>
      <listitem>
       <para>
        被 <function>unset</function>。
       </para>
      </listitem>
     </itemizedlist>
    </para>
    
   <sect2 id="language.types.null.syntax">
    <title>语法</title>
    <para>
     &null; 类型只有一个值，就是大小写敏感的关键字 &null;。
     <informalexample>
      <programlisting role="php">
$var = NULL;       
      </programlisting>
     </informalexample>
    </para>
    <para>
     参见 <function>is_null</function> 和 <function>unset</function>。
    </para>
   </sect2>
  
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>类型戏法</title>

   <simpara>
    PHP 在变量定义中不需要（或不支持）明示的类型定义；变量类型是根据使用该变量的上下文所决定的。也就是说，如果你把一个字符串值赋给变量
    <parameter>var</parameter>，<parameter>var</parameter> 就成了一个字符串。如果你又把一个整型值赋给
    <parameter>var</parameter>，那它就成了一个整数。
   </simpara>
   <para>
    PHP 的自动类型转换的一个例子是加号“+”。如果任何一个运算数是浮点数，则所有的运算数都被当成浮点数，结果也是浮点数。否则运算数会被解释为整数，结果也是整数。注意这并没有改变这些运算数本身的类型；改变的仅是这些运算数如何被求值。
    <informalexample>
     <programlisting role="php">
$foo = "0";  // $foo is string (ASCII 48)
<!-- bad example, no real operator (must be used with variable, modifies it too)
$foo++;      // $foo is the string "1" (ASCII 49)
-->
$foo += 2;   // $foo is now an integer (2)
$foo = $foo + 1.3;  // $foo is now a float (3.3)
$foo = 5 + "10 Little Piggies"; // $foo is integer (15)
$foo = 5 + "10 Small Pigs";     // $foo is integer (15)
<!--

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    如果上面两个例子看上去古怪的话，参见<link linkend="language.types.string.conversion">字符串转换</link>。
   </simpara>
   <simpara>
    如果你要强制将一个变量当作某种类型来求值，参见<link
    linkend="language.types.typecasting">类型强制转换</link>一节。如果你要改变一个变量的类型，参见 <function>settype</function>。
   </simpara>
   <para>
    如果你想要测试本节中任何例子的话，可以用 <function>var_dump</function> 函数。
   </para>
   <note>
    <para>
     数组的自动转换行为目前没有定义。
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
$a = "1";     // $a 是字符串
$a[0] = "f";  // 是字符串偏移量吗？结果会是什么？
      </programlisting>
     </informalexample>
    </para>
    <para>
     由于 PHP 支持通过偏移量进行的字符串索引，这和数组索引的语法一样。以上的例子就产生了一个问题：$a
     应该变成一个第一个元素是“f”的数组呢，还是“f”成了字符串 $a 的第一个字符？
    </para>
    <para>
     由于此原因，在 PHP 3.0.12 和 PHP 4.0b3-RC4 中这种自动转换的结果被当成未定义。解决方案仍在讨论之中。
    </para>
    <para>
     （译者注：）PHP 4 中上面的一个例子出错，第二个例子的结果将是字符串 $a = 'f'。
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>类型强制转换</title>

    <para>
     PHP 中的类型强制转换和 C 中的非常像：在要转换的变量之前加上用括号括起来的目标类型。
     <informalexample>
      <programlisting role="php">
$foo = 10;   // $foo is an integer
$bar = (float) $foo;   // $bar is a float
      </programlisting>
     </informalexample>
    </para>
    <para>
     允许的强制转换有：
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - 转换成整型</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - 转换成布尔型</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - 转换成浮点型</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - 转换成字符串</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - 转换成数组</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - 转换成对象</simpara>
      </listitem>
     </itemizedlist>
    </para>
    <note>
     <simpara>
      除了用强制转换将变量转换成字符串之外，还可以将变量用双引号引起来。
      <!-- TODO: example -->
     </simpara>
    </note>
     
    <para>
     注意在括号内允许有空格和制表符，所以下面两个例子功能相同：
     <informalexample>
      <programlisting role="php">
$foo = (int) $bar;
$foo = ( int ) $bar;
      </programlisting>
     </informalexample>
    </para>
    <para>
     当在某些类型之间强制转换时确切地会发生什么可能不是很明显。更多信息见如下小节：

     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">转换为布尔值</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">转换为整型</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.float.casting">Converting to 
        float</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">Converting to 
        string</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">Converting to 
        array</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">Converting to 
        object</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">Converting to 
        resource</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    
    </para>
    <para>
     <!-- TODO: move to 'converting to string' -->
     当强制将数组转换为字符串时，结果将是 <literal>Array</literal> 这个词。当强制将对象转换为字符串时，结果将是 <literal>Object</literal> 这个词。
    </para>
    <para>
     当强制将一个标量或字符串转换为数组时，变量将成为数组的第一个元素：
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$arr = (array) $var;
echo $arr[0];  // outputs 'ciao'  
      </programlisting>
     </informalexample>
    </para>
    <para>
     当强制将一个标量或字符串转换为对象时，变量会成为对象的属性，属性名为“scalar”：
     <informalexample>
      <programlisting role="php">
$var = 'ciao';
$obj = (object) $var;
echo $obj-&gt;scalar;  // outputs 'ciao'
      </programlisting>
     </informalexample>
    </para>

   </sect2>
  </sect1>

 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
