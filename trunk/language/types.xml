<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.10 $ -->
<!-- $Author: dallas $ -->
<!-- EN-Revision: 1.110 Maintainer: dallas Status: ready -->
<!-- CREDITS: Gregory -->
 <chapter id="language.types">
  <title>类型</title>

  <sect1 id="language.types.intro">
  <title>介绍</title>
  
  <simpara>
   PHP 支持八种原始类型。
  </simpara>
  
  <para>
   四种标量类型： 

   <itemizedlist>

    <listitem>
     <simpara>
      <type>布尔型（boolean）</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>整型（integer）</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>浮点型（float）</type>（浮点数，也作“<type>double</type>”）
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>字符串（string）</type>
     </simpara>
    </listitem>

   </itemizedlist>

   两种复合类型：

   <itemizedlist>

    <listitem>
     <simpara>
      <type>数组（array）</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>对象（object）</type>
     </simpara>
    </listitem>

   </itemizedlist>

   最后是两种特殊类型：

   <itemizedlist>

    <listitem>
     <simpara>
      <type>资源（resource）</type>
     </simpara>
    </listitem>

    <listitem>
     <simpara>
      <type>NULL</type>
     </simpara>
    </listitem>

   </itemizedlist>

   为了确保代码的易读性，本手册还介绍了一些<link linkend="language.pseudo-types">伪类型</link>：

   <itemizedlist>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">混和（mixed）</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.number">数字（number）</link>
     </simpara>
    </listitem>
 
    <listitem>
     <simpara>
      <link linkend="language.types.mixed">回馈（callback）</link>
     </simpara>
    </listitem>

   </itemizedlist>
   您可能还会读到一些关于“双精度（double）”类型的参考。实际上 double 和 float 是相同的，由于一些历史的原因，这两个名称同时存在。
  </para>
  
  <simpara>
   变量的类型通常不是由程序员设定的，确切地说，是由 PHP 根据该变量使用的上下文在运行时决定的。
  </simpara>
  <note>
   <simpara>
    如果你想查看某个<link linkend="language.expressions">表达式</link>的值和类型，用 <function>var_dump</function>。
   </simpara>
   <para>
    如果你只是想得到一个易读懂的类型的表达方式用于调试，用 <function>gettype</function>。要查看某个类型，<emphasis>不要</emphasis>用 <function>gettype</function>，而用 <literal>is_<replaceable>type</replaceable></literal> 函数。以下是一些范例：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // a boolean
$str  = "foo";  // a string
$int  = 12;     // an integer

echo gettype($bool); // prints out "boolean"
echo gettype($str);  // prints out "string"

// If this is an integer, increment it by four
if (is_int($int)) {
    $int += 4;
}

// If $bool is a string, print it out
// (does not print out anything)
if (is_string($bool)) {
    echo "String: $bool";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>
  <simpara>
   如果你要将一个变量强制转换为某类型，可以对其使用<link
   linkend="language.types.typecasting">强制转换</link>或者 <function>settype</function> 函数。
  </simpara>
  <simpara>
   注意变量根据其当时的类型在特定场合下会表现出不同的值。更多信息见<link linkend="language.types.type-juggling">类型戏法</link>。
  </simpara>
   </sect1>
   
   <sect1 id="language.types.boolean">
    <title>布尔型</title>
    
    <simpara>
     这是最简单的类型。<type>boolean</type> 表达了真值，可以为 &true; 或 &false;。
    </simpara>

    <note>
     <simpara>
      布尔类型是 PHP 4 引进的。
     </simpara>
    </note>

    <sect2 id="language.types.boolean.syntax">
     <title>语法</title>
     <para>
      要指定一个布尔值，使用关键字 &true; 或 &false;。两个都是大小写不敏感的。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo = True; // assign the value TRUE to $foo
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      通常你用某些<link linkend="language.operators">运算符</link>返回 <type>boolean</type> 值，并将其传递给<link
      linkend="control-structures">流程控制</link>。
      <informalexample>
       <programlisting role="php">
<![CDATA[
// == is an operator which test
// equality and returns a boolean
if ($action == "show_version") {
    echo "The version is 1.23";
}

// this is not necessary...
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// ...because you can simply type
if ($show_separators) {
    echo "<hr>\n";
}
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>

    <sect2 id="language.types.boolean.casting">
     <title>转换为布尔值</title>
      <simpara>
       要明示地将一个值转换成 <type>boolean</type>，用 <literal>(bool)</literal> 或者 <literal>(boolean)</literal> 来强制转换。但是很多情况下不需要用强制转换，因为当运算符，函数或者流程控制需要一个 <type>boolean</type> 参数时，该值会被自动转换。
      </simpara>
      <simpara>
       参见<link linkend="language.types.type-juggling">类型戏法</link>。
      </simpara>
      
      <para>
       当转换为 <type>boolean</type> 时，以下值被认为是 &false;：
  
       <itemizedlist>
        <listitem>
         <simpara><link linkend="language.types.boolean">布尔</link>值 &false;</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.integer">整型</link>值 0（零）</simpara>
        </listitem>
        <listitem>
         <simpara><link linkend="language.types.float">浮点型</link>值 0.0（零）</simpara>
        </listitem>
        <listitem>
         <simpara>空白<link linkend="language.types.string">字符串</link>和<link
         linkend="language.types.string">字符串</link> "0"</simpara>
        </listitem>
        <listitem>
         <simpara>没有成员变量的<link linkend="language.types.array">数组</link></simpara>
        </listitem>
        <listitem>
         <simpara>没有单元的<link linkend="language.types.object">对象</link></simpara>
        </listitem>
        <listitem>
         <simpara>特殊类型<link linkend="language.types.null">NULL</link>（包括尚未设定的变量）</simpara>
        </listitem>
       </itemizedlist>
       
       所有其它值都被认为是 &true;（包括任何<link linkend="language.types.resource">资源</link>）。
       <warning>
        <simpara>
         <literal>-1</literal> 和其它非零值（不论正负）一样，被认为是 &true;！
        </simpara>
       </warning>
       <informalexample>
        <programlisting role="php">
<![CDATA[
<?php
echo gettype((bool) "");        // bool(false)
echo gettype((bool) 1);         // bool(true)
echo gettype((bool) -2);        // bool(true)
echo gettype((bool) "foo");     // bool(true)
echo gettype((bool) 2.3e5);     // bool(true)
echo gettype((bool) array(12)); // bool(true)
echo gettype((bool) array());   // bool(false)
?>
]]>
        </programlisting>
       </informalexample>
      </para>
     
    </sect2>

   </sect1>

   <sect1 id="language.types.integer">
    <title>整型</title>
    
    <simpara>
     一个 <type>integer</type> 是集合 Z = {..., -2, -1, 0, 1, 2, ...} 中的一个数。
    </simpara>
     
    <para>
     参见<link linkend="ref.gmp">任意长度整数</link>和<link linkend="language.types.float">浮点数</link>。
    </para>

    <sect2 id="language.types.integer.syntax">
     <title>语法</title>
     <simpara>
      整型值可以用十进制，十六进制或八进制符号指定，前面可以加上可选的符号（- 或者 +）。
     </simpara>
     <para>
      如果用八进制符号，数字前必须加上 <literal>0</literal>（零），用十六进制符号数字前必须加上 <literal>0x</literal>。
      <example>
       <title>整数文字表达</title>
       <programlisting role="php">
<![CDATA[
<?php
$a = 1234; # 十进制数
$a = -123; # 一个负数
$a = 0123; # 八进制数（等于十进制的 83）
$a = 0x1A; # 十六进制数（等于十进制的 26）
?>
]]>
       </programlisting>
      </example>
	  在字面上，整型变量正式的结构可以为：
      <informalexample>
       <programlisting>
<![CDATA[
<?php
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
?>
]]>
       </programlisting>
      </informalexample>
      整型数的字长和平台有关，尽管通常最大值是大约二十亿（32 位有符号）。PHP 不支持无符号整数。
     </para>
    </sect2>
   
    <sect2 id="language.types.integer.overflow">
     <title>整数溢出</title>
     <para>
      如果你指定一个数超出了 <type>integer</type> 的范围，将会被解释为 <type>float</type>。同样如果你执行的运算结果超出了 <type>integer</type> 范围，也会返回 <type>float</type>。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// 输出为：int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// 输出为：float(2147483648)

// 同样也适用于十六进制表示的整数：
var_dump( 0x80000000 );
// 输出为：float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// 输出为：float(50000000000)
?>
]]>
       </programlisting>
      </informalexample>
      <warning>
       <simpara>
        不幸的是 PHP 中有个 bug，因此当有负数参与时结果并不总是正确。例如当运算 <literal>-50000 *
        $million</literal> 时结果是 <literal>-429496728</literal>。不过当两个运算数都是正数时就没问题。
       </simpara>
       <simpara>
        这个问题已经在 PHP 4.1.0 中解决了。
       </simpara>
      </warning>
     </para>
     <para>
      PHP 中没有整除的运算符。<literal>1/2</literal> 产生出<type>浮点数</type> <literal>0.5</literal>。您可以总是舍弃小数部分，或者使用 <function>round</function> 函数。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286)
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4)
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect2>
   

    <sect2 id="language.types.integer.casting">
     <title>转换为整形</title>
      <simpara>
       要明示地将一个值转换为 <type>integer</type>，用 <literal>(int)</literal> 或 <literal>(integer)</literal> 强制转换。不过大多数情况下都不需要强制转换，因为当运算符，函数或流程控制需要一个 <type>integer</type> 参数时，值会自动转换。您还可以通过函数 <function>intval</function> 来将一个值转换成整型。
      </simpara>
      <simpara>
       参见<link linkend="language.types.type-juggling">类型戏法</link>。
      </simpara>
      
      <sect3 id="language.types.integer.casting.from-boolean">
       <title>从<link linkend="language.types.boolean">布尔值</link>转换</title>
       <simpara>
        &false; 将产生出 <literal>0</literal>（零），&true; 将产生出 <literal>1</literal>（壹）。
       </simpara>
      </sect3>

      <sect3 id="language.types.integer.casting.from-float">
       <title>从<link linkend="language.types.float">浮点数</link>转换</title> 
       <simpara>
        当从浮点数转换成整数时，数字将被取整（<emphasis>丢弃小数位</emphasis>）。
       </simpara>
       
       <para>
        如果浮点数超出了整数范围（通常为 <literal>+/- 2.15e+9 = 2^31</literal>），则结果不确定，因为没有足够的精度使浮点数给出一个确切的整数结果。在此情况下没有警告，甚至没有任何通知！
       </para>

       <para>
        （译者注：）在 Linux 下返回结果是最小负数（-2147483648），而在 Windows 下返回结果是零（0）。
       </para>
       
       <warning><para>
        决不要将未知的分数强制转换为 <type>integer</type>，这样有时会导致意外的结果。
        <informalexample>
         <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // 显示 7！
?>
]]>
         </programlisting>
        </informalexample>
        更多信息见<link linkend="warn.float-precision">浮点数精度</link>。
       </para></warning>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-string">
       <title>从字符串转换</title>
       <simpara>
        参见<link linkend="language.types.string.conversion">字符串转换为数字</link>。
       </simpara>
      </sect3>
      
      <sect3 id="language.types.integer.casting.from-other">
       <title>从其它类型转换</title>
       <para>
        <caution>
         <simpara>
          没有定义从其它类型转换为整型的行为。目前的行为和值先<link
          linkend="language.types.boolean.casting">转换为布尔值</link>一样。不过<emphasis>不要</emphasis>依靠此行为，因为它会未加通知地改变。
         </simpara>
        </caution>
       </para>
      </sect3>      
    </sect2>
  </sect1>

  <sect1 id="language.types.float">
   <title>浮点型</title>
   <para>
    浮点数（也叫“floats”，“doubles”或“real numbers”）可以用以下任何语法定义：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1.234;
$a = 1.2e3;
$a = 7E-10;
?>
]]>
     </programlisting>
    </informalexample>
    形式上：
    <informalexample>
     <programlisting role="php">
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
     </programlisting>
    </informalexample>
    浮点数的字长和平台相关，尽管通常最大值是 1.8e308 并具有 14 位十进制数字的精度（64 位 IEEE 格式）。
   </para>

   <warning id="warn.float-precision">
    <title>浮点数精度</title>
    <para>
     显然简单的十进制分数如同 <literal>0.1</literal> 或 <literal>0.7</literal> 不能在不丢失一点点精度的情况下转换为内部二进制的格式。这就会造成混乱的结果：例如，<literal>floor((0.1+0.7)*10)</literal> 通常会返回 <literal>7</literal> 而不是预期中的 <literal>8</literal>，因为该结果内部的表示其实是类似 <literal>7.9999999999...</literal>。
    </para>
    <para>
     这和一个事实有关，那就是不可能精确的用有限位数表达某些十进制分数。例如，十进制的 <literal>1/3</literal> 变成了 <literal>0.3333333. . .</literal>。
    </para>
    <para>
     所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用<link
     linkend="ref.bc">任意精度数学函数库</link>或者 <link linkend="ref.gmp">gmp 函数库</link>。
    </para>
   </warning>

   <sect2 id="language.types.float.casting">
    <title>转换为浮点数</title>
    
    <para>
	 如果您希望了解有关何时和如何将字符串转换成浮点数的信息，请查阅标题为“<link linkend="language.types.string.conversion">将字符串转换为数字</link>”的有关章节。对于其它类型的值，其情况类似于先将值转换成整型，然后再转换成浮点。请参阅“<link linkend="language.types.integer.casting">转换为整型</link>”有关章节以获取更多信息。
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.string">
   <title>字符串</title>
   <para>
    <type>string</type> 是一系列字符。在 PHP 中，字符和字节一样，也就是说，一共有 256 种不同字符的可能性。这也暗示 PHP 对 Unicode 没有本地支持。请参阅函数 <function>utf8_encode</function>
    和 <function>utf8_decode</function> 以了解有关 Unicode 支持。
   </para>
   <note>
    <simpara>
     一个字符串变得非常巨大也没有问题，PHP 没有给字符串的大小强加实现范围，所以完全没有理由担心长字符串。
    </simpara>
   </note>
   <sect2 id="language.types.string.syntax">
    <title>语法</title>
    <para>
     字符串可以用三种字面上的方法定义。
     <itemizedlist>

      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.single">单引号</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.double">双引号</link>
       </simpara>
      </listitem>
      <listitem>
       <simpara>
        <link linkend="language.types.string.syntax.heredoc">定界符</link>
       </simpara>
      </listitem>

     </itemizedlist>
    </para>
    <sect3 id="language.types.string.syntax.single">
     <title>单引号</title>
     <para>
      指定一个简单字符串的最简单的方法是用单引号（字符 <literal>'</literal>）括起来。
     </para>
     <para>
      要表示一个单引号，需要用反斜线（<literal>\</literal>）转义，和很多其它语言一样。如果在单引号之前或字符串结尾需要出现一个反斜线，需要用两个反斜线表示。注意如果你试图转义任何其它字符，反斜线本身也会被显示出来！所以通常不需要转义反斜线本身。
      <note>
       <simpara>
        在 PHP 3 中，此情况下将发出一个 <literal>E_NOTICE</literal> 级的警告。
       </simpara>
      </note>
      <note>
       <simpara>
        和其他两种语法不同，单引号字符串中出现的<link
        linkend="language.variables">变量</link>和转义序列<emphasis>不会</emphasis>被变量的值替代。
       </simpara>
      </note>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo 'this is a simple string';

echo 'You can also have embedded newlines in
strings this way as it is
okay to do';

// Outputs: Arnold once said: "I'll be back"
echo 'Arnold once said: "I\'ll be back"';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\\*.*?';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\*.*?';

// Outputs: This will not expand: \n a newline
echo 'This will not expand: \n a newline';

// Outputs: Variables do not $expand $either
echo 'Variables do not $expand $either';
?>
]]>
       </programlisting>
      </informalexample>
     </para>
    </sect3>
    <sect3 id="language.types.string.syntax.double">
     <title>双引号</title>
     <para>
      如果用双引号（"）括起字符串，PHP 懂得更多特殊字符的转义序列：
     </para>
     <table>
      <title>转义字符</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>序列</entry>
         <entry>含义</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>\n</literal></entry>
         <entry>换行（LF 或 ASCII 字符 0x0A（10））</entry>
        </row>
        <row>
         <entry><literal>\r</literal></entry>
         <entry>回车（CR 或 ASCII 字符 0x0D（13））</entry>
        </row>
        <row>
         <entry><literal>\t</literal></entry>
         <entry>水平制表符（HT 或 ASCII 字符 0x09（9））</entry>
        </row>
        <row>
         <entry><literal>\\</literal></entry>
         <entry>反斜线</entry>
        </row>
        <row>
         <entry><literal>\$</literal></entry>
         <entry>美元符号</entry>
        </row>
        <row>
         <entry><literal>\"</literal></entry>
         <entry>双引号</entry>
        </row>
        <row>
         <entry><literal>\[0-7]{1,3}</literal></entry>
         <entry>
          此正则表达式序列匹配一个用八进制符号表示的字符
         </entry>
        </row>
        <row>
         <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
         <entry>
          此正则表达式序列匹配一个用十六进制符号表示的字符
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      此外，如果试图转义任何其它字符，反斜线本身也会被显示出来！
     </para>
     <para>
      双引号字符串最重要的一点是其中的变量名会被变量值替代。细节参见<link linkend="language.types.string.parsing">字符串解析</link>。
     </para>
    </sect3>
    
    <sect3 id="language.types.string.syntax.heredoc">
     <title>定界符</title>
     <simpara>
      另一种给字符串定界的方法使用定界符语法（“&lt;&lt;&lt;”）。应该在 <literal>&lt;&lt;&lt;</literal> 之后提供一个标识符，然后是字符串，然后是同样的标识符结束字符串。
     </simpara>     
     <simpara>
      结束标识符<emphasis>必须</emphasis>从行的第一列开始。同样，标识符也必须遵循 PHP 中其它任何标签的命名规则：只能包含字母数字下划线，而且必须以下划线或非数字字符开始。
     </simpara>
     
     <warning>
      <simpara>
       很重要的一点必须指出，结束标识符所在的行不能包含任何其它字符，<emphasis>可能</emphasis>除了一个分号（<literal>;</literal>）之外。这尤其意味着该标识符<emphasis>不能被缩进</emphasis>，而且在分号之前和之后都不能有任何空格或制表符。同样重要的是要意识到在结束标识符之前的第一个字符必须是你的操作系统中定义的换行符。例如在
       Macintosh 系统中是 <literal>\r</literal>。
      </simpara>
      <simpara>
       如果破坏了这条规则使得结束标识符不“干净”，则它不会被视为结束标识符，PHP
       将继续寻找下去。如果在这种情况下找不到合适的结束标识符，将会导致一个在脚本最后一行出现的语法错误。
      </simpara>
     </warning>

     <para>
      定界符文本表现的就和双引号字符串一样，只是没有双引号。这意味着在定界符文本中不需要转义引号，不过仍然可以用以上列出来的转义代码。变量会被展开，但当在定界符文本中表达复杂变量时和字符串一样同样也要注意。
      <example> 
       <title>定界符字符串例子</title>
       <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* More complex example, with variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
       </programlisting>
      </example>
     </para>
  
     <note>
      <para>
       定界符支持是 PHP 4 中加入的。
      </para>
     </note>
    </sect3>

    <sect3 id="language.types.string.parsing">
     <title>变量解析</title>
     <simpara>
      当用双引号或者定界符指定字符串时，其中的<link
      linkend="language.variables">变量</link>会被解析。
     </simpara>
     <simpara>
      有两种语法，一种<link linkend="language.types.string.parsing.simple">简单的</link>和一种<link
      linkend="language.types.string.parsing.complex">复杂的</link>。简单语法最通用和方便，它提供了解析变量，数组值，或者对象属性的方法。
     </simpara>
     <simpara>
      复杂语法是 PHP 4 引进的，可以用花括号括起一个表达式。
     </simpara>

     <sect4 id="language.types.string.parsing.simple">
      <title>简单语法</title>
      <simpara>
       如果遇到美元符号（<literal>$</literal>），解析器会尽可能多地取得后面的字符以组成一个合法的变量名。如果你想明示指定名字的结束，用花括号把变量名括起来。
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // works, "'" is an invalid character for varnames
echo "He drank some $beers";   // won't work, 's' is a valid character for varnames
echo "He drank some ${beer}s"; // works
echo "He drank some {$beer}s"; // works
?>
]]>
       </programlisting>
      </informalexample>
      <simpara>
       同样也可以解析数组索引或者对象属性。对于数组索引，右方括号（<literal>]</literal>）标志着索引的结束。对象属性则和简单变量适用同样的规则，尽管对于对象属性没有像变量那样的小技巧。
       <!-- XXX isn't &true; :(, this would be the trick
       Also, the same trick with curly-braces works if you
       want to limit the greediness of parsers.
       -->
      </simpara>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php 
// These examples are specific to using arrays inside of strings. 
// When outside of a string, always quote your array string keys 
// and do not use {braces} when outside of strings either. 

// Let's show all errors 
error_reporting(E_ALL); 

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');
// Works but note that this works differently outside string-quotes
echo "A banana is $fruits[banana].";
// Works
echo "A banana is {$fruits['banana']}.";

// Works but PHP looks for a constant named banana first
// as described below.
echo "A banana is {$fruits[banana]}.";

// Won't work, use braces.  This results in a parse error.
echo "A banana is $fruits['banana'].";

// Works
echo "A banana is " . $fruits['banana'] . ".";

// Works

echo "This square is $square->width meters broad.";
// Won't work. For a solution, see the complex syntax.
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad."; 
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works, 
// XXX: analogously to the ${expr} syntax for variable var's.
-->
       </programlisting>
      </informalexample>
      <simpara>
       对于任何更复杂的情况，应该使用复杂语法。
      </simpara>
     </sect4>

     <sect4 id="language.types.string.parsing.complex">
      <title>复杂（花括号）语法</title>
      <simpara>
       不是因为语法复杂而称其为复杂，而是因为用此方法可以包含复杂的表达式。
     </simpara>
     <simpara>
      事实上，用此语法你可以在字符串中包含任何在名字空间的值。仅仅用和在字符串之外同样的方法写一个表达式，然后用 { 和 } 把它包含进来。因为不能转义“{”，此语法仅在 $ 紧跟在 { 后面时被识别（用“{\$”或者“\{$”来得到一个字面上的“{$”）。用一些例子可以更清晰：
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Let's show all errors
error_reporting(E_ALL);

$great = 'fantastic';

// 不行，输出为：This is { fantastic}
echo "This is { $great}";

// 可以，输出为：This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// Works
echo "This square is {$square->width}00 centimeters broad.";

// Works
echo "This works: {$arr[4][3]}";
// This is wrong for the same reason as $foo[bar] is wrong
// outside a string.  In otherwords, it will still work but
// because PHP first looks for a constant named foo, it will
// throw an error of level E_NOTICE (undefined constant).
echo "This is wrong: {$arr[foo][3]}";
// Works.  When using multi-dimensional arrays, always use
// braces around arrays when inside of strings
echo "This works: {$arr['foo'][3]}";

// Works.
echo "This works: " . $arr['foo'][3];

echo "You can even write {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";
?>
]]>
<!-- maybe it's better to leave this out?? 
// this works, but i disencourage its use, since this is NOT 
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
       </programlisting>
      </informalexample>
     </sect4>
    </sect3>
    
    <sect3 id="language.types.string.substr">
     <title>访问字符串中的字符</title>
     <para>
      字符串中的字符可以通过在字符串之后用花括号指定所要字符从零开始的偏移量来访问。
     </para>
     <note>
      <simpara>
       为了向下兼容，仍然可以用方括号。不过此语法在 PHP 4 中不赞成使用。
      </simpara>
     </note>
     <para>
      <example>
       <title>一些字符串例子</title>
       <programlisting role="php">
<![CDATA[
<?php
// Get the first character of a string
$str = 'This is a test.';
$first = $str{0};
// Get the third character of a string
$third = $str{2};

// Get the last character of a string.
$str = 'This is still a test.';
$last = $str{strlen($str)-1}; 
?>
]]>
       </programlisting>
      </example>
     </para>
    </sect3>

   </sect2><!-- end syntax -->

   <sect2 id="language.types.string.useful-funcs">
    <title>实用函数及操作符</title>
    <para>
     字符串可以用“.”（点）运算符连接。注意这里不能用“+”（加）运算符。更多信息参见<link
     linkend="language.operators.string">字符串运算符</link>。
    </para>
    <para>
     有很多实用函数来改变字符串。
    </para>
    <simpara>
     普通函数见<link linkend="ref.strings">字符串函数库</link>一节，高级搜索和替换见正则表达式函数（两种口味：<link
     linkend="ref.pcre">Perl</link> 和 <link linkend="ref.regex">POSIX 扩展</link>）。
    </simpara>
    <simpara>
     还有 <link linkend="ref.url">URL 字符串函数</link>，以及加密／解密字符串的函数（<link
     linkend="ref.mcrypt">mcrypt</link> 和 <link linkend="ref.mhash">mhash</link>）。
    </simpara>
    <simpara>
     最后，如果还是找不到你要的函数，参见<link linkend="ref.ctype">字符类型函数库</link>。
    </simpara>
   </sect2>

   <sect2 id="language.types.string.casting">
    <title>字符串转换</title>
    
    <para>
     您可以用 <literal>(string)</literal> 标记或者 <function>strval</function>
     函数将一个值转换为字符串。当某表达式需要字符串时，字符串的转换会在表达式范围内自动完成。例如当你使用
     <function>echo</function> 或者 <function>print</function>
     函数时，或者将一个变量值与一个字符串进行比较的时候。阅读手册中有关<link
     linkend="language.types">类型</link>和<link
     linkend="language.types.type-juggling">类型戏法</link>中的部分有助于更清楚一些。参见
     <function>settype</function>。
    </para>
    <para>
     布尔值 &true; 将被转换为字符串 <literal>"1"</literal>，而值 &false; 将被表示为
     <literal>""</literal>（即空字符串）。这样您就可以随意地在布尔值和字符串之间进行比较。
    </para>
    <para> 
     整数或浮点数数值在转换成字符串时，字符串即为表示这些数值数字（浮点数还包含有指数部分）。
    </para>
    <para>
     数组将被转换成字符串 <literal>"Array"</literal>，因此您无法通过
     <function>echo</function> 或者 <function>print</function>
     函数来输出数组的内容。请参考下文以获取更多提示。
    </para>
    <para>
     对象将被转换成字符串
     <literal>"Object"</literal>。如果您因为调试需要，需要将对象的成员变量打印出来，请阅读下文。如果您希望得到该对象所依附的类的名称，请使用函数
     <function>get_class</function>。
    </para>
    <para>
     资源类型将会以 <literal>"Resource id #1"</literal> 的格式被转换成字符串，其中
     <literal>1</literal> 是 PHP
     在运行时给资源指定的唯一标识。如果您希望获取资源的类型，请使用函数
     <function>get_resource_type</function>.
    </para>
    <para>
     &null; 将被转换成空字符串。
    </para>
    
    <para>
     正如以上所示，将数组、对象或者资源打印出来，并不能给您提供任何关于这些值本身的有用的信息。请参阅函数 <function>print_r</function> 和 <function>var_dump</function>，对于调试来说，这些是更好的打印值的方法。
    </para>
    
    <para>
     您可以将 PHP 的值转换为字符串以永久地储存它们。这种方法被称为串行化，您可以用函数 <function>serialize</function> 来完成该操作。如果您在安装 PHP 时建立了 <link linkend="ref.wddx">WDDX</link> 支持，您还可以将 PHP 的值串行化为 XML 结构。
    </para>
   </sect2>

   <sect2 id="language.types.string.conversion">
    <title>字符串转换为数值</title>

    <simpara>
     当一个字符串被当作数字来求值时，根据以下规则来决定结果的类型和值。
    </simpara>
    <simpara>
     如果包括“.”，“e”或“E”其中任何一个字符的话，字符串被当作 <type>float</type> 来求值。否则就被当作整数。
    </simpara>
    <para>
     该值由字符串最前面的部分决定。如果字符串以合法的数字数据开始，就用该数字作为其值，否则其值为 0（零）。合法数字数据由可选的正负号开始，后面跟着一个或多个数字（可选地包括十进制分数），后面跟着可选的指数。指数是一个“e”或者“E”后面跟着一个或多个数字。
    </para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo is float (11.5)
$foo = 1 + "-1.3e3";              // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo is integer (1)
$foo = 1 + "bob3";                // $foo is integer (1)
$foo = 1 + "10 Small Pigs";       // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;          // $foo is float (11)
$foo = "10.0 pigs " + 1.0;        // $foo is float (11)
?>
]]>
     </programlisting>
    </informalexample>
    <simpara>
     此转换的更多信息见 Unix 手册中关于 strtod(3) 的部分。
    </simpara>
    <para>
     如果你想测试本节中的任何例子，可以拷贝和粘贴这些例子并且加上下面这一行自己看看会发生什么：
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";
?>
]]>
      </programlisting>
     </informalexample>
    </para>

    <para>
     不要指望在将一个字符转换成整型时能够得到该字符的编码（您可能也会在 C 中这么做）。如果您希望在字符编码和字符之间转换，请使用 <function>ord</function> 和 <function>chr</function> 函数。
    </para>

   </sect2>
  </sect1><!-- end string -->

  <sect1 id="language.types.array">
   <title>数组</title>

   <para>
    PHP 中的数组实际上是一个有序图。图是一种把 <emphasis>values</emphasis> 映射到 <emphasis>keys</emphasis> 的类型。此类型在很多方面做了优化，因此你可以把它当成真正的数组来使用，或列表（矢量），散列表（是图的一种实现），字典，集合，栈，队列以及更多可能性。因为可以用另一个 PHP 数组作为值，也可以很容易地模拟树。
   </para>
   <para>
    解释这些结构超出了本手册的范围，但对于每种结构你至少会发现一个例子。要得到这些结构的更多信息，我们建议你参考有关此广阔主题的外部著作。
   </para>
   
   <sect2 id="language.types.array.syntax">
    <title>语法</title>
    
    <sect3 id="language.types.array.syntax.array-func">
     <title>定义 <function>array</function></title>
     <para>
      可以用 <function>array</function> 语言结构来新建一个 <type>array</type>。它接受一定数量用逗号分隔的
      <literal><replaceable>key</replaceable> =&gt; <replaceable>value</replaceable></literal> 参数对。
     </para>
     <para>
      <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional> <replaceable
>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> 不是<type>字符串</type>就是<type>整数</type>
// <replaceable>value</replaceable> 可以为任何值
      </synopsis>
     </para>
     <para>
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      <varname>key</varname> 可以是 <type>integer</type> 或者 <type>string</type>。如果键名是一个
      <type>integer</type> 的标准表达方法，则被解释为整数（例如 <literal>"8"</literal> 将被解释为
      <literal>8</literal>，而 <literal>"08"</literal> 将被解释为 <literal>"08"</literal>）。PHP 中数组下标的变量类型不会对数组造成影响，数组的类型只有一种，它可以同时包含整型和字符串型的下标。
     </para>
     <para>
      值可以是任何值。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array("somearray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["somearray"][6];    // 5
echo $arr["somearray"][13];   // 9
echo $arr["somearray"]["a"];  // 42
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      如果省略键名，则取当前最大的整数索引，而新的键名将是该值加一。整数可以为负，所以对于负的索引也是这样。例如最大的索引是
      <literal>-6</literal> 将导致新的键名是 <literal>-5</literal>。如果还不存在整数索引，则键名将为
      <literal>0</literal>（零）。如果你指定的键名已经有了值，则该值会被覆盖。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// This array is the same as ...
array(5 => 43, 32, 56, "b" => 12);

// ...this array
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      使用 &true; 作为键名将使 <type>integer</type> <literal>1</literal> 成为键名。使用
      &false; 作为键名将使 <type>integer</type> <literal>0</literal> 成为键名。使用
      <literal>NULL</literal> 作为键名将等同于使用空字符串。使用空字符串作为键名将新建（或覆盖）一个用空字符串作为键名的值，这和用空的方括号不一样。
     </para>
     <para>
      不能用数组和对象作为键名。这样做会导致一个警告：<literal>Illegal offset type</literal>。
     </para>    
    </sect3>
    
    <sect3 id="language.types.array.syntax.modifying">
     <title>用方括号的语法新建／修改</title>
     <para>
      可以通过明示地设定值来改变一个现有的数组。
     </para>
     <para>
      这是通过在方括号内指定键名来给数组赋值实现的。也可以省略键名，在这种情况下给变量名加上一对空的方括号（“<literal>[]</literal>”）。
      <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> 不是 <type>string</type> 就是非负的 <type>integer</type>
// <replaceable>value</replaceable> 可以为任何值。
      </synopsis>
      如果 <varname>$arr</varname> 还不存在，将会新建一个。这也是一种定义数组的替换方法。要改变一个值，只要给它赋一个新值。如果要删除一个键名／值对，要对它用 <function>unset</function>。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);
$arr[] = 56;    // This is the same as $arr[13] = 56;
                // at this point of the script
$arr["x"] = 42; // This adds a new element to
                // the array with key "x"
unset($arr[5]); // This removes the element from the array
unset($arr);    // This deletes the whole array
?>
]]>
       </programlisting>
      </informalexample>
	 </para>
    </sect3>
   </sect2><!-- end syntax -->
   
   <sect2 id="language.types.array.useful-funcs">
    <title>实用函数</title>
    <para>
     有相当多的实用函数作用于数组，参见<link linkend="ref.array">数组函数库</link>一节。
    </para>
    <note>
     <para>
      <function>unset</function> 函数允许取消一个数组中的键名。要注意数组将不会重建索引。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?PHP
$a = array( 1 => 'one', 2 => 'two', 3 => 'three' );
unset( $a[2] );
/* 将产生一个数组，定义为
   $a = array( 1=>'one', 3=>'three');
   而不是
   $a = array( 1 => 'one', 2 => 'three');
*/
$b = array_values($a);
// Now b is array(1 => 'one', 2 =>'three')
?>
]]>
      </programlisting>
     </informalexample>
     
     </para>    
    </note> 
    <para>
     <link linkend="control-structures.foreach">foreach</link> 控制结构是专门用于数组的。它提供了一个简单的方法来遍历数组。
    </para>
   </sect2>
   
   <sect2 id="language.types.array.donts">
    <title>数组做什么和不做什么</title>

    <sect3 id="language.types.array.foo-bar">
     <title>为什么 <literal>$foo[bar]</literal> 错了？</title>
     <para>
      应该始终在数组的索引上加上引号。例如用 $foo['bar'] 而不是 $foo[bar]。但是为什么 $foo[bar] 错了呢？你可能在老的脚本中见过如下语法：
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
       </programlisting>
      </informalexample>
      这样是错的，但可以起作用。那么为什么错了呢？原因是此代码中有一个未定义的常量（bar）而不是字符串（'bar'－注意引号），而 PHP 可能会在以后定义此常量，不幸的是你的代码中有同样的名字。它可以起作用，因为未定义常量会被转换为同样名字的字符串。
     </para>
     <para>
      演示此效应的更多例子：
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
// 显示所有错误
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// 正确
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// 不正确。This works but also throws a PHP error of
// level E_NOTICE because of an undefined constant named fruit
//
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Let's define a constant to demonstrate what's going on.  We
// will assign value 'veggie' to a constant named fruit.
define('fruit','veggie');

// Notice the difference now
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// The following is okay as it's inside a string.  Constants are not
// looked for within strings so no E_NOTICE error here
print "Hello $arr[fruit]";      // Hello apple

// With one exception, braces surrounding arrays within strings
// allows constants to be looked for
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// This will not work, results in a parse error such as:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// This of course applies to using autoglobals in strings as well
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// Concatenation is another option
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
       </programlisting>
      </informalexample>
     </para>
     <para>
      当打开 <function>error_reporting</function> 来显示
      <constant>E_NOTICE</constant> 级别的错误（例如将其设为
      <constant>E_ALL</constant>）时将看到这些错误。默认情况下
      <link linkend="ini.error-reporting">error_reporting</link>
      被关闭不显示这些。
     </para>
     <para>
      和在<link linkend="language.types.array.syntax">语法</link>一节中规定的一样，在方括号（“<literal>[</literal>”和“<literal>]</literal>”）之间必须有一个表达式。这意味着你可以这样写：
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
       </programlisting>
      </informalexample>
      这是一个用函数返回值作为数组索引的例子。PHP 也可以用已知常量，你可能之前已经见过 <literal>E_*</literal>。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      注意 <literal>E_ERROR</literal> 也是个合法的标识符，就和第一个例子中的 <literal>bar</literal> 一样。但是上一个例子实际上和如下写法是一样的：
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
?>
]]>
       </programlisting>
      </informalexample>
      因为 <literal>E_ERROR</literal> 等于 <literal>1</literal>，等等。
     </para>
     <para>
      如同我们在以上例子中解释的那样，<literal>$foo[bar]</literal>
      起作用但其实是错误的。它起作用是因为根据语法的预期，<literal>bar</literal> 被当成了一个常量表达式。然而，在这个例子中不存在名为
      <literal>bar</literal> 的常量。PHP 就假定你指的是字面上的 <literal>bar</literal>，也就是字符串
      <literal>"bar"</literal>，但你忘记写引号了。
     </para>
     <sect4>
      <title>那么为什么这样做不好？</title>
      <para>
       在未来的某一时刻，PHP 开发小组可能会想新增一个常量或者关键字，或者您可能希望在以后在您的程序中引入新的常量，那你就有麻烦了。例如你已经不能这样用
       <literal>empty</literal> 和 <literal>default</literal> 这两个词了，因为他们是<link linkend="reserved">保留字</link>。
      </para>
      <note>
       <simpara>
        重申一次，在双引号字符串中，不给索引加上引号是合法的因此
        <literal>"$foo[bar]"</literal>是合法的。至于为什么参见以上的例子和<link
        linkend="language.types.string.parsing">字符串中的变量解析</link>中的解释。
       </simpara>
      </note>
     </sect4>
    </sect3>
   </sect2>

   <sect2 id="language.types.array.casting">
    <title>转换为数组</title>
    
    <para>
     对于任何的类型：整型、浮点、字符串、布尔和资源，如果您将一个值转换为数组，您将得到一个仅有一个元素的数组（其下标为 0），该元素即为此标量的值。
    </para>

    <para>
     如果您将一个对象转换成一个数组，您所得到的数组的元素为该对象的属性（成员变量），其键名为成员变量名。
    </para>

    <para>
     如果您将一个 &null; 值转换成数组，您将得到一个空数组。
    </para>
   </sect2>
   
   <sect2 id="language.types.array.examples">
    <title>例子</title>
    <para>
     PHP 中的数组类型有非常多的用途，因此这里有一些例子展示数组的完整威力。
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// this
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                       4        // key will be 0
          );

// is completely equivalent with
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // key will be 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// will result in the array array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// or simply array('a', 'b', 'c')
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    
    <example>
     <title>使用 array()</title>
     <programlisting role="php">
<![CDATA[
<?php
// Array as (property-)map
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );
            
// strictly numerical keys
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// this is the same as array(0 => 7, 1 => 8, ...)

$switching = array(         10, // key = 0
                    5    =>  6,
                    3    =>  7, 
                    'a'  =>  4,
                            11, // key = 6 (maximum of integer-indices was 5)
                    '8'  =>  2, // key = 8 (integer!)
                    '02' => 77, // key = '02'
                    0    => 12  // the value 10 will be overwritten by 12
                  );
// empty array
$empty = array();
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
     </programlisting>
    </example>

    <example id="language.types.array.examples.loop">
     <title>集合</title>
     <programlisting role="php">
<![CDATA[
<?php
$colors = array('red', 'blue', 'green', 'yellow');

foreach ($colors as $color) {
    echo "Do you like $color?\n";
}

/* output:
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
*/
?>
]]>
     </programlisting>
    </example>
    
    <para>
     注意目前不可能在这样一个循环中直接改变数组的值。可以改变的例子如下：
      <!--
       Should be made possible, if you write:
       foreach ( $colors as &$color )
      
       See bug#3074
      -->
     <example id="language.types.array.examples.changeloop">
      <title>集合</title>
      <programlisting role="php">
<![CDATA[
<?php
foreach ($colors as $key => $color) {
    // won't work:
    //$color = strtoupper($color);
    
    //works:
    $colors[$key] = strtoupper($color);
}
print_r($colors);

/* output:
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
*/
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     本例产生一个基于一的数组。
     <example>
      <title>基于一的数组</title>
      <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'January', 'February', 'March');
print_r($firstquarter);

/* output:
Array 
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
*/
?>
]]>   
      </programlisting>
     </example>
    </para>
    <example>
     <title>填充数组</title>
     <programlisting role="php">
<![CDATA[
<?php
// fill an array with all items from a directory
$handle = opendir('.');
while ($file = readdir($handle)) {
    $files[] = $file;
}
closedir($handle);
?>
]]>
     </programlisting>
    </example>
    <para>
     数组是有序的。你也可以使用不同的排序函数来改变顺序。更多信息参见<link linkend="ref.array">数组函数库</link>。您可以用 <function>count</function> 函数来数出数组中元素的个数。
    </para>
    <example>
     <title>数组排序</title>
     <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
     </programlisting>
    </example>
    <para>
     因为数组中的值可以为任意值，也可是另一个数组。这样你可以产生递归或多维数组。
    </para>
    <example>
     <title>递归和多维数组</title>
     <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6,
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Some examples to address values in the array above 
echo $fruits["holes"][5];    // prints "second"
echo $fruits["fruits"]["a"]; // prints "orange"
unset($fruits["holes"][0]);  // remove "first"

// Create a new multi-dimensional array
$juices["apple"]["green"] = "good";
?>
]]>
     </programlisting>
    </example>

    <para>
	 您需要注意数组的赋值总是会涉及到值的拷贝。您需要在复制数组时用指向符号（&）。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 is changed,
             // $arr1 is still array(2,3)
             
$arr3 = &$arr1;
$arr3[] = 4; // now $arr1 and $arr3 are the same
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.object">
   <title>对象</title>

   <sect2 id="language.types.object.init">
    <title>对象初始化</title>

    <para>
     要初始化一个对象，用 <literal>new</literal> 语句将对象实例到一个变量中。

     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Doing foo."; 
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     完整的讨论见<link linkend="language.oop">类与对象</link>一章。
    </simpara>
   </sect2>
   <sect2 id="language.types.object.casting">
    <title>转换为对象</title>
    
    <para>
	 如果将一个对象转换成对象，它将不会有任何变化。如果其它任何类型的值被转换成对象，内置类 <literal>stdClass</literal> 的一个实例将被建立。如果该值为 &null;，则新的实例为空。对于任何其它的值，名为 <literal>scalar</literal> 的成员变量将包含该值。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj-&gt;scalar;  // outputs 'ciao'
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect2>
  </sect1>

  <sect1 id="language.types.resource">
   <title>资源</title>
    
    <para>
     一个资源是一个特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。所有这些函数及其相应资源类型见<link linkend="resource">附录</link>。
    </para>
    
    <note>
     <simpara>
      资源类型是 PHP 4 引进的。
     </simpara>
    </note>

   <sect2 id="language.types.resource.casting">
    <title>转换为资源</title>
    
    <para>
	 由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，您无法将其它类型的值转换为资源。
    </para>
   </sect2>

    <sect2 id="language.types.resource.self-destruct">
     <title>释放资源</title>
    
    <para>
     由于 PHP4 Zend 引擎引进了资源计数系统，可以自动检测到一个资源不再被引用了（和 Java 一样）。这种情况下此资源使用的所有外部资源都会被垃圾回收系统释放。由此原因，很少需要用某些 free-result 函数来手工释放内存。
     <note>
      <simpara>
       持久数据库连接比较特殊，它们<emphasis>不会</emphasis>被垃圾回收系统破坏。参见<link
       linkend="features.persistent-connections">数据库永久连接</link>一章。
      </simpara>
     </note>
    </para>
    
   </sect2>
  </sect1>
    
  <sect1 id="language.types.null">
   <title>NULL</title>
    
   <para>
    特殊的 &null; 值表示一个变量没有值。<type>NULL</type> 类型唯一可能的值就是 &null;。
   </para>
    <note>
     <simpara>
      <type>NULL</type> 类型是 PHP 4 引进的。
     </simpara>
    </note>
    <para>
     在下列情况下一个变量被认为是 &null;：
     <itemizedlist>
      <listitem>
       <para>
        被赋值为 &null;。
       </para>
      </listitem>
      <listitem>
       <para>
        尚未被赋值。
       </para>
      </listitem>
      <listitem>
       <para>
        被 <function>unset</function>。
       </para>
      </listitem>
     </itemizedlist>
    </para>
    
   <sect2 id="language.types.null.syntax">
    <title>语法</title>
    <para>
     &null; 类型只有一个值，就是大小写敏感的关键字 &null;。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$var = NULL;
?>
]]>     
      </programlisting>
     </informalexample>
    </para>
    <para>
     参见 <function>is_null</function> 和 <function>unset</function>。
    </para>
   </sect2>
  
  </sect1>
 
  <sect1 id="language.pseudo-types">
   <title>本文档中使用的伪类型</title> 

   <sect2 id="language.types.mixed">
    <title>mixed</title>
    <para>
     <literal>mixed</literal> 说明一个参数可以接受多种不同的（但并不必须是所有的）类型。
    </para>
    <para>
     <function>gettype</function> 表明可以接受所有的 PHP 类型，例如 <function>str_replace</function> 将接受字符串和数组。
    </para>
   </sect2>
  
   <sect2 id="language.types.number">
    <title>number</title>
    <para>
     <literal>number</literal> 说明一个参数可以是 <type>integer</type> 或者 <type>float</type>。
    </para>
   </sect2>

   <sect2 id="language.types.callback">
    <title>callback</title>
    <para>
     有些诸如 <function>call_user_function</function> 或 <function>usort</function> 的函数接受用户自定义的函数作为一个参数。Callback 函数不仅可以是一个简单的函数，它还可以是一个对象的方法，包括静态类的方法。
    </para>
    <para>
     一个 PHP 函数用函数名字符串来传递。您可以传递任何内建的或者用户自定义的函数，除了
     <function>array</function>，
     <function>echo</function>，
     <function>empty</function>，
     <function>eval</function>，
     <function>exit</function>，
     <function>isset</function>，
     <function>list</function>，
     <function>print</function> 和
     <function>unset</function>。
    </para>
    <para>
     一个对象的方法以数组的形式来传递，数组的 0 下标指明对象名，下标 1 指明方法名。
    </para>
    <para>
     对于没有实例化为对象的静态类，要传递其方法，将数组 0 下标指明的对象名换成该类的名称即可。
    </para>

    <para>
     <example>
      <title>
       Callback 函数实例
      </title>
      <programlisting role="php">
<![CDATA[
<?php 

// simple callback example
function foobar() {
    echo "hello world!";
}
call_user_function("foobar"); 

// method callback examples
class foo {
  function bar() {
    echo "hello world!";
  }
}

$foo = new foo;

call_user_function(array($foo, "bar")); // object method call

call_user_function(array("foo", "bar")); // static class method call

?>
]]>
      </programlisting>
     </example>
    </para>  
   
   </sect2>
  </sect1>

  <sect1 id="language.types.type-juggling">
   <title>类型戏法</title>

   <simpara>
    PHP 在变量定义中不需要（或不支持）明示的类型定义；变量类型是根据使用该变量的上下文所决定的。也就是说，如果你把一个字符串值赋给变量
    <parameter>var</parameter>，<parameter>var</parameter> 就成了一个字符串。如果你又把一个整型值赋给
    <parameter>var</parameter>，那它就成了一个整数。
   </simpara>
   <para>
    PHP 的自动类型转换的一个例子是加号“+”。如果任何一个运算数是浮点数，则所有的运算数都被当成浮点数，结果也是浮点数。否则运算数会被解释为整数，结果也是整数。注意这并没有改变这些运算数本身的类型；改变的仅是这些运算数如何被求值。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo is string (ASCII 48)
$foo += 2;   // $foo is now an integer (2)
$foo = $foo + 1.3;  // $foo is now a float (3.3)
$foo = 5 + "10 Little Piggies"; // $foo is integer (15)
$foo = 5 + "10 Small Pigs";     // $foo is integer (15)
?>
]]>
<!-- bad example, no real operator (must be used with variable, modifies it too)  
  $foo++;      // $foo is the string "1" (ASCII 49) 

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    如果上面两个例子看上去古怪的话，参见<link linkend="language.types.string.conversion">字符串转换为数值</link>。
   </simpara>
   <simpara>
    如果你要强制将一个变量当作某种类型来求值，参见<link
    linkend="language.types.typecasting">类型强制转换</link>一节。如果你要改变一个变量的类型，参见 <function>settype</function>。
   </simpara>
   <para>
    如果你想要测试本节中任何例子的话，可以用 <function>var_dump</function> 函数。
   </para>
   <note>
    <para>
     数组的自动转换行为目前没有定义。
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[ 
<?php 
$a = "1";     // $a 是字符串
$a[0] = "f";  // 是字符串偏移量吗？结果会是什么？
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     由于一些历史原因，PHP 支持通过偏移量进行的字符串索引，这和数组索引的语法一样。以上的例子就产生了一个问题：$a
     应该变成一个第一个元素是“f”的数组呢，还是“f”成了字符串 $a 的第一个字符？
    </para>
    <para>
     目前版本的 PHP 将以上第二个赋值理解成字符串的偏移量标识，即 $a 变成了 "f"，尽管如此，这种自动转换的地结果应该被认为未定义。PHP 4 引入了新的花括号语法来访问字符串的字符，请使用该语法来替代以上的操作：
     <informalexample>
      <programlisting role="php">
<![CDATA[ 
<?php 
$a    = "abc"; // $a 为一个字符串
$a{1} = "f";   // $a 目前为 "afc"
?>
]]>
      </programlisting>
     </informalexample>
     请参阅题为“<link linkend="language.types.string.substr">用字符访问字符串</link>”的章节以获取更多信息。
    </para>
   </note>

   <sect2 id="language.types.typecasting">
    <title>类型强制转换</title>

    <para>
     PHP 中的类型强制转换和 C 中的非常像：在要转换的变量之前加上用括号括起来的目标类型。
     <informalexample>
      <programlisting role="php">
<![CDATA[ 
<?php 
$foo = 10;   // $foo is an integer
$bar = (boolean) $foo;   // $bar is a boolean
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     允许的强制转换有：
     <itemizedlist>
      <listitem>
       <simpara>(int), (integer) - 转换成整型</simpara>
      </listitem>
      <listitem>
       <simpara>(bool), (boolean) - 转换成布尔型</simpara>
      </listitem>
      <listitem>
       <simpara>(float), (double), (real) - 转换成浮点型</simpara>
      </listitem>
      <listitem>
       <simpara>(string) - 转换成字符串</simpara>
      </listitem>
      <listitem>
       <simpara>(array) - 转换成数组</simpara>
      </listitem>
      <listitem>
       <simpara>(object) - 转换成对象</simpara>
      </listitem>
     </itemizedlist>
    </para>
     
    <para>
     注意在括号内允许有空格和制表符，所以下面两个例子功能相同：
     <informalexample>
      <programlisting role="php">
<![CDATA[ 
<?php 
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      为了将一个变量还原为字符串，您还可以将变量放置在双引号种。
     <informalexample>
      <programlisting role="php">
<![CDATA[ 
<?php 
$foo = 10;            // $foo is an integer
$str = "$foo";        // $str is a string
$fst = (string) $foo; // $fst is also a string

// This prints out that "they are the same"
if ($fst === $str) {
    echo "they are the same";
}
?>
]]>
      </programlisting>
     </informalexample>
     </para>
    </note>

    <para>
     当在某些类型之间强制转换时确切地会发生什么可能不是很明显。更多信息见如下小节：

     <itemizedlist>
      <listitem>
       <simpara><link linkend="language.types.boolean.casting">转换为布尔值</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.integer.casting">转换为整型</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.float.casting">转换为浮点型</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.string.casting">转换为字符串</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.array.casting">转换为数组</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.object.casting">转换为对象</link></simpara>
      </listitem>
      <listitem>
       <simpara><link linkend="language.types.resource.casting">转换为资源</link></simpara>
      </listitem>
      <!-- don't exist yet
      <listitem>
       <simpara><link linkend="language.types.null.casting">Converting to 
        &null;</link></simpara>
      </listitem>
      -->
     </itemizedlist>
    </para>
   </sect2>
  </sect1>
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
