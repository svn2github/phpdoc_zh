<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: 1.28 $ -->
<!-- $Author: haohappy $ -->
<!-- EN-Revision: 1.158 Maintainer: dallas Status: ready -->
<!-- CREDITS: Gregory -->
<chapter xml:id="language.types" xmlns="http://docbook.org/ns/docbook">
 <title>类型</title>

 <sect1 xml:id="language.types.intro">
  <title>介绍</title>

  <simpara>
   PHP 支持八种原始类型。
  </simpara>
  <para>
   四种标量类型：
   <itemizedlist>
    <listitem>
     <simpara>
      <type>boolean</type>（布尔型）
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>integer</type>（整型）
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>float</type>（浮点型，也作“<type>double</type>”）
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>string</type>（字符串）
     </simpara>
    </listitem>
   </itemizedlist>
   两种复合类型：
   <itemizedlist>
    <listitem>
     <simpara>
      <type>array</type>（数组）
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>object</type>（对象）
     </simpara>
    </listitem>
   </itemizedlist>
   最后是两种特殊类型：
   <itemizedlist>
    <listitem>
     <simpara>
      <type>resource</type>（资源）
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>NULL</type>
     </simpara>
    </listitem>
   </itemizedlist>
   为了确保代码的易读性，本手册还介绍了一些<link
   linkend="language.pseudo-types">伪类型</link>：
   <itemizedlist>
    <listitem>
     <simpara>
      <type>mixed</type>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>number</type>
     </simpara>
    </listitem>
    <listitem>
     <simpara>
      <type>callback</type>
     </simpara>
    </listitem>
   </itemizedlist>
   可能还会读到一些关于“双精度（double）”类型的参考。实际上
   double 和 float 是相同的，由于一些历史的原因，这两个名称同时存在。
  </para>
  <simpara>
   变量的类型通常不是由程序员设定的，确切地说，是由 PHP
   根据该变量使用的上下文在运行时决定的。
  </simpara>
  <note>
   <simpara>
    如果想查看某个<link linkend="language.expressions">表达式</link>的值和类型，用
    <function>var_dump</function>。
   </simpara>
   <para>
    如果只是想得到一个易读懂的类型的表达方式用于调试，用
    <function>gettype</function>。要查看某个类型，<emphasis>不要</emphasis>用
    <function>gettype</function>，而用 <literal>is_<replaceable>type</replaceable></literal> 函数。以下是一些范例：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bool = TRUE;   // a boolean
$str  = "foo";  // a string
$int  = 12;     // an integer

echo gettype($bool); // prints out "boolean"
echo gettype($str);  // prints out "string"

// If this is an integer, increment it by four
if (is_int($int)) {
    $int += 4;
}

// If $bool is a string, print it out
// (does not print out anything)
if (is_string($bool)) {
    echo "String: $bool";
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </note>
  <simpara>
   如果要将一个变量强制转换为某类型，可以对其使用<link
   linkend="language.types.typecasting">强制转换</link>或者 <function>settype</function> 函数。
  </simpara>
  <simpara>
   注意变量根据其当时的类型在特定场合下会表现出不同的值。更多信息见<link
   linkend="language.types.type-juggling">类型戏法</link>。此外，你还可以参考
    <link linkend="types.comparisons">PHP 类型比较表</link>看不同类型相互比较的例子。
  </simpara>
 </sect1>

 <sect1 xml:id="language.types.boolean">
  <title>布尔型</title>
  <simpara>
   这是最简单的类型。<type>boolean</type> 表达了真值，可以为 &true; 或 &false;。
  </simpara>
  <note>
   <simpara>
    布尔类型是 PHP 4 引进的。
   </simpara>
  </note>
  <sect2 xml:id="language.types.boolean.syntax">
   <title>语法</title>
   <para>
    要指定一个布尔值，使用关键字 &true; 或 &false;。两个都不区分大小写。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = True; // assign the value TRUE to $foo
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    通常你用某些<link linkend="language.operators">运算符</link>返回
    <type>boolean</type> 值，并将其传递给<link
    linkend="language.control-structures">控制流程</link>。
    <informalexample>
     <programlisting role="php">
<![CDATA[
// == is an operator which test
// equality and returns a boolean
if ($action == "show_version") {
    echo "The version is 1.23";
}

// this is not necessary...
if ($show_separators == TRUE) {
    echo "<hr>\n";
}

// ...because you can simply type
if ($show_separators) {
    echo "<hr>\n";
}
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>

  <sect2 xml:id="language.types.boolean.casting">
   <title>转换为布尔值</title>
   <simpara>
    要明示地将一个值转换成 <type>boolean</type>，用 <literal>(bool)</literal> 或者 <literal>(boolean)</literal> 来强制转换。但是很多情况下不需要用强制转换，因为当运算符，函数或者流程控制需要一个 <type>boolean</type> 参数时，该值会被自动转换。
   </simpara>
   <simpara>
    参见<link linkend="language.types.type-juggling">类型戏法</link>。
   </simpara>
   <para>
    当转换为 <type>boolean</type> 时，以下值被认为是 &false;：
    <itemizedlist>
     <listitem>
      <simpara><link linkend="language.types.boolean">布尔</link>值 &false;</simpara>
     </listitem>
     <listitem>
      <simpara><link linkend="language.types.integer">整型</link>值 0（零）</simpara>
     </listitem>
     <listitem>
      <simpara><link linkend="language.types.float">浮点型</link>值 0.0（零）</simpara>
     </listitem>
     <listitem>
      <simpara>
       空白<link linkend="language.types.string">字符串</link>和<link
       linkend="language.types.string">字符串</link> "0"
      </simpara>
     </listitem>
     <listitem>
      <simpara>没有成员变量的<link linkend="language.types.array">数组</link></simpara>
     </listitem>
     <listitem>
      <simpara>没有单元的<link linkend="language.types.object">对象</link>（仅适用于 PHP 4）</simpara>
     </listitem>
     <listitem>
      <simpara>特殊类型 <link linkend="language.types.null">NULL</link>（包括尚未设定的变量）</simpara>
     </listitem>
    </itemizedlist>
    所有其它值都被认为是 &true;（包括任何<link linkend="language.types.resource">资源</link>）。
    <warning>
     <simpara>
      <literal>-1</literal> 和其它非零值（不论正负）一样，被认为是 &true;！
     </simpara>
    </warning>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump((bool) "");        // bool(false)
var_dump((bool) 1);         // bool(true)
var_dump((bool) -2);        // bool(true)
var_dump((bool) "foo");     // bool(true)
var_dump((bool) 2.3e5);     // bool(true)
var_dump((bool) array(12)); // bool(true)
var_dump((bool) array());   // bool(false)
var_dump((bool) "false");   // bool(true)
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.types.integer">
  <title>整型</title>
  <simpara>
   一个 <type>integer</type> 是集合 Z = {..., -2, -1, 0, 1, 2, ...} 中的一个数。
  </simpara>
  <para>
   参见<link linkend="ref.gmp">任意长度整数（GMP）</link>，<link
   linkend="language.types.float">浮点数</link>和<link
   linkend="ref.bc">任意精度数学库（BCMath）</link>。
  </para>
  <sect2 xml:id="language.types.integer.syntax">
   <title>语法</title>
   <simpara>
    整型值可以用十进制，十六进制或八进制符号指定，前面可以加上可选的符号（- 或者 +）。
   </simpara>
   <para>
    如果用八进制符号，数字前必须加上 <literal>0</literal>（零），用十六进制符号数字前必须加上 <literal>0x</literal>。
    <example>
     <title>整数文字表达</title>
     <programlisting role="php">
<![CDATA[
<?php
$a = 1234; // 十进制数
$a = -123; // 一个负数
$a = 0123; // 八进制数（等于十进制的 83）
$a = 0x1A; // 十六进制数（等于十进制的 26）
?>
]]>
     </programlisting>
    </example>
    在字面上，整型变量正式的结构可以为：
    <informalexample>
     <programlisting>
<![CDATA[
decimal     : [1-9][0-9]*
            | 0

hexadecimal : 0[xX][0-9a-fA-F]+

octal       : 0[0-7]+

integer     : [+-]?decimal
            | [+-]?hexadecimal
            | [+-]?octal
]]>
     </programlisting>
    </informalexample>
    整型数的字长和平台有关，尽管通常最大值是大约二十亿（32 位有符号）。PHP 不支持无符号整数。
   </para>
   <warning>
    <para>
     如果向八进制数传递了一个非法数字（即 8 或 9），则后面其余数字会被忽略。
     <example>
      <title>八进制数的怪事</title>
      <programlisting role="php">
<![CDATA[
<?php
var_dump(01090); // 010 octal = 8 decimal
?>
]]>
      </programlisting>
     </example>
    </para>
   </warning>
  </sect2>

  <sect2 xml:id="language.types.integer.overflow">
   <title>整数溢出</title>
   <para>
    如果给定的一个数超出了 <type>integer</type> 的范围，将会被解释为
    <type>float</type>。同样如果执行的运算结果超出了
    <type>integer</type> 范围，也会返回 <type>float</type>。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$large_number =  2147483647;
var_dump($large_number);
// 输出为：int(2147483647)

$large_number =  2147483648;
var_dump($large_number);
// 输出为：float(2147483648)

// 同样也适用于十六进制表示的整数：
var_dump( 0x80000000 );
// 输出为：float(2147483648)

$million = 1000000;
$large_number =  50000 * $million;
var_dump($large_number);
// 输出为：float(50000000000)
?>
]]>
     </programlisting>
    </informalexample>
    <warning>
     <simpara>
      不幸的是 PHP 中有个 bug，因此当有负数参与时结果并不总是正确。例如当运算
      <literal>-50000 * $million</literal> 时结果是
      <literal>-429496728</literal>。不过当两个运算数都是正数时就没问题。
     </simpara>
     <simpara>
      这个问题已经在 PHP 4.1.0 中解决了。
     </simpara>
    </warning>
   </para>
   <para>
    PHP 中没有整除的运算符。<literal>1/2</literal> 产生出 <type>float</type>
    <literal>0.5</literal>。可以总是舍弃小数部分，或者使用 <function>round</function> 函数。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
var_dump(25/7);         // float(3.5714285714286)
var_dump((int) (25/7)); // int(3)
var_dump(round(25/7));  // float(4)
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>

  <sect2 xml:id="language.types.integer.casting">
   <title>转换为整形</title>
   <simpara>
    要明示地将一个值转换为 <type>integer</type>，用 <literal>(int)</literal> 或
    <literal>(integer)</literal> 强制转换。不过大多数情况下都不需要强制转换，因为当运算符，函数或流程控制需要一个
    <type>integer</type> 参数时，值会自动转换。还可以通过函数
    <function>intval</function> 来将一个值转换成整型。
   </simpara>
   <simpara>
    参见<link linkend="language.types.type-juggling">类型戏法</link>。
   </simpara>

   <sect3 xml:id="language.types.integer.casting.from-boolean">
    <title>从<link linkend="language.types.boolean">布尔值</link>转换</title>
    <simpara>
     &false; 将产生出 <literal>0</literal>（零），&true; 将产生出
     <literal>1</literal>（壹）。
    </simpara>
   </sect3>

   <sect3 xml:id="language.types.integer.casting.from-float">
    <title>从<link linkend="language.types.float">浮点数</link>转换</title>
    <simpara>
     当从浮点数转换成整数时，数字将被取整（<emphasis>丢弃小数位</emphasis>）。
    </simpara>
    <para>
     如果浮点数超出了整数范围（通常为
     <literal>+/- 2.15e+9 = 2^31</literal>），则结果不确定，因为没有足够的精度使浮点数给出一个确切的整数结果。在此情况下没有警告，甚至没有任何通知！
    </para>
    <para>
     【译者注】在 Linux 下返回结果是最小负数（-2147483648），而在
     Windows 下返回结果是零（0）。
    </para>
    <warning>
     <para>
      决不要将未知的分数强制转换为 <type>integer</type>，这样有时会导致意外的结果。
      <informalexample>
       <programlisting role="php">
<![CDATA[
<?php
echo (int) ( (0.1+0.7) * 10 ); // 显示 7！
?>
]]>
       </programlisting>
      </informalexample>
      更多信息见<link linkend="warn.float-precision">浮点数精度</link>。
     </para>
    </warning>
   </sect3>

   <sect3 xml:id="language.types.integer.casting.from-string">
    <title>从字符串转换</title>
    <simpara>
     参见<link linkend="language.types.string.conversion">字符串转换为数字</link>。
    </simpara>
   </sect3>

   <sect3 xml:id="language.types.integer.casting.from-other">
    <title>从其它类型转换</title>
    <caution>
     <simpara>
      没有定义从其它类型转换为整型的行为。目前的行为和值先<link
      linkend="language.types.boolean.casting">转换为布尔值</link>一样。不过<emphasis>不要</emphasis>依靠此行为，因为它会未加通知地改变。
     </simpara>
    </caution>
   </sect3>
  </sect2>
 </sect1>

 <sect1 xml:id="language.types.float">
  <title>浮点型</title>
  <para>
   浮点数（也叫浮点数，双精度数或实数）可以用以下任何语法定义：
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$a = 1.234;
$a = 1.2e3;
$a = 7E-10;
?>
]]>
    </programlisting>
   </informalexample>
   形式上：
   <informalexample>
    <programlisting role="php">
<![CDATA[
LNUM          [0-9]+
DNUM          ([0-9]*[\.]{LNUM}) | ({LNUM}[\.][0-9]*)
EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]? {LNUM})
]]>
    </programlisting>
   </informalexample>
   浮点数的字长和平台相关，尽管通常最大值是 1.8e308 并具有 14 位十进制数字的精度（64
   位 IEEE 格式）。
  </para>

  <warning xml:id="warn.float-precision">
   <title>浮点数精度</title>
   <para>
    显然简单的十进制分数如同 <literal>0.1</literal> 或 <literal>0.7</literal>
    不能在不丢失一点点精度的情况下转换为内部二进制的格式。这就会造成混乱的结果：例如，<literal>floor((0.1+0.7)*10)</literal>
    通常会返回 <literal>7</literal> 而不是预期中的
    <literal>8</literal>，因为该结果内部的表示其实是类似 <literal>7.9999999999...</literal>。
   </para>
   <para>
    这和一个事实有关，那就是不可能精确的用有限位数表达某些十进制分数。例如，十进制的
    <literal>1/3</literal> 变成了 <literal>0.3333333. . .</literal>。
   </para>
   <para>
    所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用<link
    linkend="ref.bc">任意精度数学函数</link>或者 <link linkend="ref.gmp">gmp 函数</link>。
   </para>
  </warning>

  <sect2 xml:id="language.types.float.casting">
   <title>转换为浮点数</title>
   <para>
    如果希望了解有关何时和如何将字符串转换成浮点数的信息，请查阅“<link
    linkend="language.types.string.conversion">将字符串转换为数值</link>”一节。对于其它类型的值，其情况类似于先将值转换成整型，然后再转换成浮点。请参阅“<link
    linkend="language.types.integer.casting">转换为整型</link>”一节以获取更多信息。自
    PHP 5 起，如果试图将对象转换为浮点数，会发出一条通知。
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.types.string">
  <title>字符串</title>
  <para>
   <type>string</type> 是一系列字符。在 PHP 中，字符和字节一样，也就是说，一共有 256 种不同字符的可能性。这也暗示 PHP 对 Unicode 没有本地支持。请参阅函数 <function>utf8_encode</function>
   和 <function>utf8_decode</function> 以了解有关 Unicode 支持。
  </para>
  <note>
   <simpara>
    一个字符串变得非常巨大也没有问题，PHP 没有给字符串的大小强加实现范围，所以完全没有理由担心长字符串。
   </simpara>
  </note>
  <sect2 xml:id="language.types.string.syntax">
   <title>语法</title>
   <para>
    字符串可以用三种字面上的方法定义。
    <itemizedlist>
     <listitem>
      <simpara>
       <link linkend="language.types.string.syntax.single">单引号</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.string.syntax.double">双引号</link>
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       <link linkend="language.types.string.syntax.heredoc">定界符</link>
      </simpara>
     </listitem>
    </itemizedlist>
   </para>
   <sect3 xml:id="language.types.string.syntax.single">
    <title>单引号</title>
    <para>
     指定一个简单字符串的最简单的方法是用单引号（字符 <literal>'</literal>）括起来。
    </para>
    <para>
     要表示一个单引号，需要用反斜线（<literal>\</literal>）转义，和很多其它语言一样。如果在单引号之前或字符串结尾需要出现一个反斜线，需要用两个反斜线表示。注意如果试图转义任何其它字符，反斜线本身也会被显示出来！所以通常不需要转义反斜线本身。
     <note>
      <simpara>
       在 PHP 3 中，此情况下将发出一个 <literal>E_NOTICE</literal> 级的警告。
      </simpara>
     </note>
     <note>
      <simpara>
       和其他两种语法不同，单引号字符串中出现的<link
       linkend="language.variables">变量</link>和转义序列<emphasis>不会</emphasis>被变量的值替代。
      </simpara>
     </note>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo 'this is a simple string';

echo 'You can also have embedded newlines in
strings this way as it is
okay to do';

// Outputs: Arnold once said: "I'll be back"
echo 'Arnold once said: "I\'ll be back"';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\\*.*?';

// Outputs: You deleted C:\*.*?
echo 'You deleted C:\*.*?';

// Outputs: This will not expand: \n a newline
echo 'This will not expand: \n a newline';

// Outputs: Variables do not $expand $either
echo 'Variables do not $expand $either';
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </sect3>
   <sect3 xml:id="language.types.string.syntax.double">
    <title>双引号</title>
    <para>
     如果用双引号（"）括起字符串，PHP 懂得更多特殊字符的转义序列：
    </para>
    <table>
     <title>转义字符</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>序列</entry>
        <entry>含义</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>\n</literal></entry>
        <entry>换行（LF 或 ASCII 字符 0x0A（10））</entry>
       </row>
       <row>
        <entry><literal>\r</literal></entry>
        <entry>回车（CR 或 ASCII 字符 0x0D（13））</entry>
       </row>
       <row>
        <entry><literal>\t</literal></entry>
        <entry>水平制表符（HT 或 ASCII 字符 0x09（9））</entry>
       </row>
       <row>
        <entry><literal>\\</literal></entry>
        <entry>反斜线</entry>
       </row>
       <row>
        <entry><literal>\$</literal></entry>
        <entry>美元符号</entry>
       </row>
       <row>
        <entry><literal>\"</literal></entry>
        <entry>双引号</entry>
       </row>
       <row>
        <entry><literal>\[0-7]{1,3}</literal></entry>
        <entry>
         此正则表达式序列匹配一个用八进制符号表示的字符
        </entry>
       </row>
       <row>
        <entry><literal>\x[0-9A-Fa-f]{1,2}</literal></entry>
        <entry>
         此正则表达式序列匹配一个用十六进制符号表示的字符
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    <para>
     此外，如果试图转义任何其它字符，反斜线本身也会被显示出来！在 PHP 5.1.1
     之前，<literal>\{$var}</literal> 中的反斜线不会被显示出来。
    </para>
    <para>
     双引号字符串最重要的一点是其中的变量名会被变量值替代。细节参见<link linkend="language.types.string.parsing">字符串解析</link>。
    </para>
   </sect3>

   <sect3 xml:id="language.types.string.syntax.heredoc">
    <title>定界符</title>
    <simpara>
     另一种给字符串定界的方法使用定界符语法（“&lt;&lt;&lt;”）。应该在 <literal>&lt;&lt;&lt;</literal> 之后提供一个标识符，然后是字符串，然后是同样的标识符结束字符串。
    </simpara>
    <simpara>
     结束标识符<emphasis>必须</emphasis>从行的第一列开始。同样，标识符也必须遵循 PHP 中其它任何标签的命名规则：只能包含字母数字下划线，而且必须以下划线或非数字字符开始。
    </simpara>
    <warning>
     <simpara>
      很重要的一点必须指出，结束标识符所在的行不能包含任何其它字符，<emphasis>可能</emphasis>除了一个分号（<literal>;</literal>）之外。这尤其意味着该标识符<emphasis>不能被缩进</emphasis>，而且在分号之前和之后都不能有任何空格或制表符。同样重要的是要意识到在结束标识符之前的第一个字符必须是你的操作系统中定义的换行符。例如在
      Macintosh 系统中是 <literal>\r</literal>。
     </simpara>
     <simpara>
      如果破坏了这条规则使得结束标识符不“干净”，则它不会被视为结束标识符，PHP
      将继续寻找下去。如果在这种情况下找不到合适的结束标识符，将会导致一个在脚本最后一行出现的语法错误。
     </simpara>
     <para>
      不能用定界符语法初始化类成员。用其它字符串语法替代。
      <example>
       <title>非法的例子</title>
       <programlisting role="php">
<![CDATA[
<?php
class foo {
    public $bar = <<<EOT
bar
EOT;
}
?>
]]>
       </programlisting>
      </example>
     </para>
    </warning>
    <para>
     定界符文本表现的就和双引号字符串一样，只是没有双引号。这意味着在定界符文本中不需要转义引号，不过仍然可以用以上列出来的转义代码。变量会被展开，但当在定界符文本中表达复杂变量时和字符串一样同样也要注意。
     <example>
      <title>定界符字符串例子</title>
      <programlisting role="php">
<![CDATA[
<?php
$str = <<<EOD
Example of string
spanning multiple lines
using heredoc syntax.
EOD;

/* More complex example, with variables. */
class foo
{
    var $foo;
    var $bar;

    function foo()
    {
        $this->foo = 'Foo';
        $this->bar = array('Bar1', 'Bar2', 'Bar3');
    }
}

$foo = new foo();
$name = 'MyName';

echo <<<EOT
My name is "$name". I am printing some $foo->foo.
Now, I am printing some {$foo->bar[1]}.
This should print a capital 'A': \x41
EOT;
?>
]]>
      </programlisting>
     </example>
    </para>
    <note>
     <para>
      定界符支持是 PHP 4 中加入的。
     </para>
    </note>
   </sect3>

   <sect3 xml:id="language.types.string.parsing">
    <title>变量解析</title>
    <simpara>
     当用双引号或者定界符指定字符串时，其中的<link
     linkend="language.variables">变量</link>会被解析。
    </simpara>
    <simpara>
     有两种语法，一种<link linkend="language.types.string.parsing.simple">简单的</link>和一种<link
     linkend="language.types.string.parsing.complex">复杂的</link>。简单语法最通用和方便，它提供了解析变量，数组值，或者对象属性的方法。
    </simpara>
    <simpara>
     复杂语法是 PHP 4 引进的，可以用花括号括起一个表达式。
    </simpara>
    <sect4 xml:id="language.types.string.parsing.simple">
     <title>简单语法</title>
     <simpara>
      如果遇到美元符号（<literal>$</literal>），解析器会尽可能多地取得后面的字符以组成一个合法的变量名。如果想明示指定名字的结束，用花括号把变量名括起来。
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$beer = 'Heineken';
echo "$beer's taste is great"; // works, "'" is an invalid character for varnames
echo "He drank some $beers";   // won't work, 's' is a valid character for varnames
echo "He drank some ${beer}s"; // works
echo "He drank some {$beer}s"; // works
?>
]]>
      </programlisting>
     </informalexample>
     <simpara>
      同样也可以解析数组索引或者对象属性。对于数组索引，右方括号（<literal>]</literal>）标志着索引的结束。对象属性则和简单变量适用同样的规则，尽管对于对象属性没有像变量那样的小技巧。
      <!-- XXX isn't &true; :(, this would be the trick
      Also, the same trick with curly-braces works if you
      want to limit the greediness of parsers.
      -->
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// These examples are specific to using arrays inside of strings.
// When outside of a string, always quote your array string keys
// and do not use {braces} when outside of strings either.

// Let's show all errors
error_reporting(E_ALL);

$fruits = array('strawberry' => 'red', 'banana' => 'yellow');
// Works but note that this works differently outside string-quotes
echo "A banana is $fruits[banana].";
// Works
echo "A banana is {$fruits['banana']}.";

// Works but PHP looks for a constant named banana first
// as described below.
echo "A banana is {$fruits[banana]}.";

// Won't work, use braces.  This results in a parse error.
echo "A banana is $fruits['banana'].";

// Works
echo "A banana is " . $fruits['banana'] . ".";

// Works

echo "This square is $square->width meters broad.";
// Won't work. For a solution, see the complex syntax.
echo "This square is $square->width00 centimeters broad.";
?>
]]>
<!-- XXX this won't work:
echo "This square is $square->{width}00 centimeters broad.";
// XXX: php developers: it would be consequent to make this work.
// XXX: like the $obj->{expr} syntax outside a string works,
// XXX: analogously to the ${expr} syntax for variable var's.
-->
      </programlisting>
     </informalexample>
     <simpara>
      对于任何更复杂的情况，应该使用复杂语法。
     </simpara>
    </sect4>

    <sect4 xml:id="language.types.string.parsing.complex">
     <title>复杂（花括号）语法</title>
     <simpara>
      不是因为语法复杂而称其为复杂，而是因为用此方法可以包含复杂的表达式。
     </simpara>
     <simpara>
      事实上，用此语法可以在字符串中包含任何在名字空间的值。仅仅用和在字符串之外同样的方法写一个表达式，然后用
      { 和 } 把它包含进来。因为不能转义“{”，此语法仅在 $ 紧跟在 {
      后面时被识别（用“{\$”来得到一个字面上的“{$”）。用一些例子可以更清晰：
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// Let's show all errors
error_reporting(E_ALL);

$great = 'fantastic';

// 不行，输出为：This is { fantastic}
echo "This is { $great}";

// 可以，输出为：This is fantastic
echo "This is {$great}";
echo "This is ${great}";

// Works
echo "This square is {$square->width}00 centimeters broad.";

// Works
echo "This works: {$arr[4][3]}";
// This is wrong for the same reason as $foo[bar] is wrong
// outside a string.  In otherwords, it will still work but
// because PHP first looks for a constant named foo, it will
// throw an error of level E_NOTICE (undefined constant).
echo "This is wrong: {$arr[foo][3]}";
// Works.  When using multi-dimensional arrays, always use
// braces around arrays when inside of strings
echo "This works: {$arr['foo'][3]}";

// Works.
echo "This works: " . $arr['foo'][3];

echo "You can even write {$obj->values[3]->name}";

echo "This is the value of the var named $name: {${$name}}";
?>
]]>
<!-- maybe it's better to leave this out??
// this works, but i disencourage its use, since this is NOT
// involving functions, rather than mere variables, arrays and objects.
$beer = 'Heineken';
echo "I'd like to have another {${ strrev('reeb') }}, hips";
 -->
      </programlisting>
     </informalexample>
    </sect4>
   </sect3>

   <sect3 xml:id="language.types.string.substr">
    <title>访问和修改字符串中的字符</title>
    <para>
     字符串中的字符可以通过在字符串之后用花括号指定所要字符从零开始的偏移量来访问和修改。
    </para>
    <note>
     <simpara>
      为了向下兼容，仍然可以用方括号。不过此语法自 PHP 4 起已过时。
     </simpara>
    </note>
    <para>
     <example>
      <title>一些字符串例子</title>
      <programlisting role="php">
<![CDATA[
<?php
// Get the first character of a string
$str = 'This is a test.';
$first = $str{0};
// Get the third character of a string
$third = $str{2};

// Get the last character of a string.
$str = 'This is still a test.';
$last = $str{strlen($str)-1};

// Modify the last character of a string
$str = 'Look at the sea';
$str{strlen($str)-1} = 'e';

?>
]]>
      </programlisting>
     </example>
    </para>
   </sect3>
  </sect2><!-- end syntax -->

  <sect2 xml:id="language.types.string.useful-funcs">
   <title>实用函数及运算符</title>
   <para>
    字符串可以用“.”（点）运算符连接。注意这里不能用“+”（加）运算符。更多信息参见<link
    linkend="language.operators.string">字符串运算符</link>。
   </para>
   <para>
    有很多实用函数来改变字符串。
   </para>
   <simpara>
    普通函数见<link linkend="ref.strings">字符串函数</link>一节，高级搜索和替换见正则表达式函数（两种风格：<link
    linkend="ref.pcre">Perl</link> 和 <link linkend="ref.regex">POSIX 扩展</link>）。
   </simpara>
   <simpara>
    还有 <link linkend="ref.url">URL 字符串函数</link>，以及加密／解密字符串的函数（<link
    linkend="ref.mcrypt">mcrypt</link> 和 <link linkend="ref.mhash">mhash</link>）。
   </simpara>
   <simpara>
    最后，如果还是找不到想要的函数，参见<link linkend="ref.ctype">字符类型函数</link>。
   </simpara>
  </sect2>

  <sect2 xml:id="language.types.string.casting">
   <title>字符串转换</title>
   <para>
    可以用 <literal>(string)</literal> 标记或者 <function>strval</function>
    函数将一个值转换为字符串。当某表达式需要字符串时，字符串的转换会在表达式范围内自动完成。例如当使用
    <function>echo</function> 或者 <function>print</function>
    函数时，或者将一个变量值与一个字符串进行比较的时候。阅读手册中有关<link
    linkend="language.types">类型</link>和<link
    linkend="language.types.type-juggling">类型戏法</link>中的部分有助于更清楚一些。参见
    <function>settype</function>。
   </para>
   <para>
    布尔值 &true; 将被转换为字符串 <literal>"1"</literal>，而值 &false; 将被表示为
    <literal>""</literal>（即空字符串）。这样就可以随意地在布尔值和字符串之间进行比较。
   </para>
   <para>
    整数或浮点数数值在转换成字符串时，字符串由表示这些数值的数字字符组成（浮点数还包含有指数部分）。
   </para>
   <para>
    数组将被转换成字符串 <literal>"Array"</literal>，因此无法通过
    <function>echo</function> 或者 <function>print</function>
    函数来输出数组的内容。请参考下文以获取更多提示。
   </para>
   <para>
    对象将被转换成字符串
    <literal>"Object"</literal>。如果因为调试需要，需要将对象的成员变量打印出来，请阅读下文。如果希望得到该对象所依附的类的名称，请使用函数
    <function>get_class</function>。自
    PHP 5 起，如果合适可以用 __toString() 方法。
   </para>
   <para>
    资源类型总是以 <literal>"Resource id #1"</literal> 的格式被转换成字符串，其中
    <literal>1</literal> 是 PHP
    在运行时给资源指定的唯一标识。如果希望获取资源的类型，请使用函数
    <function>get_resource_type</function>。
   </para>
   <para>
    &null; 将被转换成空字符串。
   </para>
   <para>
    正如以上所示，将数组、对象或者资源打印出来，并不能提供任何关于这些值本身的有用的信息。请参阅函数
    <function>print_r</function> 和 <function>var_dump</function>，对于调试来说，这些是更好的打印值的方法。
   </para>
   <para>
    可以将 PHP 的值转换为字符串以永久地储存它们。这种方法被称为序列化，可以用函数
    <function>serialize</function> 来完成该操作。如果在安装 PHP 时建立了
    <link linkend="ref.wddx">WDDX</link> 支持，还可以将 PHP 的值序列化为 XML 结构。
   </para>
  </sect2>

  <sect2 xml:id="language.types.string.conversion">
   <title>字符串转换为数值</title>
   <simpara>
    当一个字符串被当作数字来求值时，根据以下规则来决定结果的类型和值。
   </simpara>
   <simpara>
    如果包括“.”，“e”或“E”其中任何一个字符的话，字符串被当作
    <type>float</type> 来求值。否则就被当作整数。
   </simpara>
   <para>
    该值由字符串最前面的部分决定。如果字符串以合法的数字数据开始，就用该数字作为其值，否则其值为
    0（零）。合法数字数据由可选的正负号开始，后面跟着一个或多个数字（可选地包括十进制分数），后面跟着可选的指数。指数是一个“e”或者“E”后面跟着一个或多个数字。
   </para>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo = 1 + "10.5";                // $foo is float (11.5)
$foo = 1 + "-1.3e3";              // $foo is float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo is integer (1)
$foo = 1 + "bob3";                // $foo is integer (1)
$foo = 1 + "10 Small Pigs";       // $foo is integer (11)
$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)
$foo = "10.0 pigs " + 1;          // $foo is float (11)
$foo = "10.0 pigs " + 1.0;        // $foo is float (11)
?>
]]>
    </programlisting>
   </informalexample>
   <simpara>
    此转换的更多信息见 Unix 手册中关于 strtod(3) 的部分。
   </simpara>
   <para>
    如果想测试本节中的任何例子，可以拷贝和粘贴这些例子并且加上下面这一行自己看看会发生什么：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
echo "\$foo==$foo; type is " . gettype ($foo) . "<br />\n";
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    不要指望在将一个字符转换成整型时能够得到该字符的编码（可能也会在
    C 中这么做）。如果希望在字符编码和字符之间转换，请使用
    <function>ord</function> 和 <function>chr</function> 函数。
   </para>
  </sect2>
 </sect1><!-- end string -->

 <sect1 xml:id="language.types.array">
  <title>数组</title>

  <para>
   PHP 中的数组实际上是一个有序图。图是一种把 <emphasis>values</emphasis>
   映射到 <emphasis>keys</emphasis> 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组来使用，或列表（矢量），散列表（是图的一种实现），字典，集合，栈，队列以及更多可能性。因为可以用另一个
   PHP 数组作为值，也可以很容易地模拟树。
  </para>
  <para>
   解释这些结构超出了本手册的范围，但对于每种结构至少会发现一个例子。要得到这些结构的更多信息，建议参考有关此广阔主题的外部著作。
  </para>

  <sect2 xml:id="language.types.array.syntax">
   <title>语法</title>
   <sect3 xml:id="language.types.array.syntax.array-func">
    <title>定义 <function>array</function></title>
    <para>
     可以用 <function>array</function> 语言结构来新建一个 <type>array</type>。它接受一定数量用逗号分隔的
     <literal><replaceable>key</replaceable> =&gt; <replaceable>value</replaceable></literal> 参数对。
    </para>
    <para>
     <synopsis>
array( <optional> <replaceable>key</replaceable> =&gt; </optional>
<replaceable>value</replaceable>
     , ...
     )
// <replaceable>key</replaceable> 可以是 <type>integer</type> 或者 <type>string</type>
// <replaceable>value</replaceable> 可以是任何值
     </synopsis>
    </para>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr = array("foo" => "bar", 12 => true);

echo $arr["foo"]; // bar
echo $arr[12];    // 1
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     <varname>key</varname> 可以是 <type>integer</type> 或者 <type>string</type>。如果键名是一个
     <type>integer</type> 的标准表达方法，则被解释为整数（例如 <literal>"8"</literal> 将被解释为
     <literal>8</literal>，而 <literal>"08"</literal> 将被解释为 <literal>"08"</literal>）。<varname>key</varname>
     中的浮点数被取整为 <type>integer</type>。PHP
     中没有不同的数字下标和关联下标数组，数组的类型只有一种，它可以同时包含整型和字符串型的下标。
    </para>
    <para>
     值可以是任何值。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr = array("somearray" => array(6 => 5, 13 => 9, "a" => 42));

echo $arr["somearray"][6];    // 5
echo $arr["somearray"][13];   // 9
echo $arr["somearray"]["a"];  // 42
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     如果对给出的值没有指定键名，则取当前最大的整数索引值，而新的键名将是该值加一。如果指定的键名已经有了值，则该值会被覆盖。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// This array is the same as ...
array(5 => 43, 32, 56, "b" => 12);

// ...this array
array(5 => 43, 6 => 32, 7 => 56, "b" => 12);
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <warning>
     <simpara>
      自 PHP 4.3.0 起，上述的索引生成方法改变了。如今如果给一个当前最大键名是负值的数组添加一个新值，则新生成的的索引将为零（<literal>0</literal>）。以前新生成的索引为当前最大索引加一，和正值的索引相同。
     </simpara>
    </warning>
    <para>
     使用 &true; 作为键名将使 <type>integer</type> <literal>1</literal> 成为键名。使用
     &false; 作为键名将使 <type>integer</type> <literal>0</literal> 成为键名。使用
     <literal>NULL</literal> 作为键名将等同于使用空字符串。使用空字符串作为键名将新建（或覆盖）一个用空字符串作为键名的值，这和用空的方括号不一样。
    </para>
    <para>
     不能用数组和对象作为键名。这样做会导致一个警告：<literal>Illegal offset type</literal>。
    </para>
   </sect3>

   <sect3 xml:id="language.types.array.syntax.modifying">
    <title>用方括号的语法新建／修改</title>
    <para>
     可以通过明示地设定值来改变一个现有的数组。
    </para>
    <para>
     这是通过在方括号内指定键名来给数组赋值实现的。也可以省略键名，在这种情况下给变量名加上一对空的方括号（“<literal>[]</literal>”）。
     <synopsis>
$arr[<replaceable>key</replaceable>] = <replaceable>value</replaceable>;
$arr[] = <replaceable>value</replaceable>;
// <replaceable>key</replaceable> 可以是 <type>integer</type> 或者 <type>string</type>
// <replaceable>value</replaceable> 可以为任何值。
     </synopsis>
     如果 <varname>$arr</varname> 还不存在，将会新建一个。这也是一种定义数组的替换方法。要改变一个值，只要给它赋一个新值。如果要删除一个键名／值对，要对它用 <function>unset</function>。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$arr = array(5 => 1, 12 => 2);
$arr[] = 56;    // This is the same as $arr[13] = 56;
                // at this point of the script
$arr["x"] = 42; // This adds a new element to
                // the array with key "x"
unset($arr[5]); // This removes the element from the array
unset($arr);    // This deletes the whole array
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <note>
     <para>
      如上所述，如果给出方括号但没有指定键名，则取当前最大整数索引值，新的键名将是该值
      + 1。如果当前还没有整数索引，则键名将为
      <literal>0</literal>。如果指定的键名已经有值了，该值将被覆盖。
     </para>
     <para>
      <warning>
       <simpara>
        自 PHP 4.3.0 起，上述的索引生成方法改变了。如今如果给一个当前最大键名是负值的数组添加一个新值，则新生成的的索引将为零（<literal>0</literal>）。以前新生成的索引为当前最大索引加一，和正值的索引相同。
       </simpara>
      </warning>
     </para>
     <para>
      注意这里所使用的最大整数键名<emphasis>不一定</emphasis>当前就在数组中。它只要在上次数组重新生成索引后曾经存在过就行了。以下面的例子来说明：
     </para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// 创建一个简单的数组
$array = array(1, 2, 3, 4, 5);
print_r($array);

// 现在删除其中的所有单元，但保持数组本身的结构
foreach ($array as $i => $value) {
    unset($array[$i]);
}
print_r($array);

// 添加一个单元（注意新的键名是 5，而不是你可能以为的 0）
$array[] = 6;
print_r($array);

// 重新索引：
$array = array_values($array);
$array[] = 7;
print_r($array);
?>
]]>
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
Array
(
    [0] => 1
    [1] => 2
    [2] => 3
    [3] => 4
    [4] => 5
)
Array
(
)
Array
(
    [5] => 6
)
Array
(
    [0] => 6
    [1] => 7
)
]]>
      </screen>
     </informalexample>
    </note>
   </sect3>
  </sect2><!-- end syntax -->

  <sect2 xml:id="language.types.array.useful-funcs">
   <title>实用函数</title>
   <para>
    有相当多的实用函数作用于数组，参见<link linkend="ref.array">数组函数</link>一节。
   </para>
   <note>
    <para>
     <function>unset</function> 函数允许取消一个数组中的键名。要注意数组将不会重建索引。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?PHP
$a = array( 1 => 'one', 2 => 'two', 3 => 'three' );
unset( $a[2] );
/* 将产生一个数组，定义为
   $a = array( 1=>'one', 3=>'three');
   而不是
   $a = array( 1 => 'one', 2 => 'three');
*/
$b = array_values($a);
// Now $b is array(0 => 'one', 1 =>'three')
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </note>
   <para>
    <link linkend="control-structures.foreach">foreach</link> 控制结构是专门用于数组的。它提供了一个简单的方法来遍历数组。
   </para>
  </sect2>

  <sect2 xml:id="language.types.array.donts">
   <title>数组做什么和不做什么</title>
   <sect3 xml:id="language.types.array.foo-bar">
    <title>为什么 <literal>$foo[bar]</literal> 错了？</title>
    <para>
     应该始终在用字符串表示的数组索引上加上引号。例如用
     $foo['bar'] 而不是 $foo[bar]。但是为什么 $foo[bar] 错了呢？可能在老的脚本中见过如下语法：
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$foo[bar] = 'enemy';
echo $foo[bar];
// etc
?>
]]>
      </programlisting>
     </informalexample>
     这样是错的，但可以正常运行。那么为什么错了呢？原因是此代码中有一个未定义的常量（bar）而不是字符串（'bar'－注意引号），而 PHP 可能会在以后定义此常量，不幸的是你的代码中有同样的名字。它能运行，是因为
     PHP 自动将<emphasis>裸字符串</emphasis>（没有引号的字符串且不对应于任何已知符号）转换成一个其值为该裸字符串的正常字符串。例如，如果没有常量定义为
     <constant>bar</constant>，PHP 将把它替代为 <literal>'bar'</literal> 并使用之。
    </para>
    <note>
     <simpara>
      这并不意味着<emphasis>总是</emphasis>给键名加上引号。用不着给键名为<link
      linkend="language.constants">常量</link>或<link
      linkend="language.variables">变量</link>的加上引号，否则会使 PHP
      不能解析它们。
     </simpara>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
error_reporting(E_ALL);
ini_set('display_errors', true);
ini_set('html_errors', false);
// Simple array:
$array = array(1, 2);
$count = count($array);
for ($i = 0; $i < $count; $i++) {
    echo "\nChecking $i: \n";
    echo "Bad: " . $array['$i'] . "\n";
    echo "Good: " . $array[$i] . "\n";
    echo "Bad: {$array['$i']}\n";
    echo "Good: {$array[$i]}\n";
}
?>
]]>
      </programlisting>
     </informalexample>
     &example.outputs.similar;
     <screen>
<![CDATA[
Checking 0:
Notice: Undefined index:  $i in /path/to/script.php on line 10
Bad:
Good: 1
Notice: Undefined index:  $i in /path/to/script.php on line 12
Bad:
Good: 1

Checking 1:
Notice: Undefined index:  $i in /path/to/script.php on line 10
Bad:
Good: 2
Notice: Undefined index:  $i in /path/to/script.php on line 12
Bad:
Good: 2
]]>
     </screen>
    </note>
    <para>
     演示此效应的更多例子：
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
// 显示所有错误
error_reporting(E_ALL);

$arr = array('fruit' => 'apple', 'veggie' => 'carrot');

// 正确
print $arr['fruit'];  // apple
print $arr['veggie']; // carrot

// 不正确。This works but also throws a PHP error of
// level E_NOTICE because of an undefined constant named fruit
//
// Notice: Use of undefined constant fruit - assumed 'fruit' in...
print $arr[fruit];    // apple

// Let's define a constant to demonstrate what's going on.  We
// will assign value 'veggie' to a constant named fruit.
define('fruit','veggie');

// Notice the difference now
print $arr['fruit'];  // apple
print $arr[fruit];    // carrot

// The following is okay as it's inside a string.  Constants are not
// looked for within strings so no E_NOTICE error here
print "Hello $arr[fruit]";      // Hello apple

// With one exception, braces surrounding arrays within strings
// allows constants to be looked for
print "Hello {$arr[fruit]}";    // Hello carrot
print "Hello {$arr['fruit']}";  // Hello apple

// This will not work, results in a parse error such as:
// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'
// This of course applies to using autoglobals in strings as well
print "Hello $arr['fruit']";
print "Hello $_GET['foo']";

// Concatenation is another option
print "Hello " . $arr['fruit']; // Hello apple
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <para>
     当打开 <function>error_reporting</function> 来显示
     <constant>E_NOTICE</constant> 级别的错误（例如将其设为
     <constant>E_ALL</constant>）时将看到这些错误。默认情况下
     <link linkend="ini.error-reporting">error_reporting</link>
     被关闭不显示这些。
    </para>
    <para>
     和在<link linkend="language.types.array.syntax">语法</link>一节中规定的一样，在方括号（“<literal>[</literal>”和“<literal>]</literal>”）之间必须有一个表达式。这意味着可以这样写：
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
echo $arr[somefunc($bar)];
?>
]]>
      </programlisting>
     </informalexample>
     这是一个用函数返回值作为数组索引的例子。PHP 也可以用已知常量，可能之前已经见过
     <literal>E_*</literal>。
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[E_ERROR]   = "A fatal error has occured";
$error_descriptions[E_WARNING] = "PHP issued a warning";
$error_descriptions[E_NOTICE]  = "This is just an informal notice";
?>
]]>
      </programlisting>
     </informalexample>
     注意 <literal>E_ERROR</literal> 也是个合法的标识符，就和第一个例子中的
     <literal>bar</literal> 一样。但是上一个例子实际上和如下写法是一样的：
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
$error_descriptions[1] = "A fatal error has occured";
$error_descriptions[2] = "PHP issued a warning";
$error_descriptions[8] = "This is just an informal notice";
?>
]]>
      </programlisting>
     </informalexample>
     因为 <literal>E_ERROR</literal> 等于 <literal>1</literal>，等等。
    </para>
    <para>
     如同在以上例子中解释的那样，<literal>$foo[bar]</literal>
     起作用但其实是错误的。它起作用是因为根据语法的预期，<literal>bar</literal> 被当成了一个常量表达式。然而，在这个例子中不存在名为
     <literal>bar</literal> 的常量。PHP 就假定指的是字面上的 <literal>bar</literal>，也就是字符串
     <literal>"bar"</literal>，但忘记加引号了。
    </para>
    <sect4>
     <title>那么为什么这样做不好？</title>
     <para>
      在未来的某一时刻，PHP 开发小组可能会想新增一个常量或者关键字，或者用户可能希望以后在自己的程序中引入新的常量，那就有麻烦了。例如已经不能这样用
      <literal>empty</literal> 和 <literal>default</literal> 这两个词了，因为他们是<link linkend="reserved">保留字</link>。
     </para>
     <note>
      <simpara>
       重申一次，在双引号字符串中，不给索引加上引号是合法的因此
       <literal>"$foo[bar]"</literal>是合法的。至于为什么参见以上的例子和<link
       linkend="language.types.string.parsing">字符串中的变量解析</link>中的解释。
      </simpara>
     </note>
    </sect4>
   </sect3>
  </sect2>

  <sect2 xml:id="language.types.array.casting">
   <title>转换为数组</title>
   <para>
    对于任何的类型：整型、浮点、字符串、布尔和资源，如果将一个值转换为数组，将得到一个仅有一个元素的数组（其下标为 0），该元素即为此标量的值。
   </para>
   <para>
    如果将一个对象转换成一个数组，所得到的数组的元素为该对象的属性（成员变量），其键名为成员变量名。
   </para>
   <para>
    如果将一个 &null; 值转换成数组，将得到一个空数组。
   </para>
  </sect2>

  <sect2 xml:id="language.types.array.comparing">
   <title>比较</title>
   <para>
    有可能通过 <function>array_diff</function> 和<link
    linkend="language.operators.array">数组运算符</link>来比较数组。
   </para>
  </sect2>

  <sect2 xml:id="language.types.array.examples">
   <title>例子</title>
   <para>
    PHP 中的数组类型有非常多的用途，因此这里有一些例子展示数组的完整威力。
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// this
$a = array( 'color' => 'red',
            'taste' => 'sweet',
            'shape' => 'round',
            'name'  => 'apple',
                       4        // key will be 0
          );

// is completely equivalent with
$a['color'] = 'red';
$a['taste'] = 'sweet';
$a['shape'] = 'round';
$a['name']  = 'apple';
$a[]        = 4;        // key will be 0

$b[] = 'a';
$b[] = 'b';
$b[] = 'c';
// will result in the array array(0 => 'a' , 1 => 'b' , 2 => 'c'),
// or simply array('a', 'b', 'c')
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <example>
    <title>使用 array()</title>
    <programlisting role="php">
<![CDATA[
<?php
// Array as (property-)map
$map = array( 'version'    => 4,
              'OS'         => 'Linux',
              'lang'       => 'english',
              'short_tags' => true
            );

// strictly numerical keys
$array = array( 7,
                8,
                0,
                156,
                -10
              );
// this is the same as array(0 => 7, 1 => 8, ...)

$switching = array(         10, // key = 0
                    5    =>  6,
                    3    =>  7,
                    'a'  =>  4,
                            11, // key = 6 (maximum of integer-indices was 5)
                    '8'  =>  2, // key = 8 (integer!)
                    '02' => 77, // key = '02'
                    0    => 12  // the value 10 will be overwritten by 12
                  );
// empty array
$empty = array();
?>
]]>
<!-- TODO example of
- overwriting keys
- using vars/functions as key/values
- warning about references
-->
    </programlisting>
   </example>
   <example xml:id="language.types.array.examples.loop">
    <title>集合</title>
    <programlisting role="php">
<![CDATA[
<?php
$colors = array('red', 'blue', 'green', 'yellow');

foreach ($colors as $color) {
    echo "Do you like $color?\n";
}

?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Do you like red?
Do you like blue?
Do you like green?
Do you like yellow?
]]>
    </screen>
   </example>
   <para>
    直接改变数组的值在 PHP 5 中可以通过引用传递来做到。之前的版本需要需要采取别的方法：
    <example xml:id="language.types.array.examples.changeloop">
     <title>集合</title>
     <programlisting role="php">
<![CDATA[
<?php
// PHP 5
foreach ($colors as &$color) {
    $color = strtoupper($color);
}
unset($color); /* 确保下面对 $color 的覆盖不会影响到前一个数组单元 */
// 之前版本的方法
foreach ($colors as $key => $color) {
    $colors[$key] = strtoupper($color);
}

print_r($colors);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Array
(
    [0] => RED
    [1] => BLUE
    [2] => GREEN
    [3] => YELLOW
)
]]>
     </screen>
    </example>
   </para>
   <para>
    本例产生一个下标从 1 开始的数组。
    <example>
     <title>下标从 1 开始的数组</title>
     <programlisting role="php">
<![CDATA[
<?php
$firstquarter  = array(1 => 'January', 'February', 'March');
print_r($firstquarter);
?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
Array
(
    [1] => 'January'
    [2] => 'February'
    [3] => 'March'
)
*/
?>
]]>
    </screen>
   </example>
  </para>
  <example>
   <title>填充数组</title>
   <programlisting role="php">
<![CDATA[
<?php
// fill an array with all items from a directory
$handle = opendir('.');
while (false !== ($file = readdir($handle))) {
    $files[] = $file;
}
closedir($handle);
?>
]]>
    </programlisting>
   </example>
   <para>
    数组是有序的。也可以使用不同的排序函数来改变顺序。更多信息参见<link
    linkend="ref.array">数组函数</link>。可以用
    <function>count</function> 函数来数出数组中元素的个数。
   </para>
   <example>
    <title>数组排序</title>
    <programlisting role="php">
<![CDATA[
<?php
sort($files);
print_r($files);
?>
]]>
    </programlisting>
   </example>
   <para>
    因为数组中的值可以为任意值，也可是另一个数组。这样可以产生递归或多维数组。
   </para>
   <example>
    <title>递归和多维数组</title>
    <programlisting role="php">
<![CDATA[
<?php
$fruits = array ( "fruits"  => array ( "a" => "orange",
                                       "b" => "banana",
                                       "c" => "apple"
                                     ),
                  "numbers" => array ( 1,
                                       2,
                                       3,
                                       4,
                                       5,
                                       6
                                     ),
                  "holes"   => array (      "first",
                                       5 => "second",
                                            "third"
                                     )
                );

// Some examples to address values in the array above
echo $fruits["holes"][5];    // prints "second"
echo $fruits["fruits"]["a"]; // prints "orange"
unset($fruits["holes"][0]);  // remove "first"

// Create a new multi-dimensional array
$juices["apple"]["green"] = "good";
?>
]]>
    </programlisting>
   </example>
   <para>
    需要注意数组的赋值总是会涉及到值的拷贝。这还意味着在 <function>current</function>
    以及类似函数中使用的内部数组指针会被重置。需要在复制数组时用引用符号（&amp;）。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$arr1 = array(2, 3);
$arr2 = $arr1;
$arr2[] = 4; // $arr2 is changed,
             // $arr1 is still array(2,3)

$arr3 = &$arr1;
$arr3[] = 4; // now $arr1 and $arr3 are the same
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.types.object">
  <title>对象</title>
  <sect2 xml:id="language.types.object.init">
   <title>对象初始化</title>
   <para>
    要初始化一个对象，用 <literal>new</literal> 语句将对象实例到一个变量中。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class foo
{
    function do_foo()
    {
        echo "Doing foo.";
    }
}

$bar = new foo;
$bar->do_foo();
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <simpara>
    完整的讨论见<link linkend="language.oop">类与对象</link>一章。
   </simpara>
  </sect2>
  <sect2 xml:id="language.types.object.casting">
   <title>转换为对象</title>
   <para>
    如果将一个对象转换成对象，它将不会有任何变化。如果其它任何类型的值被转换成对象，内置类
    <literal>stdClass</literal> 的一个实例将被建立。如果该值为
    &null;，则新的实例为空。数组转换成对象将使键名成为属性名并具有相对应的值。对于任何其它的值，名为
    <literal>scalar</literal> 的成员变量将包含该值。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$obj = (object) 'ciao';
echo $obj->scalar;  // outputs 'ciao'
?>
]]>
     </programlisting>
    </informalexample>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.types.resource">
  <title>资源</title>
  <para>
   资源是一种特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。所有这些函数及其相应资源类型见<link linkend="resource">附录</link>。
  </para>
  <note>
   <simpara>
    资源类型是 PHP 4 引进的。
   </simpara>
  </note>
  <para>
   参见 <function>get_resource_type</function>。
  </para>
  <sect2 xml:id="language.types.resource.casting">
   <title>转换为资源</title>
   <para>
    由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此无法将其它类型的值转换为资源。
   </para>
  </sect2>

  <sect2 xml:id="language.types.resource.self-destruct">
   <title>释放资源</title>
   <para>
    由于 PHP4 Zend 引擎引进了资源计数系统，可以自动检测到一个资源不再被引用了（和 Java 一样）。这种情况下此资源使用的所有外部资源都会被垃圾回收系统释放。由此原因，很少需要用某些 free-result 函数来手工释放内存。
    <note>
     <simpara>
      持久数据库连接比较特殊，它们<emphasis>不会</emphasis>被垃圾回收系统破坏。参见<link
      linkend="features.persistent-connections">数据库永久连接</link>一章。
     </simpara>
    </note>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.types.null">
  <title>NULL</title>
  <para>
   特殊的 &null; 值表示一个变量没有值。<type>NULL</type> 类型唯一可能的值就是 &null;。
  </para>
  <note>
   <simpara>
    <type>NULL</type> 类型是 PHP 4 引进的。
   </simpara>
  </note>
  <para>
   在下列情况下一个变量被认为是 &null;：
   <itemizedlist>
    <listitem>
     <para>
      被赋值为 &null;。
     </para>
    </listitem>
    <listitem>
     <para>
      尚未被赋值。
     </para>
    </listitem>
    <listitem>
     <para>
      被 <function>unset</function>。
     </para>
    </listitem>
   </itemizedlist>
  </para>
  <sect2 xml:id="language.types.null.syntax">
   <title>语法</title>
   <para>
    &null; 类型只有一个值，就是大小写不敏感的关键字 &null;（你可以写成NULL，也可以写成null）。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$var = NULL;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    参见 <function>is_null</function> 和 <function>unset</function>。
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.pseudo-types">
  <title>本文档中使用的伪类型</title>
  <sect2 xml:id="language.types.mixed">
   <title>mixed</title>
   <para>
    <literal>mixed</literal> 说明一个参数可以接受多种不同的（但并不必须是所有的）类型。
   </para>
   <para>
    例如 <function>gettype</function> 可以接受所有的 PHP 类型，<function>str_replace</function> 可以接受字符串和数组。
   </para>
  </sect2>

  <sect2 xml:id="language.types.number">
   <title>number</title>
   <para>
    <literal>number</literal> 说明一个参数可以是 <type>integer</type> 或者 <type>float</type>。
   </para>
  </sect2>

  <sect2 xml:id="language.types.callback">
   <title>callback</title>
   <para>
    有些诸如 <function>call_user_function</function> 或 <function>usort</function> 的函数接受用户自定义的函数作为一个参数。Callback 函数不仅可以是一个简单的函数，它还可以是一个对象的方法，包括静态类的方法。
   </para>
   <para>
    一个 PHP 函数用函数名字符串来传递。可以传递任何内置的或者用户自定义的函数，除了
    <function>array</function>，<function>echo</function>，<function>empty</function>，<function>eval</function>，<function>exit</function>，<function>isset</function>，<function>list</function>，<function>print</function>
    和 <function>unset</function>。
   </para>
   <para>
    一个对象的方法以数组的形式来传递，数组的下标 0 指明对象名，下标 1 指明方法名。
   </para>
   <para>
    对于没有实例化为对象的静态类，要传递其方法，将数组 0 下标指明的对象名换成该类的名称即可。
   </para>
   <para>
    <example>
     <title>Callback 函数实例</title>
     <programlisting role="php">
<![CDATA[
<?php
// An example callback function
function my_callback_function() {
    echo 'hello world!';
}

// An example callback method
class MyClass {
    function myCallbackMethod() {
        echo 'Hello World!';
    }
}

// Type 1: Simple callback
call_user_func('my_callback_function');

// Type 2: Static class method call
call_user_func(array('MyClass', 'myCallbackMethod'));

// Type 3: Object method call
$obj = new MyClass();
call_user_func(array($obj, 'myCallbackMethod'));
?>
]]>
     </programlisting>
    </example>
   </para>
  </sect2>
 </sect1>

 <sect1 xml:id="language.types.type-juggling">
  <title>类型戏法</title>
  <simpara>
   PHP 在变量定义中不需要（或不支持）明示的类型定义；变量类型是根据使用该变量的上下文所决定的。也就是说，如果把一个字符串值赋给变量
   <parameter>var</parameter>，<parameter>var</parameter>
   就成了一个字符串。如果又把一个整型值赋给
   <parameter>var</parameter>，那它就成了一个整数。
  </simpara>
  <para>
   PHP 的自动类型转换的一个例子是加号“+”。如果任何一个运算数是浮点数，则所有的运算数都被当成浮点数，结果也是浮点数。否则运算数会被解释为整数，结果也是整数。注意这并没有改变这些运算数本身的类型；改变的仅是这些运算数如何被求值。
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$foo = "0";  // $foo is string (ASCII 48)
$foo += 2;   // $foo is now an integer (2)
$foo = $foo + 1.3;  // $foo is now a float (3.3)
$foo = 5 + "10 Little Piggies"; // $foo is integer (15)
$foo = 5 + "10 Small Pigs";     // $foo is integer (15)
?>
]]>
<!-- bad example, no real operator (must be used with variable, modifies it too)
  $foo++;      // $foo is the string "1" (ASCII 49)

TODO: explain ++/- - behaviour with strings

examples:

++'001' = '002'
++'abc' = 'abd'
++'xyz' = 'xza'
++'9.9' = '9.0'
++'-3'  = '-4'
- -'9'   = 8 (integer!)
- -'5.5' = '5.5'
- -'-9'  = -10 (integer)
- -'09'  = 8 (integer)
- -'abc' = 'abc'

-->
    </programlisting>
   </informalexample>
  </para>
  <simpara>
   如果上面两个例子看上去古怪的话，参见<link linkend="language.types.string.conversion">字符串转换为数值</link>。
  </simpara>
  <simpara>
   如果要强制将一个变量当作某种类型来求值，参见<link
   linkend="language.types.typecasting">类型强制转换</link>一节。如果要改变一个变量的类型，参见 <function>settype</function>。
  </simpara>
  <para>
   如果想要测试本节中任何例子的话，可以用 <function>var_dump</function> 函数。
  </para>
  <note>
   <para>
    数组的自动转换行为目前没有定义。
   </para>
   <para>
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a = "1";     // $a 是字符串
$a[0] = "f";  // 是字符串偏移量吗？结果会是什么？
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    由于一些历史原因，PHP 支持通过偏移量进行的字符串索引，这和数组索引的语法一样。以上的例子就产生了一个问题：$a
    应该变成一个第一个元素是“f”的数组呢，还是“f”成了字符串 $a 的第一个字符？
   </para>
   <para>
    目前版本的 PHP 将以上第二个赋值理解成字符串的偏移量标识，即 $a 变成了
    "f"，尽管如此，这种自动转换的地结果应该被认为未定义。PHP 4
    引入了新的花括号语法来访问字符串的字符，请使用该语法来替代以上的操作：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$a    = "abc"; // $a 为一个字符串
$a{1} = "f";   // $a 目前为 "afc"
?>
]]>
     </programlisting>
    </informalexample>
    请参阅<link linkend="language.types.string.substr">访问和修改字符串中的字符</link>一节以获取更多信息。
   </para>
  </note>
  <sect2 xml:id="language.types.typecasting">
   <title>类型强制转换</title>
   <para>
    PHP 中的类型强制转换和 C 中的非常像：在要转换的变量之前加上用括号括起来的目标类型。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 10;   // $foo is an integer
$bar = (boolean) $foo;   // $bar is a boolean
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    允许的强制转换有：
    <itemizedlist>
     <listitem>
      <simpara>(int)，(integer) - 转换成整型</simpara>
     </listitem>
     <listitem>
      <simpara>(bool)，(boolean) - 转换成布尔型</simpara>
     </listitem>
     <listitem>
      <simpara>(float)，(double)，(real) - 转换成浮点型</simpara>
     </listitem>
     <listitem>
      <simpara>(string) - 转换成字符串</simpara>
     </listitem>
     <listitem>
      <simpara>(array) - 转换成数组</simpara>
     </listitem>
     <listitem>
      <simpara>(object) - 转换成对象</simpara>
     </listitem>
    </itemizedlist>
   </para>
   <para>
    注意在括号内允许有空格和制表符，所以下面两个例子功能相同：
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = (int) $bar;
$foo = ( int ) $bar;
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <note>
    <para>
     为了将一个变量还原为字符串，还可以将变量放置在双引号中。
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$foo = 10;            // $foo is an integer
$str = "$foo";        // $str is a string
$fst = (string) $foo; // $fst is also a string

// This prints out that "they are the same"
if ($fst === $str) {
    echo "they are the same";
}
?>
]]>
     </programlisting>
    </informalexample>
    </para>
   </note>
   <para>
    当在某些类型之间强制转换时确切地会发生什么可能不是很明显。更多信息见如下小节：
    <itemizedlist>
     <listitem>
      <simpara><link linkend="language.types.boolean.casting">转换为布尔值</link></simpara>
     </listitem>
     <listitem>
      <simpara><link linkend="language.types.integer.casting">转换为整型</link></simpara>
     </listitem>
     <listitem>
      <simpara><link linkend="language.types.float.casting">转换为浮点型</link></simpara>
     </listitem>
     <listitem>
      <simpara><link linkend="language.types.string.casting">转换为字符串</link></simpara>
     </listitem>
     <listitem>
      <simpara><link linkend="language.types.array.casting">转换为数组</link></simpara>
     </listitem>
     <listitem>
      <simpara><link linkend="language.types.object.casting">转换为对象</link></simpara>
     </listitem>
     <listitem>
      <simpara><link linkend="language.types.resource.casting">转换为资源</link></simpara>
     </listitem>
     <!-- don't exist yet
     <listitem>
      <simpara><link linkend="language.types.null.casting">Converting to
       &null;</link></simpara>
     </listitem>
     -->
     <listitem>
      <simpara>
       <link linkend="types.comparisons">类型比较表</link>
      </simpara>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>
 </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
