<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.17 $ -->
<!-- $Author: gregory $ -->
<!-- EN-Revision: 1.38 Maintainer: verdana Status: ready -->
<!-- CREDITS: Gregory -->
 <chapter id="functions">
  <title>函数</title>

  <sect1 id="functions.user-defined">
   <title>用户自定义函数</title>
 
   <para>
    一个函数可由以下的语法来定义：
   </para>
   <para>
    <example>
     <title>展示函数用途的伪码</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo ($arg_1, $arg_2, ..., $arg_n)
{
    echo "Example function.\n";
    return $retval;
}
?>
]]>
     </programlisting>
    </example>
   </para>
   
   <!--
    
    status of func(const $param) ?
    zend doesn't care at all whether or not you specify it.
    I've never seen it before... what's its use? (or was...)
    
    -->
     
   <simpara>
    任何有效的 PHP 代码都有可能出现在函数内部，甚至包括其它函数和
    <link linkend="keyword.class">类</link> 定义。
   </simpara>
   <simpara>
    在 PHP 3 中，函数必须在被调用之前定义。而 PHP 4 则不再有这样的
    条件。<emphasis>除非</emphasis>函数如以下两个范例中有条件的定义。
   </simpara>
   <para>
    如果一个函数以以下两个范例的方式有条件的定义，其定义必须在调用<emphasis>之前</emphasis>完成。
   </para>
   <para>
    <example>
     <title>有条件的函数</title>
     <programlisting role="php">
<![CDATA[
<?php

$makefoo = true;

/* We can't call foo() from here 
   since it doesn't exist yet,
   but we can call bar() */

bar();

if ($makefoo) {
  function foo ()
  {
    echo "I don't exist until program execution reaches me.\n";
  }
}

/* Now we can safely call foo()
   since $makefoo evaluated to true */

if ($makefoo) foo();

function bar()
{
  echo "I exist immediately upon program start.\n";
}

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    <example>
     <title>函数中的函数</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo() 
{
  function bar() 
  {
    echo "I don't exist until foo() is called.\n";
  }
}

/* We can't call bar() yet
   since it doesn't exist. */

foo();

/* Now we can call bar(),
   foo()'s processesing has
   made it accessable. */

bar();

?>  
]]>
     </programlisting>
    </example>
   </para>
   <simpara>
    PHP 不支持函数重载，可能也不支持取消定义或者重定义已声明的函数。
   </simpara>
   <note> 
    <simpara> 
     函数名是非大小写敏感的，不过在调用函数的时候，通常使用其在定义时相同的形式。
    </simpara> 
   </note> 
   <simpara>
    PHP 3 虽然支持默认参数（更多的信息请参照
    <link linkend="functions.arguments.default">默认参数的值</link>）
    ，但是却不支持可变的参数个数。
    PHP 4 支持: 见 <link
    linkend="functions.variable-arg-list">可变长度的参数列表</link> 和涉及到的相关函数
    <function>func_num_args</function>，
    <function>func_get_arg</function>， 和
    <function>func_get_args</function> 以获取更多的信息。
   </simpara>

  </sect1>
 
  <sect1 id="functions.arguments">
   <title>函数的参数</title>
 
   <simpara>
    通过参数列表可以传递信息到函数，该列表是以逗号作为分隔符的变量和常量列表。
   </simpara> 
   <para>
     PHP 支持按值传递参数（默认）, 
     <link linkend="functions.arguments.by-reference">通过引用传递</link>, 和
     <link linkend="functions.arguments.default">默认参数值</link>. 
     可变长度参数列表仅在 PHP 4 和后续版本中支持；更多信息请参照 <link
     linkend="functions.variable-arg-list">可变长度参数列表</link> 
     和涉及到的相关函数 <function>func_num_args</function>，
     <function>func_get_arg</function>, 和
     <function>func_get_args</function>。
     PHP 3 中通过传递一个数组参数可以达到类似的效果：
    </para>
   <para>
    <example>
<![CDATA[
function takes_array($input)
{
    echo "$input[0] + $input[1] = ", $input[0]+$input[1];
}
]]>
     </programlisting>
    </example>
   </para>
 
   <sect2 id="functions.arguments.by-reference">
    <title>通过引用传递参数</title>
 
    <simpara>
     缺省情况下，函数参数通过值传递（因而即使在函数内部改变参数的值，它
     并不会改变函数外部的值）。如果你希望允许函数修改它的参数值，你必须
     通过引用传递参数。
    </simpara>
    <para>
     如果想要函数的一个参数总是通过引用传递，你可以在函数定义中该参数的
     前面预先加上符号（&）：
    </para>
    <para>
     <example>
      <title>用引用传递函数参数</title>
      <programlisting role="php">
<![CDATA[
<?php
function add_some_extra(&$string)
{
    $string .= 'and something extra.';
}
$str = 'This is a string, ';
add_some_extra($str);
echo $str;    // outputs 'This is a string, and something extra.'
?>
]]>
      </programlisting>
     </example>
    </para>
 
   </sect2>
 
   <sect2 id="functions.arguments.default">
    <title>默认参数的值</title>
 
    <para>
     函数可以定义 C++ 风格的标量参数默认值，如下：
    </para>
    <para>
     <example>
      <title>函数中默认参数的用途</title>
      <programlisting role="php">
<![CDATA[
<?php
function makecoffee ($type = "cappuccino")
{
    return "Making a cup of $type.\n";
}
echo makecoffee ();
echo makecoffee ("espresso");
?>
]]>
      </programlisting>
     </example>
    </para>
 
    <para>
     上述片断的输出是：
    </para>
    <para>
     <screen>
Making a cup of cappuccino.
Making a cup of espresso.
     </screen>
    </para>
 
    <simpara>
     默认值必须是标量，不是（比如）变量或者类成员。
    </simpara>
    <para>
     请注意当使用默认参数时，任何默认参数必须放在任何非默认参数的右侧；否则，
     可能函数将不会按照预期的情况工作。考虑下面的代码片断：
    </para>
    <para>
     <example>
      <title>函数默认参数不正确的用法</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt ($type = "acidophilus", $flavour)
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt ("raspberry");   // won't work as expected
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     上述例子的输出时：
    </para>
    <para>
     <screen>
Warning: Missing argument 2 in call to makeyogurt() in 
/usr/local/etc/httpd/htdocs/php3test/functest.html on line 41
Making a bowl of raspberry .
     </screen>
    </para>
    <para>
     现在，比较上面的例子和这个例子：
    </para>
    <para>
     <example>
      <title>函数默认参数正确的用法</title>
      <programlisting role="php">
<![CDATA[
<?php
function makeyogurt ($flavour, $type = "acidophilus")
{
    return "Making a bowl of $type $flavour.\n";
}
 
echo makeyogurt ("raspberry");   // works as expected
?>
]]>
      </programlisting>
     </example>
    </para>
    <para>
     这个例子的输出是：
    </para>
    <para>
     <screen>
Making a bowl of acidophilus raspberry.
     </screen>
    </para>

   </sect2>

   <sect2 id="functions.variable-arg-list">
    <title>可变长度参数列表</title>
	
    <simpara>
     PHP 4 已经在用户自定义函数中支持可变长度参数列表。这个真的很简单，
     使用 <function>func_num_args</function>，<function>func_get_arg</function>，和 
     <function>func_get_args</function> 函数.
    </simpara>

    <simpara>
     无需特别的语法，参数列表仍然能够被明确无误的传递给函数并且正常运转。
    </simpara>

   </sect2>

  </sect1>
 
  <sect1 id="functions.returning-values">
   <title>返回值</title>
 
   <para>
    值通过使用可选的返回语句返回。任何类型都可以返回，其中包括列表和对象。
    这导致函数立即结束它的运行，并且将控制权传递回它被调用的行。更多信息
    请参照 <function>return</function>。
   </para>
   <para>
    <example>
     <title><function>return</function> 函数的用法</title>
     <programlisting role="php">
<![CDATA[
<?php
function square ($num)
{
    return $num * $num;
}
echo square (4);   // outputs '16'.
?>
]]>
     </programlisting>
     </example>
   </para>
      
   <para>
    函数不能返回多个值，但为了获得简单的结果，可以返回一个列表。
   </para>
   <para>
    <example>
     <title>返回一个数组以得到多个返回值</title>
     <programlisting role="php">
<![CDATA[
<?php
function small_numbers()
{
    return array (0, 1, 2);
}
list ($zero, $one, $two) = small_numbers();
?>
]]>
     </programlisting>
     </example>
   </para>
   <para>
    从函数返回一个引用，你必须在函数声明和指派返回值给一个变量时都使用引用操作符 &amp; ：
   </para>
   <para>
    <example>
     <title>由函数返回一个引用</title>
     <programlisting role="php">
<![CDATA[
<?php
function &returns_reference()
{
    return $someref;
}

$newref =& returns_reference();
?>
]]>
     </programlisting>
     </example>
   </para>
   <simpara>
    有关引用的更多信息, 请查看 <link
    linkend="language.references">引用的解释</link>.
   </simpara>
  </sect1>
 
  <sect1 id="functions.variable-functions">
   <title>变量函数</title>

   <para>
    PHP 支持变量函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找
    与变量的值相同的函数，并且将尝试执行它。除了别的事情以外，这个可以被
    用于实现回调函数，函数表等等。
    </para>
   <para>
    变量函数不能用于语言结构，例如 <function>echo</function>、<function>print</function>、<function>unset</function>、<function>isset</function>、<function>empty</function>、<function>include</function>、<function>require</function> 以及类似的语句。您需要使用您自己的外壳函数来将这些结构用作变量函数。
   </para>
   <para>
    <example>
     <title>变量函数示例</title>
     <programlisting role="php">
<![CDATA[
<?php
function foo()
{
    echo "In foo()<br>\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br>\n";
}

// This is a wrapper function around echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // This calls foo()

$func = 'bar';
$func('test');  // This calls bar()

$func = 'echoit';
$func('test');  // This calls echoit()
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    您还可以利用变量函数的特性来调用一个对象的方法。
    <example>
     <title>变量方法范例</title>
     <programlisting role="php">
<![CDATA[
<?php
class Foo
{
    function Var()
    {
        $name = 'Bar';
        $this->$name(); // This calls the Bar() method
    }
    
    function Bar()
    {
        echo "This is Bar";
    }
}

$foo = new Foo();
$funcname = "Var";
$foo->$funcname();   // This calls $foo->Var()

?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    请参阅 <function>call_user_func</function>、<link linkend="language.variables.variable">变量变量</link> 和 <function>function_exists</function>。
   </para>

  </sect1>

<sect1 id="functions.internal"> 
     <title>内部（内建）函数</title> 
    
     <para> 
      PHP 有很多标准的函数和结构。还有一些函数需要和特定地 PHP 扩展模块一起编译，否则在使用它们的时候就会得到一个致命的“未定义函数”错误。例如，要使用诸如 <function>imagecreatetruecolor</function> 的“<link linkend="ref.image">图像</link>函数”，您需要在编译 PHP 的时候加上 GD 的支持。或者，要使用 <function>mysql_connect</function> 函数，您就需要在编译 PHP 的时候加上 <link linkend="ref.mysql">MySQL</link> 支持。另外还有一些核心函数，例如“<link linkend="ref.strings">字符串函数</link>”和“<link linkend="ref.variables">变量函数</link>”，它们存在于每一个版本的 PHP 中。调用 <function>phpinfo</function> 或者 <function>get_loaded_extensions</function> 可以得知 PHP 加载了那些扩展库。同时还应该注意，很多扩展库默认就是有效的。PHP 手册按照不同的扩展库组织了它们的文档。请参阅“<link linkend="configuration">配置</link>”、“<link linkend="installation">安装</link>”以及独立的扩展库章节以获取有关如何设置 PHP 的信息。
     </para> 
     <para> 
      手册中“<link linkend="about.prototypes">如何阅读函数原型</link>”讲解了如何阅读和理解一个函数的原型。确认一个函数将返回什么，或者函数是否直接作用于传递的参数是很重要得。例如，<function>str_replace</function> 函数将返回修改过的字符串，而 <function>usort</function> 却直接作用于传递的参数变量本身。手册中，每一个函数的页面中都有关于函数参数、行为改变、成功与否的返回值以及使用条件等信息。了解这些重要的（常常是细微的）差别是编写正确的 PHP 代码的关键。
     </para> 
     <para> 
      请参阅函数 <function>function_exists</function>、<link linkend="funcref">函数的引用</link>、<function>get_extension_funcs</function> 和 <function>dl</function>。
     </para> 
    </sect1> 
 
 </chapter>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
