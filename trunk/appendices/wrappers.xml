<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.10 $ -->
<!-- $Author: dallas $ -->
<!-- EN-Revision:1.11 Maintainer: dallas Status: ready -->
<appendix id="wrappers">
 <title>支持的协议／封装协议列表</title>
 <para>
  以下是 PHP 内置用于文件系统函数例如
  <function>fopen</function> 和 <function>copy</function>
  的 URL 风格协议列表。除了这些封装协议之外，从
  PHP 4.3 起，你还可以用 PHP 脚本和
  <function>stream_register_wrapper</function>
  写自己的封装协议。
 </para>

 <section id="wrappers.http">
  <title>HTTP 和 HTTPS</title>
  <simpara>PHP 3，PHP 4。自 PHP 4.3 起支持 <filename>https://</filename></simpara>

  <itemizedlist>
   <listitem><simpara><filename>http://example.com</filename></simpara></listitem>
   <listitem><simpara><filename>http://user:password@example.com</filename></simpara></listitem>
   <listitem><simpara><filename>https://example.com</filename></simpara></listitem>
   <listitem><simpara><filename>https://user:password@example.com</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   允许通过 HTTP 1.0 使用 HTTP GET 方法对文件／资源进行只读访问。<literal>Host:</literal>
   报头也会通过请求发送出去以支持基于域名的虚拟主机。如果你在 ini
   文件或者流上下文配置了 <link linkend="ini.user-agent">user_agent</link>
   字符串，也会被包括在请求报头中。
  </simpara>
  <simpara>
   自 PHP 4.0.5 起支持重定向。如果使用较早版本的 PHP 则需要在 URL 末尾包括一个斜线。
  </simpara>
  <simpara>
   流允许访问资源的<emphasis>正文</emphasis>，报头部分保存在
   <varname>$http_response_header</varname> 变量中。自
   PHP 4.3 起，可以用
   <function>stream_get_meta_data</function> 得到报头。
  </simpara>
  <simpara>
   HTTP 连接是只读的，不能将数据写入或者拷贝文件到 HTTP 资源。
  </simpara>
  <note>
   <simpara>
    自 PHP 4.3 起开始支持 HTTPS，需要在编译时加入 OpenSSL 的支持。
   </simpara>
  </note>
 </section>

 <section id="wrappers.ftp">
  <title>FTP 和 FTPS</title>
  <simpara>PHP 3，PHP 4。自 PHP 4.3 起支持 <filename>ftps://</filename></simpara>

  <itemizedlist>
   <listitem><simpara><filename>ftp://example.com/pub/file.txt</filename></simpara></listitem>
   <listitem><simpara><filename>ftp://user:password@example.com/pub/file.txt</filename></simpara></listitem>
   <listitem><simpara><filename>ftps://example.com/pub/file.txt</filename></simpara></listitem>
   <listitem><simpara><filename>ftps://user:password@example.com/pub/file.txt</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   允许对已有文件进行只读访问以及通过 FTP 建立新文件。如果服务器不支持被动模式的
   ftp，则连接会失败。
  </simpara>
  <simpara>
   可以用读或者写的方式打开文件，但不能同时是读写。如果 ftp
   服务器上已经存在远程文件而你试图用写的方式打开，则连接会失败。如果你想通过
   ftp 更新已有的文件，用 <function>ftp_connect</function>。
  </simpara>
  <simpara>
   <filename>ftps://</filename> 是 PHP 4.3 引进的。它和 <filename>ftp://</filename> 相同，但是尝试和
   ftp 服务器建立一个安全连接。如果服务器不支持 SSL，则会返回一个普通的未加密的
   ftp 连接。
  </simpara>
  <note>
   <simpara>
    自 PHP 4.3 起开始支持 FTPS，需要在编译时加入 OpenSSL 的支持。
   </simpara>
  </note>

 </section>

 <section id="wrappers.php">
  <title>PHP 输入／输出流</title>
  <simpara>
   <literal>PHP 3.0.13</literal> 及以上版本，自
   <literal>PHP 4.3</literal> 起支持 <filename>php://output</filename>
   和 <filename>php://input</filename>，自
   <literal>PHP 5.0</literal> 起支持 <filename>php://filter</filename>。
  </simpara>

  <itemizedlist>
   <listitem><simpara><filename>php://stdin</filename></simpara></listitem>
   <listitem><simpara><filename>php://stdout</filename></simpara></listitem>
   <listitem><simpara><filename>php://stderr</filename></simpara></listitem>
   <listitem><simpara><filename>php://output</filename></simpara></listitem>
   <listitem><simpara><filename>php://input</filename></simpara></listitem>
   <listitem><simpara><filename>php://filter</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   <filename>php://stdin</filename>，<filename>php://stdout</filename> 和 <filename>php://stderr</filename> 允许访问
   PHP 进程相应的输入或者输出流。
  </simpara>
  <simpara>
   <filename>php://output</filename> 允许向输出缓冲机制写入数据，和
   <function>print</function> 与 <function>echo</function> 的方式相同。
  </simpara>
  <simpara>
   <filename>php://input</filename> 允许您读取 POST 的原始数据。
   和 <varname>$HTTP_RAW_POST_DATA</varname> 比起来，它给内存带来的压力较小，并且不需要任何特殊的 &php.ini; 设置。
  </simpara>
  <simpara>
   <filename>php://stdin</filename> 和
   <filename>php://input</filename> 是只读的，同时，<filename>php://stdout</filename>，<filename>php://stderr</filename> 和
   <filename>php://output</filename> 是只写的。
  </simpara>

  <simpara> 
   <filename>php://filter</filename>
   是一种设计用来允许过滤器程序在打开时成为流的封装协议。这对于单独具有完整功能的文件函数例如
   <function>readfile</function>，<function>file</function>
   和 <function>file_get_contents</function> 很有用，否则就没有机会在读取内容之前将过滤器应用于流之上。
  </simpara> 
  <simpara> 
   <filename>php://filter</filename> 的目标接受随后的&apos;参数&apos;作为其&apos;路径&apos;的一部分。
  </simpara> 
  <itemizedlist> 
   <listitem> 
    <para> 
    <literal>/resource=&lt;stream to be filtered&gt;</literal> 
     (<emphasis>required</emphasis>)  此参数必须位于
     <filename>php://filter</filename> 的末尾并且需要指向向要过滤的流。
     <informalexample> 
      <programlisting role="php"> 
<![CDATA[ 
<?php 
/* This is equivalent to simply: 
   readfile("http://www.example.com"); 
   since no filters are actually specified */ 
  
readfile("php://filter/resource=http://www.example.com"); 
?> 
]]> 
      </programlisting> 
     </informalexample> 
    </para> 
   </listitem> 
   <listitem> 
    <para> 
     <literal>/read=&lt;filter list to apply to read chain&gt;</literal> 
     (<emphasis>optional</emphasis>)  本参数接受一个或多个过滤器的名字，用管道字符 <literal>|</literal> 分隔。
     <informalexample> 
      <programlisting role="php"> 
<![CDATA[ 
<?php 
/* This will output the contents of 
   www.example.com entirely in uppercase */ 
readfile("php://filter/read=string.toupper/resource=http://www.example.com"); 
  
/* This will do the same as above 
   but will also ROT13 encode it */ 
readfile("php://filter/read=string.toupper|string.rot13/resource=http://www.example.com"); 
?> 
]]> 
      </programlisting> 
     </informalexample> 
    </para> 
   </listitem> 
   <listitem> 
    <para> 
     <literal>/write=&lt;filter list to apply to write chain&gt;</literal> 
     (<emphasis>optional</emphasis>)  本参数接受一个或多个过滤器的名字，用管道字符 <literal>|</literal> 分隔。
     <informalexample> 
      <programlisting role="php"> 
<![CDATA[ 
<?php 
/* This will filter the string "Hello World" 
   through the rot13 filter, then write to 
   example.txt in the current directory */ 
file_set_contents("php://filter/write=string.rot13/resource=example.txt","Hello World"); 
?> 
]]> 
      </programlisting> 
     </informalexample> 
    </para> 
   </listitem> 
   <listitem> 
    <simpara> 
     <literal>/&lt;filter list to apply to both chains&gt;</literal> 
     (<emphasis>optional</emphasis>)  任何没有被
     <literal>read=</literal> 或
     <literal>write=</literal> 指定的过滤器会被同时应用于读写链。
    </simpara> 
   </listitem> 
  </itemizedlist> 

 </section>

 <section id="wrappers.compression">
  <title>压缩流</title>
  <simpara><filename>zlib:</filename> PHP 4.0.4 - PHP 4.2.3（仅用于带 fopencookie 的系统）</simpara>
  <simpara>PHP 4.3 及以上版本支持 <filename>compress.zlib://</filename> 和 <filename>compress.bzip2://</filename></simpara>

  <itemizedlist>
   <listitem><simpara><filename>zlib:</filename></simpara></listitem>
   <listitem><simpara><filename>compress.zlib://</filename></simpara></listitem>
   <listitem><simpara><filename>compress.bzip2://</filename></simpara></listitem>
  </itemizedlist>

  <simpara>
   <filename>zlib:</filename> 和 <function>gzopen</function> 的工作方式相象，只除了流可以用于
   <function>fread</function> 和其它文件系统函数。自 PHP 4.3
   起已不赞成使用，因为可能会和包含有“:”字符的文件名混淆，用 <filename>compress.zlib://</filename> 代替。
  </simpara>

  <simpara>
   <filename>compress.zlib://</filename> 和 <filename>compress.bzip2://</filename> 各自等同于
   <function>gzopen</function> 和 <function>bzopen</function>，并且可以在不支持
   fopencookie 的系统中使用。
  </simpara>
 </section>
</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
