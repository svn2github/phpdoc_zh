<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.1 $ -->
<!-- $Author: dallas $ -->
<!-- EN-Revision:1.14 Maintainer: dallas Status: partial -->

<appendix id="filters">
 <title>可用过滤器列表</title>
 <para>
  下面列出了用在 <function>stream_filter_append</function>
  中的几个内置的流过滤器。用户的 PHP 版本中的过滤器也许比这里列出的更多（或更少）。
 </para>

 <para>
  值得指出 <function>stream_filter_append</function>
  与 <function>stream_filter_prepend</function>
  之间有少许不平衡。每个 PHP
  流都含有一个小的<emphasis>读取缓冲区</emphasis>，它存储了来自文件系统或其它资源的几段数据以便更有效率地处理。数据一从资源进入流的内部缓冲区，立刻被附上的过滤器处理而不管
  PHP 程序是否真的已经准备好接收数据。当过滤器是
  <emphasis>appended</emphasis>
  时如果数据等待在读取缓冲区，数据将被立即通过过滤器处理，使其效果看上去是透明的。然而当过滤器是
  <emphasis>prepended</emphasis>
  时如果数据等待在读取缓冲区，数据将<emphasis>不会</emphasis>被该过滤器处理。该数据将会等到从资源取得下一段数据后才会被处理。
 </para>

 <para>
  用 <function>stream_get_filters</function> 来列出 PHP 中已安装的过滤器。
 </para>

 <section id="filters.string">
  <title>字符串过滤器</title>

  <simpara>
   每个过滤器都正如其名字暗示的那样工作并与内置的
   PHP 字符串函数的行为相对应。对于指定过滤器的更多信息，请参考该函数的手册页。
  </simpara>

  <simpara>
   <literal>string.rot13</literal>（自
   PHP 4.3.0 起）使用此过滤器等同于用
   <function>str_rot13</function> 函数处理所有的流数据。
  </simpara>
  <example>
   <title>string.rot13</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.rot13');
fwrite($fp, "This is a test.\n");
/* Outputs:  Guvf vf n grfg.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.toupper</literal>（自
   PHP 5.0.0 起）使用此过滤器等同于用
   <function>strtoupper</function> 函数处理所有的流数据。
  </simpara>
  <example>
   <title>string.toupper</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.toupper');
fwrite($fp, "This is a test.\n");
/* Outputs:  THIS IS A TEST.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.tolower</literal>（自
   PHP 5.0.0 起）使用此过滤器等同于用
   <function>strtolower</function> 函数处理所有的流数据。
  </simpara>
  <example>
   <title>string.tolower</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.tolower');
fwrite($fp, "This is a test.\n");
/* Outputs:  this is a test.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.strip_tags</literal>（自
   PHP 5.0.0 起）使用此过滤器等同于用
   <function>strip_tags</function>
   函数处理所有的流数据。可以用两种格式接收参数：一种是和
   <function>strip_tags</function>
   函数第二个参数相似的一个包含有标记列表的字符串，一种是一个包含有标记名的数组。
  </simpara>
  <example>
   <title>string.strip_tags</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, "<b><i><u>");
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, array('b','i','u'));
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */
?>
]]>
   </programlisting>
  </example>

 </section>

 <section id="filters.convert">
  <title>转换过滤器</title>

  <simpara>
   如同 string.* 过滤器，convert.* 过滤器的作用就和其名字一样。转换过滤器是
   PHP 5.0.0 添加的。对于指定过滤器的更多信息，请参考该函数的手册页。
  </simpara>

  <simpara>
   <literal>convert.base64-encode</literal> 和
   <literal>convert.base64-decode</literal>
   使用这两个过滤器等同于分别用
   <function>base64_encode</function> 和
   <function>base64_decode</function>
   函数处理所有的流数据。<literal>convert.base64-encode</literal>
   支持以一个关联数组给出的参数。如果给出了
   <parameter>line-length</parameter>，base64 输出将被用
   <parameter>line-length</parameter> 个字符为
   长度而截成块。如果给出了
   <parameter>line-break-chars</parameter>，每块将被用给出的字符隔开。这些参数的效果和用
   <function>base64_encode</function> 再加上
   <function>chunk_split</function> 相同。
  </simpara>
  <example>
   <title>
    convert.base64-encode &amp;
    convert.base64-decode
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode');
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBpcyBhIHRlc3QuCg==  */

$param = array('line-length' => 8, 'line-break-chars' => "\r\n");
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode', STREAM_FILTER_WRITE, $param);
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBp
          :  cyBhIHRl
          :  c3QuCg==  */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-decode');
fwrite($fp, "VGhpcyBpcyBhIHRlc3QuCg==");
fclose($fp);
/* Outputs:  This is a test.  */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>convert.quoted-printable-encode</literal> 和
   <literal>convert.quoted-printable-decode</literal>
   使用此过滤器的 decode 版本等同于用
   <function>quoted_printable_decode</function>
   函数处理所有的流数据。没有和
   <literal>convert.quoted-printable-encode</literal>
   相对应的函数。<literal>convert.quoted-printable-encode</literal>
   支持以一个关联数组给出的参数。除了支持和
   <literal>convert.base64-encode</literal>
   一样的附加参数外，<literal>convert.quoted-printable-encode</literal>
   还支持布尔参数 <parameter>binary</parameter> 和
   <parameter>force-encode-first</parameter>。<literal>convert.base64-decode</literal>
   只支持
   <parameter>line-break-chars</parameter>
   参数作为从编码载荷中剥离的类型提示。
  </simpara>
  <example>
   <title>
    convert.quoted-printable-encode &amp;
    convert.quoted-printable-decode
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.quoted-printable-encode');
fwrite($fp, "This is a test.\n");
/* Outputs:  =This is a test.=0A  */
?>
]]>
   </programlisting>
  </example>
 </section>

 <section id="filters.compression">
  <title>压缩过滤器</title>

  <simpara>
   While the <link linkend="wrappers.compression">Compression Wrappers</link>
   provide a way of creating
   gzip and bz2 compatible files on the local filesystem, they do not provide a
   means for generalized compression over network streams, nor do they provide a
   means to begin with a non-compressed stream and transition to a compressed one.
   For this, a compression filter may be applied to any stream resource at any time.
  </simpara>

  <note>
   <simpara>
    Compression filters do <emphasis>not</emphasis> generate headers and trailers
    used by commandline utilites such as <literal>gzip</literal>.  They only compress
    and decompress the payload portions of compressed data streams.
   </simpara>
  </note>

  <simpara>
   <literal>zlib.deflate</literal> (compression) and
   <literal>zlib.inflate</literal> (decompression) are implementations of
   the compression methods described in <ulink url="&url.rfc;1951">RFC 1951</ulink>.
   The <literal>deflate</literal> filter takes up to three parameters passed as
   an associative array.

   <parameter>level</parameter> describes the compression
   strength to use (1-9).  Higher numbers will generally yield smaller payloads at
   the cost of additional processing time.  Two special compression levels also exist:
   0 (for no compression at all), and -1 (zlib internal default -- currently 6).

   <parameter>window</parameter> is the base-2 log of the compression loopback window size.
   Higher values (up to 15 -- 32768 bytes) yield better compression at a cost of memory,
   while lower values (down to 9 -- 512 bytes) yield worse compression in a smaller memory footprint.
   Default <parameter>window</parameter> size is currently <constant>15</constant>.

   <parameter>memory</parameter> is a scale indicating how much work memory should be allocated.
   Valid values range from 1 (minimal allocation) to 9 (maximum allocation).  This memory allocation
   affects speed only and does not impact the size of the generated payload.
  </simpara>

  <note>
   <simpara>
    Because compression level is the most commonly used parameter, it may be alternatively
    provided as a simple integer value (rather than an array element).
   </simpara>
  </note>

  <simpara>
    zlib.* compression filters are available with PHP as of version <literal>5.1.0</literal> if
    <link linkend="ref.zlib">zlib</link> support is enabled.  They are also available as a backport in version
    <literal>5.0.x</literal> by installing the <ulink url="&url.pecl.package;zlib_filter">zlib_filter</ulink>
    package from <ulink url="&url.pecl;">PECL</ulink>.  These filters are <emphasis>not</emphasis>
    available for PHP 4.
  </simpara>

  <example>
   <title>
    <literal>zlib.deflate</literal> and
    <literal>zlib.inflate</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$params = array('level' => 6, 'window' => 15, 'memory' => 9);

$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, $params);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";
echo "The original text was:\n";
/* Use readfile and zlib.inflate to decompress on the fly */
readfile('php://filter/zlib.inflate/resource=test.deflated');

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.
The original text was:
This is a test.
This is only a test.
This is not an important string.

 */
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>
    <literal>zlib.deflate</literal> simple
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
/* Here "6" indicates compression level 6 */
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, 6);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.

 */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>bzip2.compress</literal> and
   <literal>bzip2.decompress</literal>
   work in the same manner as the zlib filters described above.

   The <literal>bzip2.compress</literal> filter accepts up to two parameters given as
   elements of an associative array:

   <parameter>blocks</parameter> is an integer value
   from 1 to 9 specifying the number of 100kbyte blocks of memory to allocate for
   workspace.

   <parameter>work</parameter> is also an integer value ranging from
   0 to 250 indicating how much effort to expend using the normal compression method
   before falling back on a slower, but more reliable method.  Tuning this parameter
   effects only compression speed.  Neither size of compressed output nor memory usage
   are changed by this setting.  A work factor of 0 instructs the bzip library to use
   an internal default.

   The <literal>bzip2.decompress</literal> filter only accepts one parameter,
   which can be passed as either an ordinary boolean value, or as the
   <parameter>small</parameter> element of an associative array.

   <parameter>small</parameter>, when set to a &true; value, instructs the bzip library
   to perform decompression in a minimal memory footprint at the cost of speed.
  </simpara>

  <simpara>
    bzip2.* compression filters are available with PHP as of version <literal>5.1.0</literal> if
    <link linkend="ref.bzip2">bz2</link> support is enabled.  They are also available as a backport in version
    <literal>5.0.x</literal> by installing the <ulink url="&url.pecl.package;bz2_filter">bz2_filter</ulink>
    package from <ulink url="&url.pecl;">PECL</ulink>.  These filters are <emphasis>not</emphasis>
    available for PHP 4.
  </simpara>

  <example>
   <title>
    <literal>bzip2.compress</literal> and
    <literal>bzip2.decompress</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$param = array('blocks' => 9, 'work' => 0);

echo "The original file is " . filesize('LICENSE') . " bytes long.\n";

$fp = fopen('LICENSE.compressed', 'w');
stream_filter_append($fp, 'bzip2.compress', STREAM_FILTER_WRITE, $param);
fwrite($fp, file_get_contents('LICENSE'));
fclose($fp);

echo "The compressed file is " . filesize('LICENSE.compressed') . " bytes long.\n";

/* Generates output:

The original text is 3288 characters long.
The compressed file is 1488 bytes long.

 */
?>
]]>
   </programlisting>
  </example>
 </section>

 <section id="filters.encryption">
  <title>Encryption Filters</title>

  <simpara>
   <literal>mcrypt.*</literal> and <literal>mdecrypt.*</literal>
   provide symmetric encryption and decryption using libmcrypt.
   Both sets of filters support the same algorithms available to
   <link linkend="ref.mcrypt">mcrypt extension</link> in the form of
   <literal>mcrypt.ciphername</literal> where <parameter>ciphername</parameter>
   is the name of the cipher as it would be passed to
   <function>mcrypt_module_open</function>.
   The following five filter parameters are also available:
  </simpara>

  <para>
   <table>
    <title>mcrypt filter parameters</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>Parameter</entry>
       <entry>Required?</entry>
       <entry>Default</entry>
       <entry>Sample Values</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>mode</entry>
       <entry>Optional</entry>
       <entry>cbc</entry>
       <entry>cbc, cfb, ecb, nofb, ofb, stream</entry>
      </row>
      <row>
       <entry>algorithms_dir</entry>
       <entry>Optional</entry>
       <entry>ini_get('mcrypt.algorithms_dir')</entry>
       <entry>Location of algorithms modules</entry>
      </row>
      <row>
       <entry>modes_dir</entry>
       <entry>Optional</entry>
       <entry>ini_get('mcrypt.modes_dir')</entry>
       <entry>Location of modes modules</entry>
      </row>
      <row>
       <entry>iv</entry>
       <entry>Required</entry>
       <entry>N/A</entry>
       <entry>Typically 8, 16, or 32 bytes of binary data.  Depends on cipher</entry>
      </row>
      <row>
       <entry>key</entry>
       <entry>Required</entry>
       <entry>N/A</entry>
       <entry>Typically 8, 16, or 32 bytes of binary data.  Depends on cipher</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <example>
   <title>Encrypting file output using 3DES</title>
   <programlisting role="php">
<![CDATA[
<?php
$passphrase = 'My secret';

/* Turn a human readable passphrase
 * into a reproducable iv/key pair
 */
$iv = substr(md5('iv'.$passphrase, true), 0, 8);
$key = substr(md5('pass1'.$passphrase, true) .
               md5('pass2'.$passphrase, true), 0, 24);
$opts = array('iv'=>$iv, 'key'=>$key);

$fp = fopen('secert-file.enc', 'wb');
stream_filter_append($fp, 'mcrypt.tripledes', STREAM_FILTER_WRITE, $opts);
fwrite($fp, 'Secret secret secret data');
fclose($fp);
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>Reading an encrypted file</title>
   <programlisting role="php">
<![CDATA[
<?php
$passphrase = 'My secret';

/* Turn a human readable passphrase
 * into a reproducable iv/key pair
 */
$iv = substr(md5('iv'.$passphrase, true), 0, 8);
$key = substr(md5('pass1'.$passphrase, true) .
               md5('pass2'.$passphrase, true), 0, 24);
$opts = array('iv'=>$iv, 'key'=>$key);

$fp = fopen('secert-file.enc', 'rb');
stream_filter_append($fp, 'mdecrypt.tripledes', STREAM_FILTER_WRITE, $opts);
$data = rtrim(stream_get_contents($fp));
fclose($fp);

echo $data;
?>
]]>
   </programlisting>
  </example>

 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
