<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.2 $ -->
<!-- $Author: dallas $ -->
<!-- EN-Revision:1.14 Maintainer: dallas Status: ready -->

<appendix id="filters">
 <title>可用过滤器列表</title>
 <para>
  下面列出了用在 <function>stream_filter_append</function>
  中的几个内置的流过滤器。用户的 PHP 版本中的过滤器也许比这里列出的更多（或更少）。
 </para>

 <para>
  值得指出 <function>stream_filter_append</function>
  与 <function>stream_filter_prepend</function>
  之间有少许不平衡。每个 PHP
  流都含有一个小的<emphasis>读取缓冲区</emphasis>，它存储了来自文件系统或其它资源的几段数据以便更有效率地处理。数据一从资源进入流的内部缓冲区，立刻被附上的过滤器处理而不管
  PHP 程序是否真的已经准备好接收数据。当过滤器是
  <emphasis>appended</emphasis>
  时如果数据等待在读取缓冲区，数据将被立即通过过滤器处理，使其效果看上去是透明的。然而当过滤器是
  <emphasis>prepended</emphasis>
  时如果数据等待在读取缓冲区，数据将<emphasis>不会</emphasis>被该过滤器处理。该数据将会等到从资源取得下一段数据后才会被处理。
 </para>

 <para>
  用 <function>stream_get_filters</function> 来列出 PHP 中已安装的过滤器。
 </para>

 <section id="filters.string">
  <title>字符串过滤器</title>

  <simpara>
   每个过滤器都正如其名字暗示的那样工作并与内置的
   PHP 字符串函数的行为相对应。对于指定过滤器的更多信息，请参考该函数的手册页。
  </simpara>

  <simpara>
   <literal>string.rot13</literal>（自
   PHP 4.3.0 起）使用此过滤器等同于用
   <function>str_rot13</function> 函数处理所有的流数据。
  </simpara>
  <example>
   <title>string.rot13</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.rot13');
fwrite($fp, "This is a test.\n");
/* Outputs:  Guvf vf n grfg.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.toupper</literal>（自
   PHP 5.0.0 起）使用此过滤器等同于用
   <function>strtoupper</function> 函数处理所有的流数据。
  </simpara>
  <example>
   <title>string.toupper</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.toupper');
fwrite($fp, "This is a test.\n");
/* Outputs:  THIS IS A TEST.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.tolower</literal>（自
   PHP 5.0.0 起）使用此过滤器等同于用
   <function>strtolower</function> 函数处理所有的流数据。
  </simpara>
  <example>
   <title>string.tolower</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.tolower');
fwrite($fp, "This is a test.\n");
/* Outputs:  this is a test.   */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>string.strip_tags</literal>（自
   PHP 5.0.0 起）使用此过滤器等同于用
   <function>strip_tags</function>
   函数处理所有的流数据。可以用两种格式接收参数：一种是和
   <function>strip_tags</function>
   函数第二个参数相似的一个包含有标记列表的字符串，一种是一个包含有标记名的数组。
  </simpara>
  <example>
   <title>string.strip_tags</title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, "<b><i><u>");
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'string.strip_tags', STREAM_FILTER_WRITE, array('b','i','u'));
fwrite($fp, "<b>bolded text</b> enlarged to a <h1>level 1 heading</h1>\n");
fclose($fp);
/* Outputs:  <b>bolded text</b> enlarged to a level 1 heading   */
?>
]]>
   </programlisting>
  </example>

 </section>

 <section id="filters.convert">
  <title>转换过滤器</title>

  <simpara>
   如同 string.* 过滤器，convert.* 过滤器的作用就和其名字一样。转换过滤器是
   PHP 5.0.0 添加的。对于指定过滤器的更多信息，请参考该函数的手册页。
  </simpara>

  <simpara>
   <literal>convert.base64-encode</literal> 和
   <literal>convert.base64-decode</literal>
   使用这两个过滤器等同于分别用
   <function>base64_encode</function> 和
   <function>base64_decode</function>
   函数处理所有的流数据。<literal>convert.base64-encode</literal>
   支持以一个关联数组给出的参数。如果给出了
   <parameter>line-length</parameter>，base64 输出将被用
   <parameter>line-length</parameter> 个字符为
   长度而截成块。如果给出了
   <parameter>line-break-chars</parameter>，每块将被用给出的字符隔开。这些参数的效果和用
   <function>base64_encode</function> 再加上
   <function>chunk_split</function> 相同。
  </simpara>
  <example>
   <title>
    convert.base64-encode &amp;
    convert.base64-decode
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode');
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBpcyBhIHRlc3QuCg==  */

$param = array('line-length' => 8, 'line-break-chars' => "\r\n");
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-encode', STREAM_FILTER_WRITE, $param);
fwrite($fp, "This is a test.\n");
fclose($fp);
/* Outputs:  VGhpcyBp
          :  cyBhIHRl
          :  c3QuCg==  */

$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.base64-decode');
fwrite($fp, "VGhpcyBpcyBhIHRlc3QuCg==");
fclose($fp);
/* Outputs:  This is a test.  */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>convert.quoted-printable-encode</literal> 和
   <literal>convert.quoted-printable-decode</literal>
   使用此过滤器的 decode 版本等同于用
   <function>quoted_printable_decode</function>
   函数处理所有的流数据。没有和
   <literal>convert.quoted-printable-encode</literal>
   相对应的函数。<literal>convert.quoted-printable-encode</literal>
   支持以一个关联数组给出的参数。除了支持和
   <literal>convert.base64-encode</literal>
   一样的附加参数外，<literal>convert.quoted-printable-encode</literal>
   还支持布尔参数 <parameter>binary</parameter> 和
   <parameter>force-encode-first</parameter>。<literal>convert.base64-decode</literal>
   只支持
   <parameter>line-break-chars</parameter>
   参数作为从编码载荷中剥离的类型提示。
  </simpara>
  <example>
   <title>
    convert.quoted-printable-encode &amp;
    convert.quoted-printable-decode
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$fp = fopen('php://output', 'w');
stream_filter_append($fp, 'convert.quoted-printable-encode');
fwrite($fp, "This is a test.\n");
/* Outputs:  =This is a test.=0A  */
?>
]]>
   </programlisting>
  </example>
 </section>

 <section id="filters.compression">
  <title>压缩过滤器</title>

  <simpara>
   虽然<link linkend="wrappers.compression">压缩封装协议</link>提供了在本地文件系统中
   创建 gzip 和 bz2
   兼容文件的方法，但不代表可以在网络的流中提供通用压缩的意思，也不代表可以将一个非压缩的流转换成一个压缩流。对此，压缩过滤器可以在任何时候应用于任何流资源。
  </simpara>

  <note>
   <simpara>
    压缩过滤器<emphasis>不</emphasis>产生命令行工具如
    <literal>gzip</literal> 的头和尾信息。只是压缩和解压数据流中的有效载荷部分。
   </simpara>
  </note>

  <simpara>
   <literal>zlib.deflate</literal>（压缩）和
   <literal>zlib.inflate</literal>（解压）实现了定义与
   <ulink url="&url.rfc;1951">RFC 1951</ulink>
   的压缩算法。<literal>deflate</literal>
   过滤器可以接受以一个关联数组传递的最多三个参数。<parameter>level</parameter>
   定义了压缩强度（1-9）。数字更高通常会产生更小的载荷，但要消耗更多的处理时间。存在两个特殊压缩等级：0（完全不压缩）和
   -1（zlib 内部默认值，目前是 6）。<parameter>window</parameter>
   是压缩回溯窗口大小，以二的次方表示。更高的值（大到 15 ―― 32768
   字节）产生更好的压缩效果但消耗更多内存，低的值（低到 9 ―― 512
   字节）产生产生较差的压缩效果但内存消耗低。目前默认的
   <parameter>window</parameter> 大小是 <constant>15</constant>。<parameter>memory</parameter>
   用来指示要分配多少工作内存。合法的数值范围是从 1（最小分配）到
   9（最大分配）。内存分配仅影响速度，不会影响生成的载荷的大小。
  </simpara>

  <note>
   <simpara>
    因为最常用的参数是压缩等级，也可以提供一个整数值作为此参数（而不用数组）。
   </simpara>
  </note>

  <simpara>
    zlib.* 压缩过滤器自 PHP 版本 <literal>5.1.0</literal> 起可用，在激活
    <link linkend="ref.zlib">zlib</link> 的前提下。也可以通过安装来自
    <ulink url="&url.pecl;">PECL</ulink> 的 <ulink
    url="&url.pecl.package;zlib_filter">zlib_filter</ulink> 包作为一个后门在
    <literal>5.0.x</literal> 版中使用。此过滤器在 PHP 4 中<emphasis>不可用</emphasis>。
  </simpara>

  <example>
   <title>
    <literal>zlib.deflate</literal> 和
    <literal>zlib.inflate</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$params = array('level' => 6, 'window' => 15, 'memory' => 9);

$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, $params);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";
echo "The original text was:\n";
/* Use readfile and zlib.inflate to decompress on the fly */
readfile('php://filter/zlib.inflate/resource=test.deflated');

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.
The original text was:
This is a test.
This is only a test.
This is not an important string.

 */
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>
    <literal>zlib.deflate</literal> 简单参数用法
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$original_text = "This is a test.\nThis is only a test.\nThis is not an important string.\n";
echo "The original text is " . strlen($original_text) . " characters long.\n";

$fp = fopen('test.deflated', 'w');
/* Here "6" indicates compression level 6 */
stream_filter_append($fp, 'zlib.deflate', STREAM_FILTER_WRITE, 6);
fwrite($fp, $original_text);
fclose($fp);

echo "The compressed file is " . filesize('test.deflated') . " bytes long.\n";

/* Generates output:

The original text is 70 characters long.
The compressed file is 56 bytes long.

 */
?>
]]>
   </programlisting>
  </example>

  <simpara>
   <literal>bzip2.compress</literal> 和
   <literal>bzip2.decompress</literal> 工作的方式与上面讲的 zlib
   过滤器相同。<literal>bzip2.compress</literal>
   过滤器接受以一个关联数组给出的最多两个参数：<parameter>blocks</parameter>
   是从 1 到 9 的整数值，指定分配多少个 100K
   字节的内存块作为工作区。<parameter>work</parameter> 是 0 到 250
   的整数值，指定在退回到一个慢一些，但更可靠的算法之前做多少次常规压缩算法的尝试。调整此参数仅影响到速度，压缩输出和内存使用都不受此设置的影响。将此参数设为
   0 指示 bzip 库使用内部默认算法。<literal>bzip2.decompress</literal>
   过滤器仅接受一个参数，可以用普通的布尔值传递，或者用一个关联数组中的
   <parameter>small</parameter> 单元传递。当 <parameter>small</parameter>
   设为 &true; 值时，指示 bzip 库用最小的内存占用来执行解压缩，代价是速度会慢一些。
  </simpara>

  <simpara>
    bzip2.* 压缩过滤器自 PHP 版本 <literal>5.1.0</literal> 起可用，在激活
    <link linkend="ref.bzip2">bz2</link> 支持的前提下。也可以通过安装来自
    <ulink url="&url.pecl;">PECL</ulink> 的<ulink
    url="&url.pecl.package;bz2_filter">bz2_filter</ulink> 包作为一个后门在
    <literal>5.0.x</literal> 版中使用。此过滤器在 PHP 4 中<emphasis>不可用</emphasis>。
  </simpara>

  <example>
   <title>
    <literal>bzip2.compress</literal> 和
    <literal>bzip2.decompress</literal>
   </title>
   <programlisting role="php">
<![CDATA[
<?php
$param = array('blocks' => 9, 'work' => 0);

echo "The original file is " . filesize('LICENSE') . " bytes long.\n";

$fp = fopen('LICENSE.compressed', 'w');
stream_filter_append($fp, 'bzip2.compress', STREAM_FILTER_WRITE, $param);
fwrite($fp, file_get_contents('LICENSE'));
fclose($fp);

echo "The compressed file is " . filesize('LICENSE.compressed') . " bytes long.\n";

/* Generates output:

The original text is 3288 characters long.
The compressed file is 1488 bytes long.

 */
?>
]]>
   </programlisting>
  </example>
 </section>

 <section id="filters.encryption">
  <title>加密过滤器</title>

  <simpara>
   <literal>mcrypt.*</literal> 和 <literal>mdecrypt.*</literal>
   使用 libmcrypt 提供了对称的加密和解密。这两组过滤器都支持
   <link linkend="ref.mcrypt">mcrypt 扩展库</link>中相同的算法，格式为
   <literal>mcrypt.ciphername</literal>，其中 <parameter>ciphername</parameter>
   是密码的名字，将被传递给 <function>mcrypt_module_open</function>。有以下五个过滤器参数可用：
  </simpara>

  <para>
   <table>
    <title>mcrypt 过滤器参数</title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>参数</entry>
       <entry>是否必须</entry>
       <entry>默认值</entry>
       <entry>取值举例</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>mode</entry>
       <entry>可选</entry>
       <entry>cbc</entry>
       <entry>cbc, cfb, ecb, nofb, ofb, stream</entry>
      </row>
      <row>
       <entry>algorithms_dir</entry>
       <entry>可选</entry>
       <entry>ini_get('mcrypt.algorithms_dir')</entry>
       <entry>algorithms 模块的目录</entry>
      </row>
      <row>
       <entry>modes_dir</entry>
       <entry>可选</entry>
       <entry>ini_get('mcrypt.modes_dir')</entry>
       <entry>modes 模块的目录</entry>
      </row>
      <row>
       <entry>iv</entry>
       <entry>必须</entry>
       <entry>N/A</entry>
       <entry>典型为 8，16 或 32 字节的二进制数据。根据密码而定</entry>
      </row>
      <row>
       <entry>key</entry>
       <entry>必须</entry>
       <entry>N/A</entry>
       <entry>典型为 8，16 或 32 字节的二进制数据。根据密码而定</entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </para>

  <example>
   <title>用 3DES 将文件加密输出</title>
   <programlisting role="php">
<![CDATA[
<?php
$passphrase = 'My secret';

/* Turn a human readable passphrase
 * into a reproducable iv/key pair
 */
$iv = substr(md5('iv'.$passphrase, true), 0, 8);
$key = substr(md5('pass1'.$passphrase, true) .
               md5('pass2'.$passphrase, true), 0, 24);
$opts = array('iv'=>$iv, 'key'=>$key);

$fp = fopen('secert-file.enc', 'wb');
stream_filter_append($fp, 'mcrypt.tripledes', STREAM_FILTER_WRITE, $opts);
fwrite($fp, 'Secret secret secret data');
fclose($fp);
?>
]]>
   </programlisting>
  </example>

  <example>
   <title>读取加密的文件</title>
   <programlisting role="php">
<![CDATA[
<?php
$passphrase = 'My secret';

/* Turn a human readable passphrase
 * into a reproducable iv/key pair
 */
$iv = substr(md5('iv'.$passphrase, true), 0, 8);
$key = substr(md5('pass1'.$passphrase, true) .
               md5('pass2'.$passphrase, true), 0, 24);
$opts = array('iv'=>$iv, 'key'=>$key);

$fp = fopen('secert-file.enc', 'rb');
stream_filter_append($fp, 'mdecrypt.tripledes', STREAM_FILTER_WRITE, $opts);
$data = rtrim(stream_get_contents($fp));
fclose($fp);

echo $data;
?>
]]>
   </programlisting>
  </example>

 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
