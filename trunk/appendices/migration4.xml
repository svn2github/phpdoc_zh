<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.2 $ -->
<!-- $Author: class007 $ -->
<!-- EN-Revision: 1.24 Maintainer: class007 Status: ready -->
 <appendix id="migration4">
  <title>从 PHP 3 移植到 PHP 4</title>
	
  <section id='migration4.changes'>
   <title>PHP 4 所作的改变</title>
   <para>
    PHP 4 和其整合的 Zend engine 极大的增强了 PHP 的性能和兼容性，对细节代码也十分注意。所以从 PHP 3 到 PHP 4 的移植要比从 PHP/FI 2 到 PHP 3 的移植容易得多。很多 PHP 3 的代码无需修改就可以在 PHP 4 中运行，但是您还是需要在转换程序运行环境时注意一些细节。下面就是一些提示。
   </para>
  </section>

  <section id="migration4.php4.with.php3">
   <title>同时运行 PHP 3 和 PHP 4</title>
   <simpara>
    最新的操作系统提供了执行多版本和范围程序的能力。这个功能使得在一个 Apache 服务器上同时运行 PHP 3 和 PHP 4 成为可能。   </simpara>
   <simpara>
    已知该功能可以运行在如下平台：
   </simpara>
   <itemizedlist>
     <listitem><simpara>包含新版本 binutils 的 Linux（binutils 2.9.1.0.25 测试通过）</simpara></listitem>
     <listitem><simpara>Solaris 2.5 或更高版本</simpara></listitem>
     <listitem><simpara>FreeBSD（3.2，4.0 测试通过）</simpara></listitem>
   </itemizedlist>
   <para>
    要启用该功能，需要配置(configure) PHP3 和 PHP4 的 APXS（使用 --with-apxs 参数）以及所需的链接扩展（使用 --enable-versioning 参数）。其余的和标准安装方法一样。例如：
    <informalexample>
     <programlisting role="configure">
<![CDATA[
$ ./configure \
  --with-apxs=/apache/bin/apxs \
  --enable-versioning \
  --with-mysql \
  --enable-track-vars
]]>
		 </programlisting>
		</informalexample>
   </para>
  </section>

  <section id="migration4.configuration">
   <title>移植配置文件</title>
   <para>
    全局配置文件 <filename>php3.ini</filename> 已经改名为 &php.ini;。
   </para>
   <para>
    Apache 配置文件也有一些细微的改动。PHP 模块所属的 MIME 类型已经改变。
    <informalexample>
		 <programlisting role="apache">
<![CDATA[
application/x-httpd-php3        -->    application/x-httpd-php
application/x-httpd-php3-source -->    application/x-httpd-php-source
]]>
		 </programlisting>
		</informalexample>
   </para>
   <para>
    您可以使得您的配置文件工作在两个 PHP 版本上（取决于哪个版本编译到服务器上），使用下面的语法：
    <informalexample>
		 <programlisting>
<![CDATA[
AddType  application/x-httpd-php3        .php3
AddType  application/x-httpd-php3-source .php3s

AddType  application/x-httpd-php         .php
AddType  application/x-httpd-php-source  .phps
]]>
     </programlisting>
		</informalexample>
   </para>
   <simpara>
    除此之外，关于 PHP 的 Apache 指令已经改变。
   </simpara>
   <para>
    从 PHP 4.0 开始，只有四个 Apache 指令与 PHP 相关：
    <informalexample>
		 <programlisting role="apache">
<![CDATA[
php_value [PHP directive name] [value]
php_flag [PHP directive name] [On|Off]
php_admin_value [PHP directive name] [value]
php_admin_flag [PHP directive name] [On|Off]
]]>
		 </programlisting>
		</informalexample>
   </para>
   <simpara>
    Admin values 和非 Admin values 有两处不同：
   </simpara>
   <itemizedlist>
    <listitem><simpara>
    Admin values（或 flags）指仅可以出现在服务器范围内的 apache 配置文件（例如：httpd.conf）。
    </simpara></listitem>
    <listitem><simpara>
    Standard values（或 flags）无法控制某种 PHP 指令，例如――安全模式（如果您在 .htaccess 文件中覆盖了安全模式的设定，安全模式就失去了它的意义）。相比较，Admin values 可以更改任何 PHP 指令的值。
    </simpara></listitem>
   </itemizedlist>
   <simpara>
    为了使翻译进程更加容易，PHP 4 捆绑了自动转换您的 Apache 配置文件和 .htaccess 文件使 PHP 3 和 PHP 4 都可以工作。但这些脚本并不转换 MIME 类型！您需要自己转换它。
   </simpara>
   <para>
    要转换您的 Apache 配置文件，运行 apconf-conv.sh 脚本（在 scripts/apache/ 目录）例如：
    <informalexample>
		 <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  ./apconf-conv.sh /usr/local/apache/conf/httpd.conf
]]>
		 </programlisting>
		</informalexample>
   </para>
   <simpara>
    您原来的配置文件会更名为 httpd.conf.orig。
   </simpara>
   <para>
    要转换您的 .htaccess 文件，运行 aphtaccess-conv.sh 脚本（也在 scripts/apache/ directory 目录下）：
    <informalexample>
		 <programlisting role="shell">
<![CDATA[
~/php4/scripts/apache:#  find / -name .htaccess -exec ./aphtaccess-conv.sh {} \;
]]>
		 </programlisting>
		</informalexample>
   </para>
   <simpara>
    同样的，您原有的 .htaccess 文件会以 .orig 后缀保存。
   </simpara>
   <simpara>
    运行转换脚本需要安装 awk。
   </simpara>
  </section>

  <section id='migration4.parser'>
   <title>解析器行为</title>
   <para>
    解析和执行现在变为两个完全独立的步骤。只有当完全成功的解析后，程序才会执行。
   </para>
   <para>
    这种改变所带来的一个新的要求是一个脚本文件所包含的另一个文件必须有着完整的语法结构。您不能将一个完整的控制结构分散在不同的文件中。这意味着您不能在一个文件中开始一个 <literal>for</literal> 或 <literal>while</literal> 循环、一个 <literal>if</literal> 或 <literal>switch</literal> 块，而在另一个文件中结束它们，或在另一个文件中使用    <literal>else</literal>、<literal>endif</literal>、<literal>case</literal> 或 <literal>break</literal>。
   </para>
   <para>
    但是在循环或其它控制结构中包含额外的脚本文件是允许的。只要控制的关键词和相应的 <literal>{...}</literal> 在同一个单元（文件或使用函数 <function>eval</function> 结合的字符串）中就可以了。
   </para>
   <para>
    不过，在循环或其它控制结构中包含额外的脚本文件并不是一个好的遍程习惯。
   </para>
   <para>
    另外，一种在 PHP 3 中不常见的代码――从一个 require 的文件中返回值――在 PHP 4 中也不能使用。而从一个 include 文件中返回值还是允许的。
   </para>
  </section>

  <section id='migration4.error-reporting'>
   <title>错误报告</title>
	 
   <section id='migration4.error-reporting.config'>
    <title>配置的改变</title>
    <para>
     PHP 3 错误报告的级别是简单的将不同的错误报告级别的数字相加而成。通常 15 代表报告所有错误，而 7 代表报告除了 notice 信息以外的所有错误。
    </para>
    <para>
     PHP 4 有一整套错误和警告的级别，并且配置解析器允许使用符号常量来定义显示的错误级别。
    </para>
    <para>
     错误报告级别应该被明确的配置。如果您不想显示某种错误信息，您需要将他们从 <literal>E_ALL</literal> 符号常量中排除。听起来很复杂吗？让我们看看吧。如果您想显示除了以 <literal>E_NOTICE</literal> 表示的 notice 信息以外的所有错误信息，您就应该在 &php.ini; 中设置：<literal>error_reporting = E_ALL &amp; ~ ( E_NOTICE )</literal> 。如果您还不想显示 warning 信息，只需要使用“|”运算符：<literal>error_reporting= E_ALL &amp; ~ ( E_NOTICE | E_WARNING )</literal>。
    </para>
    <warning>
     <para>
      使用旧有的从 7 到 15 的数字来设置错误报告的级别不是个好主意，因为这屏蔽了 PHP 4 中新的错误类产生的错误信息。这可能导致非常奇怪的现象：脚本不能执行却没有任何错误提示。
     </para>
     <para>
      这在过去已经导致了许多重复的 bug 报告。人们报告新的脚本引擎不能跟踪脚本文件中经常发生的缺少“}”的错误。事实上，这是由不正确的配置引起的。
     </para>
     <para>
      所以，检查您错误报告的设置是在脚本无法运行而没有出现错误提示时您应做的第一件事。Zend engine 到现在已经很成熟了，一般不会出现如此奇怪的现象。
     </para>
    </warning>
   </section>

   <section id='migration4.error-reporting.additions'>
    <title>额外的警告信息</title>
    <para>
     许多已存在的 PHP 3 代码使用的语言样式在现在应当被看做是非常糟糕的。因此，如果用 PHP 4 编译该脚本，会产生很多额外的警告信息。如果您不想看到这些信息，只要简单的把 E_NOTICE 选项关闭。但更好的做法是修正代码。
    </para>
    <para>
     The most common case that will now produce notice messages is the
     use of unquoted string constants as array indices. Both PHP 3
     and 4 will fall back to interpret these as strings if no
     keyword or constant is known by that name, but whenever a
     constant by that name had been defined anywhere else in the code
     it might break your script. This can even become a security risk
     if some intruder manages to redefine string constants in a way
     that makes your script give him access rights he wasn't intended
     to have. So PHP 4 will now warn you whenever you use unquoted
     string constants as for example in
     <literal>$_SERVER[REQUEST_METHOD]</literal>. Changing it
     to <literal>$_SERVER['REQUEST_METHOD']</literal> will
     make the parser happy and greatly improve the style and security
     of your code.
    </para>
    <para>
     Another thing PHP 4 will now tell you about is the use of
     uninitialized variables or array elements.
    </para>
   </section>
   
  </section>

  <section id='migration4.initializers'>
   <title>Initializers</title>
   <para>
    Static variable and class member initializers only accept scalar
    values while in PHP 3 they accepted any valid expression.  This
    is, once again, due to the split between parsing and execution as
    no code has yet been executed when the parser sees the
    initializer.
   </para>
   <para>
    For classes you should use constructors to initialize member
    variables instead. For static variables anything but a simple
    static value rarely makes sense anyway.
   </para>
  </section>

  <section id='migration4.empty'>
   <title><literal>empty("0")</literal></title>
   <para>
    The perhaps most controversial change in behavior has happened to the
    behavior of the <function>empty</function>. A String containing
    only the character '0' (zero) is now considered empty while it
    wasn't in PHP 3.
   </para>
   <para> 
    This new behavior makes sense in web applications, with all input
    fields returning strings even if numeric input is requested, and
    with PHP's capabilities of automatic type conversion.  But on the
    other had it might break your code in a rather subtle way,
    leading to misbehavior that is hard to track down if you do not
    know about what to look for.
   </para>
  </section>

  <section id='migration4.missing'>
   <title>Missing functions</title>
   <para>
    While PHP 4 comes with a lot of new features, functions and
    extensions, you may still find some functions from version 3
    missing. A small number of core functions has vanished because
    they do not work with the new scheme of splitting parsing and
    execution as introduced into 4 with the Zend engine.  Other
    functions and even complete extensions have become obsolete as
    newer functions and extensions serve the same task better and/or
    in a more general way. Some functions just simply haven't been
    ported yet and finally some functions or extensions may be missing
    due to license conflicts.
   </para>

   <section id='migration4.missing.concept'>
    <title>Functions missing due to conceptual changes</title>
    <para>
     As PHP 4 now separates parsing from execution it is no longer
     possible to change the behavior of the parser (now embedded in
     the Zend engine) at runtime as parsing already happened by
     then. So the function <function>short_tags</function> no longer
     exists. You can still change the parsers behavior by setting
     appropriate values in the &php.ini; file.
    </para>
    <para>
     Another feature of PHP 3 that is not a part of PHP 4 is the bundled
     debugging interface. There are third-party add-ons for the Zend engine
     which add similar functionality.
    </para>
   </section>

   <section id='migration4.deprecate'>
    <title>Deprecate functions and extensions</title>
    <para>
     The Adabas and Solid database extensions are no more. Long live
     the unified ODBC extension instead.
    </para>
   </section>

   <section id='migration4.unset'>
    <title>Changed status for <function>unset</function></title>
    <para>
     <function>unset</function>, although still available, is
     implemented as a language construct rather than a function.
    </para>
    <para>
     This does not have any consequences on the behavior of
     <function>unset</function>, but testing for "unset" using
     <function>function_exists</function> will return &false; as it would with
     other language constructs that look like functions such as
     <function>echo</function>.
    </para>
    <para>
     Another more practical change is that it is no longer possible to
     call <function>unset</function> indirectly, that is
     <literal>$func="unset"; $func($somevar)</literal> won't work
     anymore.
    </para>
   </section>
  </section>

  <section id='migration4.extensions'>
   <title>PHP 3 extension</title>
   <para>
    Extensions written for PHP 3 will not work with PHP 4, neither as binaries
    nor at the source level. It is not difficult to port extensions to PHP 4
    if you have access to the original source. A detailed description of the
     actual porting process is not part of this text.
   </para>
  </section>

  <section id='migration4.strings'>
   <title>Variable substitution in strings</title>
   <para>
    PHP 4 adds a new mechanism to variable substitution in
    strings. You can now finally access object member variables and
    elements from multidimensional arrays within strings.
   </para>
   <para>
    To do so you have to enclose your variables with curly braces with
    the dollar sign immediately following the opening brace:
    <literal>{$...}</literal>
   </para>
   <para>
    To embed the value of an object member variable into a string you
    simply write <literal>"text {$obj-&gt;member} text"</literal> while
    in PHP 3 you had to use something like <literal>"text
    ".$obj-&gt;member." text"</literal>.
   </para>
   <para>
    This should lead to more readable code, while it may break
    existing scripts written for PHP 3. But you can easily check for
    this kind of problem by checking for the character combination
    <literal>{$</literal> in your code and by replacing it with
    <literal>\{$</literal> with your favorite search-and-replace
    tool.
   </para>
  </section>

  <section id='migration4.cookies'>
   <title>Cookies</title>
   <para>
    PHP 3 had the bad habit of setting cookies in the reverse order
    of the <function>setcookie</function> calls in your code. PHP 4
    breaks with this habit and creates the cookie header lines in
    exactly the same order as you set the cookies in the code.
   </para>
   <para>
    This might break some existing code, but the old behaviour was so
    strange to understand that it deserved a change to prevent further
    problems in the future.
   </para>
  </section>

  <section id='migration4.variables'>
   <title>Handling of global variables</title>
   <para>
    While handling of global variables had the focus on to be easy in
    PHP 3 and early versions of PHP 4, the focus has changed to be more
    secure. While in PHP 3 the following example worked fine, in PHP 4 it
    has to be unset($GLOBALS["id"]);. This is only one issue of global
    variable handling. You should always have used $GLOBALS, with
    newer versions of PHP 4 you are forced to do so in most cases.
    Read more on this subject in the <link linkend="references.global">
    <literal>global</literal> references section</link>.
   </para>
   <example>
    <title>Migration of global variables</title>
    <programlisting role="php">
<![CDATA[
<?php
$id = 1;
function test()
{
    global $id;
    unset($id);
}
test();
echo($id); // This will print out 1 in PHP 4
?>
]]>
    </programlisting>
   </example>
  </section>

 </appendix>


<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
