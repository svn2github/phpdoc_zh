<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.4 $ -->
<!-- $Author: gregory $ -->
<!-- EN-Revision: 1.12 Maintainer: Gregory Status: ready -->
<!-- CREDITS: thomaslio -->
<chapter id="features.commandline">
 <title>PHP 的命令行模式</title>
 <!-- NEW DOCUMENTATION STARTS -->
 <para>
  从版本 4.3 开始，<literal>PHP</literal> 提供了一种新类型的 <literal>SAPI</literal>（Server Application Programming Interface，服务端应用编程端口）支持，名为 <literal>CLI</literal>，意为 <emphasis>Command Line Interface</emphasis>，即命令行接口。顾名思义，该 <literal>SAPI</literal> 模块主要用作 PHP 的开发外壳应用。<literal>CLI SAPI</literal> 和其它 <literal>SAPI</literal> 模块相比有很多的不同之处，我们将在本章中详细阐述。
 </para>
 <para>
  <literal>CLI SAPI</literal> 最先是随 <literal>PHP 4.2.0</literal> 版本发布的，但仍旧只是一个实验性的版本，并需要在运行 <literal>./configure</literal> 时加上 <literal>--enable-cli</literal> 参数。从 <literal>PHP 4.3.0</literal> 版本开始，<literal>CLI SAPI</literal> 成为了正式模块，也因此将被<emphasis role="strong">永久地</emphasis>编译并安装为 PHP 二进制文件（即 Windows 下的 <filename>php.exe</filename> 文件）。
 </para>
 <para>
  以下为 <literal>CLI SAPI</literal> 和其它 <literal>SAPI</literal> 模块相比的显著区别：
  <itemizedlist>
   <listitem>
    <para>
	 与 <literal>CGI SAPI</literal> 不同，其输出没有任何头信息。
    </para>
    <para>
	 尽管 <literal>CGI SAPI</literal> 提供了取消 HTTP 头信息的方法，但在 <literal>CLI SAPI</literal> 中并不存在类似的方法以开启 HTTP 头信息的输出。
    </para>
    <para>
	  CLI 默认以安静模式开始，但为了保证兼容性， <literal>-q</literal> 参数使得您可以使用旧的 CGI 脚本。
    </para>
    <para>
	  在运行时，不会把工作目录改为脚本的当前目录。（您可以使用 <literal>-C</literal> 参数来兼容 CGI 模式）。
    </para>
    <para>
	  出错时输出纯文本的错误信息（非 HTML 格式）。
    </para>
   </listitem>
   <listitem>
    <para>
	 <literal>CLI SAPI</literal> 强制更改了 &php.ini; 中的某些设置，因为这些设置在外壳环境下是没有意义的。
     <table>
      <title>被更改的 &php.ini; 设置选项</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>设置选项</entry>
         <entry><literal>CLI SAPI</literal> 默认值</entry>
         <entry>备注</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
		  无意义的 HTML 标记符会使得出错信息很凌乱，所以在外壳下阅读报错信息是十分困难的。因此将该选项的默认值改为 &false;。
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
		  在命令行模式下，所有来自 <function>print</function> 和 <function>echo</function> 的输出将被立即写到输出端，而不作任何地缓冲操作。如果您希望延缓或控制标准输出，您仍然可以使用 <link linkend="ref.outcontrol">output buffering</link> 设置项。
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0 （无限值）</entry>
         <entry>
		  鉴于在外壳环境下使用 <literal>PHP</literal> 的无穷的可能性，最大运行时间被设置为了无限值。为 WEB 开发的应用程序可能只需运行几秒钟时间，而外壳应用程序的运行时间可能会长的多。
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
		  由于该设置为 &true;，您将总是可以在 <literal>CLI SAPI</literal> 中访问到 <emphasis>argc</emphasis>（传送给应用程序参数的个数）和 <emphasis>argv</emphasis>（包含有实际参数的数组）。
         </para>
         <para>
		  对于 PHP 4.3.0，在使用 <literal>CLI SAPI</literal> 时，<literal>PHP</literal> 变量 <literal>$argc</literal>
          和 <literal>$argv</literal> 已被注册并且设定了对应的值。而在这之前的版本，这两个变量在 <literal>CGI</literal> 或者 <literal>模块</literal> 版本中的建立依赖于将 PHP 的设置选项 <link linkend="ini.register-globals">register_globals</link> 设为 <emphasis>on</emphasis>。除了版本和 <literal>register_globals</literal> 设定以外，您可以随时通过调用 <link linkend="reserved.variables.server">$_SERVER</link> 或者 <varname>$HTTP_SERVER_VARS</varname>来访问它们。例如：<varname>$_SERVER['argv']</varname>
         </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
	  这些设置无法在设置文件 &php.ini; 或任何指定的其它文件中被初始化为其它值。这些默认值被限制在所有其它的设置文件被解析后改变。不过，它们的值可以在程序运行的过程中被改变（尽管对于该运行过程来说，这些设置项是没有意义的）。
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
	 为了减轻外壳环境下的工作，我们定义了如下常量：
     <table>
      <title>CLI 专用常量</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>常量名称</entry>
         <entry>描 述</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STDIN</constant></entry>
         <entry>
		 一个已打开的指向 <literal>stdin</literal> 的流。您可以用如下方法来调用：
         <programlisting role="php">
$stdin = fopen('php://stdin', 'r');
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDOUT</constant></entry>
         <entry>
		 一个已打开的指向 <literal>stdout</literal> 的流。您可以用如下方式来调用：
         <programlisting role="php">
$stdout = fopen('php://stdout', 'w');
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDERR</constant></entry>
         <entry>
		 一个已打开的指向 <literal>stdout</literal> 的流。您可以用如下方式来调用：
         <programlisting role="php">
$stderr = fopen('php://stderr', 'w');
         </programlisting>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
	 有了以上常量，您就无需自己建立指向诸如 <literal>stderr</literal> 的流，只需简单的使用这些常量来代替流指向：
     <programlisting role="php">
php -r 'fwrite(STDERR, "stderr\n");'
     </programlisting>
	 您无需自己来关闭这些流，PHP 会自动完成这些操作。
    </para>
   </listitem>
   <listitem>
    <para>
	 <literal>CLI SAPI</literal> <emphasis role="strong">不</emphasis>会将当前目录改为已运行的脚本所在的目录。
    </para>
    <para>
	 以下范例显示了本模块与 <literal>CGI SAPI</literal> 模块之间的不同：
     <programlisting role="php">
<![CDATA[
<?php
    /* Our simple test application */
    echo getcwd(), "\n";
?>
]]>
     </programlisting>
    </para>
    <para>
	 在使用 <literal>CGI</literal> 版本时，其输出为
     <screen>
<![CDATA[
$ pwd
/tmp

$ php-cgi -f another_directory/test.php
/tmp/another_directory
]]>
     </screen>
    </para>
    <para>
	 我们明显可以看到 <literal>PHP</literal> 将当前目录改成了刚刚运行过的脚本所在的目录。
    </para>
    <para>
	 使用 <literal>CLI SAPI</literal> 模式，我们得到：
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
     </screen>
	 这使得我们在利用 <literal>PHP</literal> 编写外壳工具时获得了很大的便利。
    </para>
    <note>
     <para>
	  您可以在命令行运行时给 <literal>CGI SAPI</literal> 加上 <literal>-C</literal> 参数，使其支持 <literal>CLI SAPI</literal> 的功能。
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
 <para>
  以下是 <literal>PHP</literal> 二进制文件（即 <filename>php.exe</filename> 程序）提供的命令行模式的选项参数，您随时可以通过 <command>PHP -h </command> 命令来查询这些参数。
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [args...]
       php [options] -r <code> [args...]
       php [options] [-- args...]
  -s               Display colour syntax highlighted source.
  -w               Display source with stripped comments and whitespace.
  -f <file>        Parse <file>.
  -v               Version number
  -c <path>|<file> Look for php.ini file in this directory
  -a               Run interactively
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -z <file>        Load Zend extension <file>.
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -i               PHP information
  -r <code>        Run PHP <code> without using script tags <?..?>
  -h               This help

  args...          Arguments passed to script. Use -- args when first argument 
                   starts with - or script is read from stdin
]]>
  </screen>
 </para>
 <para>
  <literal>CLI SAPI</literal> 模块有以下三种不同的方法来获取您要运行的 <literal>PHP</literal> 代码：
  <orderedlist>
   <listitem>
    <para>
	 让 <literal>PHP</literal> 运行指定文件。 
    </para>
    <para>
     <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
     </screen>
    </para>
    <para>
	 以上两种方法（使用或不使用 <literal>-f</literal> 参数）都能够运行给定的 <filename>my_script.php</filename> 文件。您可以选择任何文件来运行，您指定的 <literal>PHP</literal> 脚本并非必须要以 <filename>.php</filename> 为扩展名，它们可以有任意的文件名和扩展名。
    </para>
   </listitem>
   <listitem>
    <para>
	 在命令行直接运行 <literal>PHP</literal> 代码。
    </para>
    <para>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
    </para>
    <para>
	 在使用这种方法时，请您注意外壳变量的替代及引号的使用。
    </para>
    <note>
     <para>
	  请仔细阅读以上范例，在运行代码时没有开始和结束的标记符！加上 <literal>-r</literal> 参数后，这些标记符是不需要的，加上它们会导致语法错误。
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
	 通过标准输入（<literal>stdin</literal>）提供需要运行的 <literal>PHP</literal> 代码。
    </para>
    <para>
	 以上用法给我们提供了非常强大的功能，使得我们可以如下范例所示，动态地生成 <literal>PHP</literal> 代码并通过命令行运行这些代码：
     <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
     </screen>
    </para>
   </listitem>
  </orderedlist>
 </para>
 <para>
  以上三种运行代码的方法不能同时使用。
 </para>
 <para>
  和所有的外壳应用程序一样，<literal>PHP</literal> 的二进制文件（<filename>php.exe</filename> 文件）及其运行的 <literal>PHP</literal> 脚本能够接受一系列的参数。<literal>PHP</literal> 没有限制传送给脚本程序的参数的个数（外壳程序对命令行的字符数有限制，但您通常都不会超过该限制）。传递给您脚本的参数可在全局变量 <literal>$argv</literal> 中获取。该数组中下标为零的成员为脚本的名称（当 <literal>PHP</literal> 代码来自标准输入获直接用 <literal>-r</literal> 参数以命令行方式运行时，该名称为“<literal>-</literal>”）。另外，全局变量 <literal>$argc</literal> 存有 <literal>$argv</literal> 数组中成员变量的个数（而非传送给脚本程序的参数的个数）。
 </para>
 <para>
  只要您传送给您脚本的参数不是以 <literal>-</literal> 符号开头，您就无需过多的注意什么。向您的脚本传送以 <literal>-</literal> 开头的参数会导致错误，因为 <literal>PHP</literal> 会认为应该由它自身来处理这些参数。您可以用参数列表分隔符 <literal>--</literal> 来解决这个问题。在 <literal>PHP</literal> 解析完参数后，该符号后所有的参数将会被原样传送给您的脚本程序。
 </para>
 <screen>
<![CDATA[
# 以下命令将不会运行 PHP 代码，而只显示 PHP 命令行模式的使用说明：
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# 以下命令将会把“-h”参数传送给脚本程序，PHP 不会显示命令行模式的使用说明：
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
 </screen>
 <para>
  除此之外，我们还有另一个方法将 <literal>PHP</literal> 用于外壳脚本。您可以在写一个脚本，并在第一行以 <literal>#!/usr/bin/php</literal> 开头，在其后加上以 <literal>PHP</literal> 开始和结尾标记符包含的正常的 <literal>PHP</literal> 代码，然后为该文件设置正确的运行属性。该方法可以使得该文件能够像外壳脚本或 PERL 脚本一样被直接执行。
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
    var_dump($argv);
?>
]]>
  </programlisting>
 </para>
 <para>
  假设改文件名为 <filename>test</filename> 并被放置在当前目录下，我们可以做如下操作：
  <screen>
<![CDATA[
$ chmod 755 test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
 </para>
 <para>
  正如您所看到的，在您向该脚本传送以 <literal>-</literal> 开头的参数时，脚本仍然能够正常运行。
 </para>
 <para>
  <table>
   <title>命令行选项</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>选项名称</entry>
      <entry>描 述</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-s</entry>
      <entry>
       <para>
	    显示有语法高亮色彩的源文件。
       </para>
       <para>
	    该参数使用内建机制来解析文件并为其生成一个 <literal>HTML</literal> 高亮版本并将结果写到标准输出。请注意该过程所做的只是生成了一个 <literal>&lt;code&gt; [...] &lt;/code&gt;</literal> 的 <literal>HTML</literal> 标记符块，并不包含任何的 <literal>HTML</literal> 头。
       </para>
       <note>
        <para>
		 该选项不能和 <literal>-r</literal> 参数同时使用。
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-w</entry>
      <entry>
       <para>
	    显示除去了注释和空格的源代码。
       </para>
       <note>
        <para>
		 该选项不能和 <literal>-r</literal> 参数同时使用。
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       <para>
	    解析并运行给定的文件名。该参数为可选参数且可以不加，仅指明需要运行的文件名即可。
       </para>
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       <para>
	    将 PHP、PHP SAPI 及 Zend 的版本信息写入的标准输出。例如：
        <screen>
<![CDATA[
$ php -v
PHP 4.3.0-dev (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.2.1, Copyright (c) 1998-2002 Zend Technologies
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       <para>
	    用该参数，您可以指定一个放置 &php.ini; 文件的目录，或者直接指定一个自定义的 <literal>INI</literal> 文件，其文件名可以不是 &php.ini;。例如：
        <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-a</entry>
      <entry>
       <para>
	    交互地运行 PHP。
        <!-- 
        mfischer, 20020510: Couldn't come up with a decent useful description
        of the current implementation of the interactive mode.
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       <para>
	    用该参数可以自行设置 &php.ini; 文件中设置变量的值，其语法为：
        <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
        </screen>
       </para>
       <para>
        范例：
        <screen>
<![CDATA[
# Ommiting the value part will set the given configuration directive to "1"
$ php -d max_execution_time -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Passing an empty value part will set the configuration directive to ""
php -d max_execution_time= -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# The configuration directive will be set to anything passed after the '=' character
$  php -d max_execution_time=20 -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php -d max_execution_time=doesntmakesense -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-e</entry>
      <entry>
       <para>
	    为调试器等生成扩展信息。
        <!-- 
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-z</entry>
      <entry>
       <para>
	    加载 Zend 扩展库。如果仅给定一个文件名，PHP 将试图从您系统扩展库的默认路径（在 Linux 系统下，该路径通常由 <filename>/etc/ld.so.conf</filename> 指定）加载该扩展库。如果您用一个绝对路径指定文件名，则系统的扩展库默认路径将不会被使用。如果用相对路径指定的文件名，PHP 则仅试图加载相对于当前目录的扩展库。
       </para>
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       <para>
	    该参数提供了对指定 <literal>PHP</literal> 代码进行语法检查的方便的方法。如果成功，则向标准输出写入 <literal>No syntax errors detected in &lt;filename&gt;</literal> 字符串，并且外壳返回值为 <literal>0</literal>。如果失败，则 <literal>Errors parsing
        &lt;filename&gt;</literal> 以及内部解析器错误信息会一起被写入到标准输出，同时外壳返回值将别设置为 <literal>255</literal>。
       </para>
       <para>
	    该参数将无法检查致命错误（如未定义函数），如果您希望检测之名错误，请使用 <literal>-f</literal> 参数。
       </para>
       <note>
        <para>
		 该参数不能和 <literal>-r</literal> 一同使用。
        </para>
       </note>
      </entry>
     </row>

     <row>
      <entry>-m</entry>
      <entry>
       <para>
	    使用该参数，PHP 将打印出内置以及已加载的 PHP 及 Zend 模块：
        <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
	   该命令行参数会调用 <function>phpinfo</function> 函数，并打印出结果。如果 <literal>PHP</literal> 没有正常工作，我们建议您执行 <command>php -i</command> 命令来查看在信息表格之前或者对应的地方是否有任何错误信息输出。请注意输出的内容为 <literal>HTML</literal> 格式，因此输出的信息篇幅较大。
      </entry>
     </row>
     <row>
      <entry>-r</entry>
      <entry>
       <para>
	    使用该参数可以在命令行运行 <literal>PHP</literal> 代码。您<emphasis role="strong">无需</emphasis>加上 <literal>PHP</literal> 的起始和结束标识符（<literal>&lt;?php</literal> 和 <literal>?&gt;</literal>），否则将会导致语法解析错误。
       </para>
       <note>
        <para>
		 使用这种形式的 <literal>PHP</literal> 时，应个别注意避免和外壳环境进行的命令行参数替换相冲突。
        </para>
        <para>
		 显示语法解析错误的范例
         <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
         </screen>
        </para>
        <para>
		 这里的问题在于即时使用了双引号 <literal>"</literal>，sh/bash 仍然实行了参数替换。由于 <literal>$foo</literal> 没有被定义，被替换后它所在的位置变成了空字符，因此在运行时，实际被 <literal>PHP</literal> 读取的代码为：
         <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
         </screen>
        </para>
        <para>
		 正确的方法是使用单引号 <literal>'</literal>。在用单引号引用的字符串中，变量不会被 sh/bash 还原成其原值。
         <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
         </screen>
        </para>
        <para>
		 如果您使用的外壳不是 sh/bash，您可能会碰到其它的问题。请报告您碰到的 bug，或者发邮件到 phpdoc@lists.php.net。
        </para>
        <para>
		 当您试图将外壳的环境变量引入到马或者用反斜线来转义字符时也可能碰到各种各样的问题，请您在使用时注意！
		 <!-- :-) -->
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
	   使用该参数，您可以得到完整的命令行参数的列表及这些参数作用的简单描述。
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <!-- NEW DOCUMENTATION ENDS -->

 <!-- OLD DOCUMENTED STARTS
  mfischer, 20020510: I've commented out the start paragraphs of the old
  documentation as it is meant to be replaced by the new one.
 <para>
  The command line options of the PHP executable are useful
  if you would like to debug or test your PHP setup, but they
  can also be handy, if you would like to use PHP for a
  different purpose than web scripting.
 </para>
 <para>
  Note, that you can always direct the output of the PHP
  executable to an external file with the &gt; character,
  so <literal>php -q test.php > test.html</literal> will
  print out the output of <filename>test.php</filename>
  without HTTP headers to the <filename>test.html</filename>
  file in the same directory.
 </para>
 <para>
  You can only use these command line options if you have
  the PHP executable. If you built the server module
  version, and you have no CGI version available on your
  machine, than you have no chance to use these options.
  For Windows users both the PHP executable and the server
  modules are in the binary package, the executable is
  named <filename>php.exe</filename>.
 </para>
 <para>
  This list of command line options is consistent with PHP 4.0.6.
  You can get the actual list and some one line descriptions
  with the <literal>-h</literal> option. The output of
  <literal>php -h</literal> should be something like this:
  <screen>
<![CDATA[
Usage: php [-q] [-h] [-s [-v] [-i] [-f <file>] |  {<file> [args...]}
  -q             Quiet-mode.  Suppress HTTP Header output.
  -s             Display colour syntax highlighted source.
  -f <file>      Parse <file>.  Implies `-q'
  -v             Version number
  -C             Do not chdir to the script's directory
  -c <path>      Look for php.ini file in this directory
  -d foo[=bar]   Define INI entry foo with value 'bar'
  -e             Generate extended information for debugger/profiler
  -z <file>      Load Zend extension <file>.
  -l             Syntax check only (lint)
  -m             Show compiled in modules
  -i             PHP information
  -h             This help
]]>
  </screen>
 </para>
 <para>
  Here we list some of the most important command line options
  with detailed explanations.
 </para>
 <para>
  <table>
   <title>Command line options</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Option</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-q</entry>
      <entry>
       Suppress HTTP headers output. Normally PHP prints out
       HTTP headers for the calling program (ie. webserver)
       to hand on to the browser. When writing command line
       applications these headers are useless.
      </entry>
     </row>
     <row>
      <entry>-s</entry>
      <entry>
       Display the color highlighted source of the file
       given with its name. This is the same as if you were
       printing out the source using the
       <function>highlight_file</function> function in
       a PHP script.
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       Parse the file given, and search for syntactical and
       fatal errors. This option implies -q. Use for
       debugging purposes.
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       By calling PHP with this option, you can ask
       it to print out its version number, ie: 4.0.6. 
      </entry>
     </row>
     <row>
      <entry>-C</entry>
      <entry>
       Normally PHP changes the working directory to the
       running scripts directory. This makes it possible
       for example, to open files in the same directory,
       with only specifying the name of the file. If you
       would like to disable this directory change, use
       this option.
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       Using this option, you can specify an alternative
       &php.ini; path, so PHP will
       search your configurations file in this path
       instead of the default one.
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       With this option, you can set individual 
       &php.ini; settings in the
       time of running a script.
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       Check the file given for syntax errors. This
       option implies -q. Use for debugging purposes.
       This option won't find fatal errors (like undefined
       functions). Use -f if you would like to test
       for fatal errors too.
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       Using this option, PHP prints out the built in
       (and loaded) PHP and Zend modules, the PHP
       and Zend version numbers, and a short Zend
       copyright notice.
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       This command line option calls
       <function>phpinfo</function>, and prints
       out the results. If PHP is not working well,
       it is advisable to make a <literal>php -i</literal>
       and see if any error messages are printed out
       before or in place of the information tables.
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       With this option, you can get information about
       the actual list of command line options and some
       one line descriptions about what they do.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 -->
 <para>
  PHP 的命令行模式能使得 PHP 脚本能完全独立于 WEB 服务器单独运行。如果您使用 Unix 系统，您需要在您的 PHP 脚本的最前面加上一行特殊的代码，使得它能够被执行，这样系统就能知道用什么样的程序要运行该脚本。在 Windows 平台下您可以将 <literal>php.exe</literal> 和 <literal>.php</literal> 文件的双击属性相关联，您也可以编写一个批处理文件来用 PHP 执行脚本。为 Unix 系统增加的第一行代码不会影响该脚本在 Windows 下的运行，因此您也可以用该方法编写跨平台的脚本程序。以下是一个简单的PHP 命令行程序的范例。
 </para>
 <example>
  <title>试图以命令行方式运行的 PHP 脚本（script.php）</title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

This is a command line PHP script with one option.

  Usage:
  <?php echo $argv[0]; ?> <option>

  <option> can be some word you would like
  to print out. With the --help, -help, -h,
  or -? options, you can get this help.

<?php
} else {
    echo $argv[1];
}
?>
]]>
  </programlisting>
 </example>
 <para>
  在以上脚本中，我们用第一行特殊的代码来指明该文件应该由 PHP 来执行。我们在这里使用 CLI 的版本，因此不会有 HTTP 头信息输出。在您用 PHP 编写命令行应用程序时，您可以使用两个参数：<varname>$argc</varname> 和 <varname>$argv</varname>。前面一个的值是比参数个数大 1 的整数（运行的脚本本身的名称也被当作一个参数）。第二个时包含有参数的数组，其第一个元素为脚本的名称，下标为数字 0（<varname>$argv[0]</varname>）。
 </para>
 <para>
  在以上程序中我们检查了参数的个数是大于 1 个还是小于 1 个。即时参数是 <literal>--help</literal>、<literal>-help</literal>、<literal>-h</literal> 或 <literal>-?</literal>，我们仍然打印出帮助信息，并同时动态输出脚本的名称。如果还收到了其它参数，我们也把它们显示出来。
 </para>
 <para>
  如果您希望在 Unix 下运行以上脚本，您需要使得它成为可执行脚本，然后简单的运行 <literal>script.php echothis</literal> 或 <literal>script.php -h</literal>。在 Windows 下，您可以为此编写一个批处理文件：
 </para>
 <example>
  <title>运行 PHP 命令行脚本的批处理文件（script.bat）</title>
  <programlisting role="winbat">
@c:\php\php.exe script.php %1 %2 %3 %4
  </programlisting>
 </example>
 <para>
  假设您将上述程序命名为 <filename>script.php</filename>，且您的 <filename>php.exe</filename> 文件放置在 <filename>c:\php\php.exe</filename>，该批处理文件会帮助您将附加的参数传给脚本程序： <literal>script.bat echothis</literal> 或
  <literal>script.bat -h</literal>。
 </para>
 <para>
  请参阅 <link linkend="ref.readline">Readline</link> 扩展模块的有关文档，以获取更多的函数的信息。这些函数可以帮助您完善您的 PHP 命令行应用程序。
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
