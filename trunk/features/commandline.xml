<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.1 $ -->
<!-- $AUTHOR$ -->
<!-- EN-Revision: 1.8 Maintainer: thomaslio Status: ready -->
<chapter id="features.commandline">
 <title>PHP的命令行模式</title>
 <!-- NEW DOCUMENTATION STARTS -->
 <para>
  从 4.3版本开始，<literal>PHP</literal> 将支持新的
  <literal>SAPI</literal> 模式(服务器应用程序界面)
  名字为 <literal>CLI</literal> 意思为<emphasis>命令行接口</emphasis>。意味着此种 <literal>SAPI</literal> 模式
  主要聚焦在shell的(或者桌面的)<literal>PHP</literal>应用程序开发。<literal>CLI SAPI</literal> 与其他<literal>SAPI</literal>完全不同。深入说明遍及本章
 </para>
 <para>
  <literal>CLI SAPI</literal>第一次发布是在
  <literal>PHP 4.2.0</literal>, 但那是实验性的并且不的不明确的配置<literal>./configure</literal>为<literal>--enable-cli</literal>。从<literal>PHP 4.3.0</literal>以后，
  <literal>CLI SAPI</literal>不再是实验性的因此
  <emphasis role="strong">始终</emphasis>内建在
  <filename>php</filename>内(在windows中就是<filename>php.exe</filename>)。
 </para>
 <para>
  值得注意的是<literal>CLI SAPI</literal>与其他
  <literal>SAPI</literal>的不同在于以下几点
  <itemizedlist>
   <listitem>
    <para>
     <literal>CGI SAPI</literal>，不再有headers输出。
    </para>
    <para>
     虽然<literal>CGI SAPI</literal>有很多方式产生压缩的HTTP
     headers, 但它不等同于<literal>CLI
     SAPI</literal>此项的打开。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>CLI
     SAPI</literal>模式不考虑确定 &php.ini; 指示，因为对于 shell 环境没有任何实在的意义:
     <table>
      <title> &php.ini; 指示</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>指示</entry>
         <entry><literal>CLI SAPI</literal>默认值</entry>
         <entry>注释</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          为了防止产生无意义的混乱，和很难读懂出错的信息和<literal>HTML</literal>
          标记出现在shell模式下, 因此默认指示为 &false;.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          渴望从
          <function>print</function>, <function>echo</function>函数中直接输出效果和友好的输出并且不需要任何高速缓冲的cache。如果想推迟或者熟悉的普通输出，你可以使用<link linkend="ref.outcontrol">output buffering</link>。 
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0 (无限的)</entry>
         <entry>
          防止产生无止境的可能发生的事情，使用<literal>PHP</literal>在
          shell 模式下，最大的执行时间被设置为0，就是无限大。相反的运行在web不需要太长时间, shell应用程序需要大量的执行时间
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
           当运行<literal>CLI SAPI</literal>模式时，<literal>PHP</literal>的全局变量<literal>$argc</literal>
          (number of arguments passed to the application) and
          <literal>$argv</literal> (array of the actual arguments)被适当的填充使用。
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      在&php.ini; 不能被初始化化为其他的值。因为初始化的值被默认为所有的文件都被解析，因此，他们的值只是在运行时间被改变(哪些提示被认为有意义的，
      比如： <link linkend="ini.register-argc-argv">register_argc_argv</link>)。
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     为了减轻在shell环境的工作压力, 以下常量已经被定义：
     <table>
      <title>CLI 的常量</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>常量</entry>
         <entry>描述</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STDIN</constant></entry>
         <entry>
         已开放的流状态<literal>stdin</literal>
         <programlisting role="php">
$stdin = fopen('php://stdin', 'r');
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDOUT</constant></entry>
         <entry>
         已开放的流状态<literal>stdout</literal>
         <programlisting role="php">
$stdout = fopen('php://stdout', 'w');
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDERR</constant></entry>
         <entry>
         已开放的流状态<literal>stdout</literal>
         <programlisting role="php">
$stderr = fopen('php://stderr', 'w');
         </programlisting>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     以上所述，你不需要打开 比如：以
     <literal>stderr</literal>简单常量代替流资源
     <programlisting role="php">
php -r 'fwrite(STDERR, "stderr\n");'
     </programlisting>
     你不需要明确的关闭流，<literal>PHP</literal>会自动关闭。
    </para>
   </listitem>
   <listitem>
    <para>
     <literal>CLI SAPI</literal><emphasis
     role="strong">不</emphasis>需要改变当前目录执行脚本的目录
    </para>
    <para>
     举例表明与<literal>CGI SAPI</literal>的不同:
     <programlisting role="php">
<![CDATA[
<?php
    /* Our simple test application */
    echo getcwd(), "\n";
?>
]]>
     </programlisting>
    </para>
    <para>
    当你使用<literal>CGI</literal>版本，输出是
     <screen>
<![CDATA[
$ pwd
/tmp

$ php-cgi -f another_directory/test.php
/tmp/another_directory
]]>
     </screen>
     <literal>PHP</literal>会明确改变执行脚本的当前目录
    </para>
    <para>
     Using the <literal>CLI SAPI</literal> yields:
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f another_directory/test.php
/tmp
]]>
     </screen>
     在写一个<literal>PHP</literal>shell工具时是一个很大的弹性
    </para>
    <note>
     <para>
      <literal>CGI SAPI</literal>支持<literal>CLI SAPI</literal>
      行为用<literal>-C</literal>
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
 <para>
  <literal>PHP</literal>的命令行列表的选项可以用
  <literal>-h</literal>选择：
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [args...]
       php [options] -r <code> [args...]
       php [options] [-- args...]
  -s               Display colour syntax highlighted source.
  -w               Display source with stripped comments and whitespace.
  -f <file>        Parse <file>.
  -v               Version number
  -c <path>|<file> Look for php.ini file in this directory
  -a               Run interactively
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -z <file>        Load Zend extension <file>.
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -i               PHP information
  -r <code>        Run PHP <code> without using script tags <?..?>
  -h               This help

  args...          Arguments passed to script. Use -- args when first argument 
                   starts with - or script is read from stdin
]]>
  </screen>
 </para>
 <para>
  <literal>CLI SAPI</literal>有三种不同的代码去执行
  <orderedlist>
   <listitem>
    <para>
      告诉<literal>PHP</literal>执行确定的文件
    </para>
    <para>
     <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
     </screen>
     第二种方式(使用<literal>-f</literal>切换)执行文件<filename>my_script.php</filename>。你可以选择任何文件执行， <literal>PHP</literal>不一定需要<filename>.php</filename>的后缀名字。 
    </para>
   </listitem>
   <listitem>
    <para>
     可以通过<literal>PHP</literal>代码直接执行在命令上。
    </para>
    <para>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
     特别小心shell的变量的替换和引用。
    </para>
    <note>
     <para>
      请仔细看这个例子，它们没有开始和结束符号! 
      <literal>-r</literal> 切换不再需要他们。使用它们会出错。
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     <literal>PHP</literal>可以经via普通输出
     (<literal>stdin</literal>).
    </para>
    <para>
     This gives the powerful ability to dynamically create
     <literal>PHP</literal>有强大的能力动态生成为二进知文件，看例子
     (虚构的)：
     <screen>
<![CDATA[
$ some_application | some_filter | php | sort -u >final_output.txt
]]>
     </screen>
    </para>
   </listitem>
  </orderedlist>
  你不可以合并使用三种方式的任何两种
 </para>
 <para>
  对于每一个shell程序，<literal>PHP</literal>接受一个建议并且能接收它们<literal>PHP</literal>的哪些建议可以无限的通过(shell有确定的字符串数量限制被通过)。这些建议可以有全局数组<literal>$argv</literal>可以被通过。脚本的名字可以包含零指出(可以用<literal>-</literal>来表示普通输出<literal>PHP</literal>来自普通输出或者命令行输出
  <literal>-r</literal>)。第二个注册的全局变量
  <literal>$argc</literal>包含着一系列的基本数据数组
  <literal>$argv</literal>(一系列建议<emphasis role="strong">不能</emphasis>被通过)。
 </para>
 <para>
  As long as the arguments you want to pass to your script do not start with
  the <literal>-</literal> character, there's nothing special to watch out
  for. Passing an argument to your script which starts with a
   <literal>-</literal> will cause trouble because <literal>PHP</literal>
   itself thinks it has to handle it. To prevent this use the argument list
   separator <literal>--</literal>. After the argument has been parsed by
   <literal>PHP</literal>, every argument following it is passed
   untoched/unparsed to your script.
 </para>
 <screen>
<![CDATA[
# This will not execute the given code but will show the PHP usage
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# This will pass the '-h' argument to your script and prevent PHP from showing it's usage
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
 </screen>
 <para>
  However, there's another way of using <literal>PHP</literal> for shell
  scripting. You can write a script where the first line starts with
  <literal>#!/usr/bin/php</literal> and then following the normal
  <literal>PHP</literal> code included within the <literal>PHP</literal>
  starting and end tags and set the execution attributes of the file
  appropriately. This way it can be executed like a normal shell or perl
  script:
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
    var_dump($argv);
?>
]]>
  </programlisting>
  Assuming this file is named <filename>test</filename> in the current
  directory, we can now do the following:
  <screen>
<![CDATA[
$ chmod 755 test
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./test"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
  As you see no care has to be taken when passing parameters to your script
  which start with <literal>-</literal>.
 </para>
 <para>
  <table>
   <title>Command line options</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Option</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-s</entry>
      <entry>
       <para>
        Display colour syntax highlighted source.
       </para>
       <para>
        This option uses the internal mechanism to parse the file and produces
        a <literal>HTML</literal> highlighted version of it and writes it to
        standard output. Note that all it does it to generate a block of
        <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>
        <literal>HTML</literal> tags, no <literal>HTML</literal> headers.
       </para>
       <note>
        <para>
         This option does not work together with the <literal>-r</literal>
         option.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-w</entry>
      <entry>
       <para>
        Display source with stripped comments and whitespace.
       </para>
       <note>
        <para>
         This option does not work together with the <literal>-r</literal>
         option.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       <para>
        Parses and executed the given filename to the <literal>-f</literal>
        option. This switch is optional and can be left out. Only providing
        the filename to execute is sufficient.
       </para>
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       <para>
        Writes the PHP, PHP SAPI, and Zend version to standard output, e.g.
        <screen>
<![CDATA[
$ php -v
PHP 4.3.0-dev (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.2.1, Copyright (c) 1998-2002 Zend Technologies
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       <para>
        With this option one can either specify a directory where to look for
        &php.ini; or you can specify a custom <literal>INI</literal> file
        directly (which does not need to be named &php.ini;), e.g.:
        <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-a</entry>
      <entry>
       <para>
        Runs PHP interactively.
        <!-- 
        mfischer, 20020510: Couldn't come up with a decent useful description
        of the current implementation of the interactive mode.
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       <para>
        This option allows to set a custom value for any of the configuration
        directives allowed in &php.ini;. The syntax is:
        <screen>
<![CDATA[
-d configuration_directive[=value]
]]>
        </screen>
       </para>
       <para>
        Examples:
        <screen>
<![CDATA[
# Ommiting the value part will set the given configuration directive to "1"
$ php -d max_execution_time -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Passing an empty value part will set the configuration directive to ""
php -d max_execution_time= -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# The configuration directive will be set to anything passed after the '=' character
$  php -d max_execution_time=20 -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php -d max_execution_time=doesntmakesense -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "doesntmakesense"
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-e</entry>
      <entry>
       <para>
        Generate extended information for debugger/profiler.
        <!-- 
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-z</entry>
      <entry>
       <para>
        Load Zend extension. If only a filename is given, PHP tries to load
        this extension from the current default library path on your system
        (usually specified <filename>/etc/ld.so.conf</filename> on Linux
        systems).  Passing a filename with an absolute path information will
        not use the systems library search path. A relative filename with a
        directory information will tell <literal>PHP</literal> only to try to
        load the extension relative to the current directory.
       </para>
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       <para>
        This option provides a convenient way to only perform a syntax check
        on the given <literal>PHP</literal> code. On succes, the text
        <literal>No syntax errors detected in &lt;filename&gt;</literal> is
        written to standard output and the shell return code is
        <literal>0</literal>. On failure, the text <literal>Errors parsing
        &lt;filename&gt;</literal> in addition to the internal parser error
        message is written to standard output and the shell return code is set
        to <literal>255</literal>.
       </para>
       <para>
        This option won't find fatal errors (like undefined functions). Use
        <literal>-f</literal> if you would like to test for fatal errors too.
       </para>
       <note>
        <para>
         This option does not work together with the <literal>-r</literal>
         option.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       <para>
        Using this option, PHP prints out the built in (and loaded) PHP and
        Zend modules:
        <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       This command line option calls <function>phpinfo</function>, and prints
       out the results. If <literal>PHP</literal> is not working well, it is
       advisable to make a <literal>php -i</literal> and see if any error
       messages are printed out before or in place of the information tables.
       Beware that the output is in <literal>HTML</literal> and therefore
       quite huge.
      </entry>
     </row>
     <row>
      <entry>-r</entry>
      <entry>
       <para>
        This option allows execution of <literal>PHP</literal> right from
        within the command line. The <literal>PHP</literal> start and end tags
        (<literal>&lt;?php</literal> and <literal>?&gt;</literal>) are
        <emphasis role="strong">not needed</emphasis> and will cause a parser
        errors.
       </para>
       <note>
        <para>
         Care has to be taken when using this form of <literal>PHP</literal>
         to not collide with command line variable substitution done by the
         shell.
        </para>
        <para>
         Example showing a parser error
         <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
         </screen>
         The problem here is that the sh/bash performs variable substritution
         even when using double quotes <literal>"</literal>. Since the
         variable <literal>$foo</literal> is unlikely to be defined, it
         expands to nothing which results in being the code passed to
         <literal>PHP</literal> for executin in fact reads:
         <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
         </screen>
         The correct way would be to use single quotes <literal>'</literal>.
         variables in strings quoted with single quotes are not expanded
         by sh/bash.
         <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
         </screen>
         If you are using a shell different from sh/bash, you might experience
         further issues. Feel free to open a bug report or send a mail to
         phpdoc@lists.php.net.

         One still can easily run intro troubles when trying to get shell
         variables into the code or using backslashes for escaping. You've
         been warned. <!-- :-) -->
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       With this option, you can get information about the actual list of
       command line options and some one line descriptions about what they do.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 <!-- NEW DOCUMENTATION ENDS -->

 <!-- OLD DOCUMENTED STARTS
  mfischer, 20020510: I've commented out the start paragraphs of the old
  documentation as it is meant to be replaced by the new one.
 <para>
  The command line options of the PHP executable are useful
  if you would like to debug or test your PHP setup, but they
  can also be handy, if you would like to use PHP for a
  different purpose than web scripting.
 </para>
 <para>
  Note, that you can always direct the output of the PHP
  executable to an external file with the &gt; character,
  so <literal>php -q test.php > test.html</literal> will
  print out the output of <filename>test.php</filename>
  without HTTP headers to the <filename>test.html</filename>
  file in the same directory.
 </para>
 <para>
  You can only use these command line options if you have
  the PHP executable. If you built the server module
  version, and you have no CGI version available on your
  machine, than you have no chance to use these options.
  For Windows users both the PHP executable and the server
  modules are in the binary package, the executable is
  named <filename>php.exe</filename>.
 </para>
 <para>
  This list of command line options is consistent with PHP 4.0.6.
  You can get the actual list and some one line descriptions
  with the <literal>-h</literal> option. The output of
  <literal>php -h</literal> should be something like this:
  <screen>
<![CDATA[
Usage: php [-q] [-h] [-s [-v] [-i] [-f <file>] |  {<file> [args...]}
  -q             Quiet-mode.  Suppress HTTP Header output.
  -s             Display colour syntax highlighted source.
  -f <file>      Parse <file>.  Implies `-q'
  -v             Version number
  -C             Do not chdir to the script's directory
  -c <path>      Look for php.ini file in this directory
  -d foo[=bar]   Define INI entry foo with value 'bar'
  -e             Generate extended information for debugger/profiler
  -z <file>      Load Zend extension <file>.
  -l             Syntax check only (lint)
  -m             Show compiled in modules
  -i             PHP information
  -h             This help
]]>
  </screen>
 </para>
 <para>
  Here we list some of the most important command line options
  with detailed explanations.
 </para>
 <para>
  <table>
   <title>Command line options</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Option</entry>
      <entry>Description</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-q</entry>
      <entry>
       Suppress HTTP headers output. Normally PHP prints out
       HTTP headers for the calling program (ie. webserver)
       to hand on to the browser. When writing command line
       applications these headers are useless.
      </entry>
     </row>
     <row>
      <entry>-s</entry>
      <entry>
       Display the color highlighted source of the file
       given with its name. This is the same as if you were
       printing out the source using the
       <function>highlight_file</function> function in
       a PHP script.
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>
       Parse the file given, and search for syntactical and
       fatal errors. This option implies -q. Use for
       debugging purposes.
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>
       By calling PHP with this option, you can ask
       it to print out its version number, ie: 4.0.6. 
      </entry>
     </row>
     <row>
      <entry>-C</entry>
      <entry>
       Normally PHP changes the working directory to the
       running scripts directory. This makes it possible
       for example, to open files in the same directory,
       with only specifying the name of the file. If you
       would like to disable this directory change, use
       this option.
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>
       Using this option, you can specify an alternative
       &php.ini; path, so PHP will
       search your configurations file in this path
       instead of the default one.
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>
       With this option, you can set individual 
       &php.ini; settings in the
       time of running a script.
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>
       Check the file given for syntax errors. This
       option implies -q. Use for debugging purposes.
       This option won't find fatal errors (like undefined
       functions). Use -f if you would like to test
       for fatal errors too.
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>
       Using this option, PHP prints out the built in
       (and loaded) PHP and Zend modules, the PHP
       and Zend version numbers, and a short Zend
       copyright notice.
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>
       This command line option calls
       <function>phpinfo</function>, and prints
       out the results. If PHP is not working well,
       it is advisable to make a <literal>php -i</literal>
       and see if any error messages are printed out
       before or in place of the information tables.
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>
       With this option, you can get information about
       the actual list of command line options and some
       one line descriptions about what they do.
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>
 </para>
 -->
 <para>
  The PHP executable can be used to run PHP scripts absolutely independent
  from the web server. If you are on a Unix system, you should add a special
  first line to your PHP script, and make it executable, so the system will
  know, what program should run the script. On a Windows platform you can
  associate <literal>php.exe</literal> with the double click option of the
  <literal>.php</literal> files, or you can make a batch file to run the
  script through PHP. The first line added to the script to work on Unix won't
  hurt on Windows, so you can write cross platform programs this way. A simple
  example of writing a command line PHP program can be found below.
 </para>
 <example>
  <title>Script intended to be run from command line (script.php)</title>
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

This is a command line PHP script with one option.

  Usage:
  <?php echo $argv[0]; ?> <option>

  <option> can be some word you would like
  to print out. With the --help, -help, -h,
  or -? options, you can get this help.

<?php
} else {
    echo $argv[1];
}
?>
]]>
  </programlisting>
 </example>
 <para>
  In the script above, we used the special first line to indicate,
  that this file should be run by PHP. We work with a CLI version
  here, so there will be no HTTP header printouts. There are two
  variables you can use while writing command line applications with
  PHP: <varname>$argc</varname> and <varname>$argv</varname>. The
  first is the number of arguments plus one (the name of the script
  running). The second is an array containing the arguments, starting
  with the script name as number zero (<varname>$argv[0]</varname>).
 </para>
 <para>
  In the program above we checked if there are less or more than one
  arguments. Also if the argument was <literal>--help</literal>,
  <literal>-help</literal>, <literal>-h</literal> or <literal>-?</literal>,
  we printed out the help message, printing the script name dynamically.
  If we received some other argument we echoed that out.
 </para>
 <para>
  If you would like to run the above script on Unix, you need to
  make it executable, and simply call it as
  <literal>script.php echothis</literal> or
  <literal>script.php -h</literal>. On Windows, you can make a
  batch file for this task:
 </para>
 <example>
  <title>Batch file to run a command line PHP script (script.bat)</title>
  <programlisting role="winbat">
@c:\php\php.exe script.php %1 %2 %3 %4
  </programlisting>
 </example>
 <para>
  Assuming, you named the above program as
  <filename>script.php</filename>, and you have your
  <filename>php.exe</filename> in
  <filename>c:\php\php.exe</filename> this batch file
  will run it for you with your added options:
  <literal>script.bat echothis</literal> or
  <literal>script.bat -h</literal>.
 </para>
 <para>
  See also the <link linkend="ref.readline">Readline</link>
  extension documentation for more functions you can use
  to enhance your command line applications in PHP.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
