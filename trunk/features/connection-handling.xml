<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.1 $ -->
<!-- $AUTHOR$ -->
<!-- EN-Revision: 1.19 Maintainer: thomaslio Status: ready -->
 <chapter id="features.connection-handling">
  <title>连接操作</title>

  <note>
   <para>应用在3.0.7版本以上</para>
  </note>

  <para>
   PHP的三种可能存在的连接状态是：
   <itemizedlist>
    <listitem><simpara>0 - NORMAL</simpara></listitem>
    <listitem><simpara>1 - ABORTED</simpara></listitem>
    <listitem><simpara>2 - TIMEOUT</simpara></listitem>
   </itemizedlist>
  </para>

  <simpara>
   当PHP运行在NORMAL方式下,如果远程的客户端的连接状态ABORTED被打开时.
   远程连接经常是用户单击了STOP按钮。如果PHP强制时间有限制的话(见
   <function>set_time_limit</function>函数)，TIMEOUT状态将会打开</simpara>。

  <simpara>
   你可以决定是否用你的脚本导致客户端的连接终止。Sometimes it is handy to always have your
   scripts run to completion even if there is no remote browser receiving
   the output.  The default behaviour is however for your script to be
   aborted when the remote client disconnects.  This behaviour can be
   set via the ignore_user_abort &php.ini; directive as well as through
   the corresponding "php_value ignore_user_abort" Apache .conf directive or
   with the <function>ignore_user_abort</function> function.  If you do
   not tell PHP to ignore a user abort and the user aborts, your script
   will terminate.  The one exception is if you have registered a shutdown
   function using <function>register_shutdown_function</function>.  With a
   shutdown function, when the remote user hits his STOP button, the
   next time your script tries to output something PHP will detect that
   the connection has been aborted and the shutdown function is called.
   This shutdown function will also get called at the end of your script
   terminating normally, so to do something different in case of a client
   disconnect you can use the <function>connection_aborted</function>
   function.  This function will return &true; if the connection was
   aborted.</simpara>

  <simpara>
   Your script can also be terminated by the built-in script timer.
   The default timeout is 30 seconds.  It can be changed using
   the max_execution_time &php.ini; directive or the corresponding
   "php_value max_execution_time" Apache .conf directive as well as with
   the <function>set_time_limit</function> function.  When the timer
   expires the script will be aborted and as with the above client
   disconnect case, if a shutdown function has been registered it will
   be called.  Within this shutdown function you can check to see if
   a timeout caused the shutdown function to be called by calling the
   <function>connection_timeout</function> function.  This function will
   return &true; if a timeout caused the shutdown function to be called.</simpara>

  <simpara>
   One thing to note is that both the ABORTED and the TIMEOUT states
   can be active at the same time.  This is possible if you tell
   PHP to ignore user aborts.  PHP will still note the fact that
   a user may have broken the connection, but the script will keep
   running.  If it then hits the time limit it will be aborted and
   your shutdown function, if any, will be called.  At this point
   you will find that <function>connection_timeout</function>
   and <function>connection_aborted</function> return &true;.
   You can also check both states in a single call by using the
   <function>connection_status</function>.  This function returns a
   bitfield of the active states.  So, if both states are active it
   would return 3, for example.</simpara>

 </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
