<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.1 $ -->
<!-- $Author: lm92 $ -->
<!-- EN-Revision: 1.5 Maintainer: lm92 Status: ready -->
  <chapter id="security.globals">
   <title>使用 Register Globals</title>
   <para>
    可能 PHP 中最具争议的变化就是从 PHP <ulink url="&url.php.release4.2.0;">4.2.0</ulink>
    版开始配置文件中 <link linkend="ini.register-globals">register_globals</link>
    的默认值改为 OFF 了。由于这个选项长期打开而导致很多人根本不知道它的存在而且对 PHP
    产生了一定的误解。本节会解释为什么有的人虽然知道这个打开选项是不安全的但也宁愿滥用它去写出一些危险的代码。
   </para>
   <para>
    当 register_globals 打开以后，各种有害的变量都有可能进入您的代码，比如说通过 HTML
    表单。又由于 PHP 在使用变量之前是无需进行初始化的，这就使得某些代码更不安全了。鉴于此，PHP
    开发小组决定把这个选项的默认值设成
    OFF。当打开的时候，人们就会自然而然地使用那些只能设想而不能确定其来源的变量。但是 register_globals
    的关闭改变了这种代码内部变量和客户端发送的变量混杂在一起的糟糕情况。下面先让看一个滥用 register_globals 的例子：
   </para>
   <para>
    <example>
     <title>滥用 register_globals = on 的例子</title>
     <programlisting role="php">
<![CDATA[
<?php
// 当用户合法的时候，斌值 $authorized = true
if (authenticated_user()) {
    $authorized = true;
}

// 由于我们并没有事前把 $authorized 初始化为 false，
// 当 register_globals 打开时，可能通过GET auth.php?authorized=1 来定义该变量值
// 所以任何人都可以绕过身份验证
if ($authorized) {
    include "/highly/sensitive/data.php";
}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    当 register_globals = on 的时候，上面的代码就会有危险了。如果是
    OFF，<varname>$authorized</varname> 就不能通过如 URL
    请求等方式来改变，尽管初始化变量是一个良好的编程习惯，但是无论如何，上面的代码已经变得安全了。比如说，如果在上面的代码执行之前加入
    <literal>$authorized = false</literal> 的话，无论 register_globals 是 on 还是
    off，用户状态都会被初始化为未验证。
   </para>
   <para>
    另一个就是关于<link linkend="ref.session">会话</link>应用例子。当 register_globals = on
    的时候，<varname>$username</varname> 也可以用在下面的代码中，但要您要意识到
    <varname>$username</varname> 也可能会从其它途径进来，比如说通过 URL的 GET。
   </para>
   <para>
    <example>
     <title>使用会话时同时兼容 register_globals on 和 off 的例子</title>
     <programlisting role="php">
<![CDATA[
<?php
// 我们不知道 $username 的来源，但很清楚 $_SESSION 是
// 来源于会话数据
if (isset($_SESSION['username'])) {

    echo "Hello <b>{$_SESSION['username']}</b>";

} else {

    echo "Hello <b>Guest</b><br />";
    echo "Would you like to login?";

}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    采取相应的预防措施以便在伪造变量输入的时候给予警告是完全有可能的。如果您确知要从哪里获得变量，您就可以辨别出哪些来源不当的了。然而，我们不能保证变量来源没有被伪造，但是这就需要攻击者去猜测应该伪造哪种来源了。如果您并不在意外部变量的来源，您可以用
    <varname>$_REQUEST</varname> 数组，它包括了 GET、POST 和 COOKIE
    的所有数据。详情可参见本手册的 <link linkend="language.variables.external">PHP 的外部变量</link>。
   </para>
   <para>
    <example>
     <title>探测有害变量</title>
     <programlisting role="php">
<![CDATA[
<?php
if (isset($_COOKIE['MAGIC_COOKIE'])) {

    // MAGIC_COOKIE 来自 cookie
    // 这样做是确保是来自 cookie 的数据

} elseif (isset($_GET['MAGIC_COOKIE']) || isset($_POST['MAGIC_COOKIE'])) {

   mail("admin@example.com", "Possible breakin attempt", $_SERVER['REMOTE_ADDR']);
   echo "Security violation, admin has been alerted.";
   exit;

} else {

   // 这一次请求中并没有设置 MAGIC_COOKIE 变量

}
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    当然，单纯地关闭 register_globals
    并不代表您的代码安全了。对于每一段提交上来的数据，您都要对其进行具体的检查，并且不要忘记验证您的数据数据和对变量进行初始化。把
    <function>error_reporting</function> 设为
    <constant>E_NOTICE</constant> 级别可以帮助您检查未初始化的变量。
   </para>
   <para>
    更多关于 register_globals 设成 On 和 Off 的信息，请见
    <link linkend="faq.misc.registerglobals">FAQ</link>。
   </para>

   &note.superglobals;

  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
