<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision: 1.1 $ -->
<!-- $Author: lm92 $ -->
<!-- EN-Revision: 1.7 Maintainer: lm92 Status: ready -->
  <chapter id="security.errors">
   <title>错误报告</title>
   <para>
    错误报告对于 PHP 
    程序的安全性来说是一把又双仞剑，在特定的环境下，它可能会提高安全性，也可能会对系统产生危害。
   </para>
   <para>
    攻击系统时经常使用的手法就是输入不正确的数据，然后查看错误提示的类型及上下文。这样做有利于攻击者收集服务器的信息以便寻找弱点。比如说，如果一个攻击者知道了一个页面所基于的表单信息，那么他就会尝试修改变量：
    <example>
     <title>用自定义的 HTML 页面攻击变量</title>
     <programlisting role="html">
<![CDATA[
<form method="post" action="attacktarget?username=badfoo&amp;password=badfoo">
<input type="hidden" name="username" value="badfoo" />
<input type="hidden" name="password" value="badfoo" />
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    通常 PHP
    所返回的错误提示都能帮助开发者调试程序，它会提出哪个文件的哪些函数或代码出错，并指出错误发生的在文件的第几行，这些就是
    PHP 本身所能给出的信息。很多 PHP 开发者会使用
    <function>show_source</function>、<function>highlight_string</function>或者<function>highlight_file</function>
    函数来调试代码，但是在正式运行的网站中，这种做法可能会暴露出隐藏的变量、未检查的语法和其它的可能危及系统安全的信息。在运行一些开源的程序时打开调试功能，或者使用人尽皆知的调试技术是很危险的。如果让攻击者确定了你是使用了哪种具体的调试技术，他们会尝试发送变量来打开调试功能：
    <example>
     <title>利用变量打开调式功能</title>
     <programlisting role="html">
<![CDATA[
<form method="post" action="attacktarget?errors=Y&amp;showerrors=1&amp;debug=1">
<input type="hidden" name="errors" value="Y" />
<input type="hidden" name="showerrors" value="1" />
<input type="hidden" name="debug" value="1" />
</form>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    不管处理错误的方法如何，攻击者只要能找到系统错误的话都可以获得更多的信息。
   </para>
   <para>
    比如说，PHP 的独有的错误提示风格可以说明系统在运行 PHP
    （译者注：其它技术如 ASP.Net 也一样）。如果攻击者访问一个 .html
    为后缀的页面之后，想知道其后台的技术（为了寻找系统弱点），他们就会把错误的数据提交上去，然后就可以确定系统是基于
    PHP 的了。
   </para>
   <para>
    一个函数错误就可能暴露系统正在使用的数据库，或者为攻击者提供有关网页、程序或设计方面的有用信息。攻击者往往会顺藤摸瓜地找到开放的数据库端口，以及页面上某些 bug
    或弱点等。比如说，攻击者可以一些不正常的数据使程序出错，来探测哪些代码是用于进行身份验证的（能过错误提示的行号码）以便在其它地方加以利用。
   </para>
   <para>
    一个文件系统或者 PHP 的错误就会暴露 Web
    服务器具有什么权限，例如文件在服务器上的组织结构。开发者编码上的出错可能会使这个问题更加严重，把原来该隐藏的数据反而给泄漏出去了。
   </para>
   <para>
    有三个常用的办法处理这些问题。第一个是彻底地检查所有代码，使其可以兼容大部份的错误。第二个是在运行代码时关闭错误报告。第三个是使用
    PHP 内置的错误处理函数创建自己的错误处理机制。根据不同的安全策略，您会发现三种方法都是很有用的。
   </para>
   <para>
    一个能提前阻止这个问题发生的方法就是使用
    <function>error_reporting</function>，它可以保护您的代码并发现变量使用不当的地方。在部署项目之前，先打开
    E_ALL 测试您的代码，它会帮助您找到变量使用不当的地方。一但项目正式运作了，你就要把
    <function>error_reporting</function> 的参数设为 0 或者把 &php.ini; 内的
    <literal>display_errors</literal> 设为 off 来关闭所有的错误提示。当然，如果您选择迟一些再这样做，您就必须打开 ini 文件内的
    <literal>log_errors</literal> 选项，并通过 <literal>error_log</literal> 指定用于记录错误信息的文件。
    <example>
     <title>用 E_ALL 来查找危险的变量</title>
     <programlisting role="php">
<![CDATA[
<?php
if ($username) {  // 在使用变量之前没有对其进行检查或初始化
    $good_login = 1;
}
if ($good_login == 1) { // 上面的检查失败后，并没有对变量进行检查或初始化
    readfile ("/highly/sensitive/data/index.html");
}
?>
]]>
     </programlisting>
    </example>
   </para>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
