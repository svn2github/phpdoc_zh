<?xml version="1.0" encoding="gb2312"?>
<!-- $Revision: 1.1 $ -->
<!-- $Author: lm92 $ -->
<!-- EN-Revision: 1.3 Maintainer: lm92 Status: ready -->
  <chapter id="security.filesystem">
   <title>文件系统安全</title>
   <simpara>
    PHP 遵从大多数服务器系统中关于文件和目录权限的安全机制。这就使您可以控制哪些文件在文件系统内是可读的。您必须特别注同全局的可读文件，并确保每一个有权限的用户对这些文件的读取动作都是安全的。
   </simpara>
   <simpara>
    PHP 被设计为允许使用不同的用户级别来访问文件系统，所以完全有可能通过编写一段 PHP 代码来读取如 /etc/passwd 的系统文件、更改以太网连接以及发送大量的任务给打印机等等。换而言之，您必须确保的您的 PHP 代码写入和读取的文件是安全的。
   </simpara>
   <simpara>
    使用下面的代码，用户可以指定文件名并在自己的主目录中删除它。假设这样做是为了能通过 Web 界面来管理文件系统，因此 Apache 用户有权删除自己目录下的文件。
   </simpara>
   <para>
    <example>
     <title>不对变量进行安全检查会导致……</title>
     <programlisting role="php">
<![CDATA[
<?php
// 从用户目录中删除指定的文件
$username = $_POST['user_submitted_name'];
$homedir = "/home/$username";
$file_to_delete = "$userfile";
unlink ("$homedir/$userfile");
echo "$file_to_delete has been deleted!";
?>
]]>
     </programlisting>
    </example>
   既然 username 变量可以通过用户表单来提交，他们就可以在用户名和文件名前加一些东西，然后删除其它目录的文件。这种情况下，你就需要考虑对提交的变量内容进行验证了。如果在提交的文件名前面加上“../etc/”和“passwd”的话，上面的代码就等同于：
    <example>
     <title>……一个针对文件系统的攻击</title>
     <programlisting role="php">
<![CDATA[
<?php
// 如果 PHP 有 root 权限的话，用户就可以删除硬盘中的任意文件
$username = "../etc/";
$homedir = "/home/../etc/";
$file_to_delete = "passwd";
unlink ("/home/../etc/passwd");
echo "/home/../etc/passwd has been deleted!";
?>
]]>
     </programlisting>
    </example>
    有两个办法可以帮助您防止这类的问题
    <itemizedlist>
     <listitem>
      <simpara>
       限制 PHP 用户的权限
      </simpara>
     </listitem>
     <listitem>
      <simpara>
       检查所有提交上来的变量值
      </simpara>
     </listitem>
    </itemizedlist>
    根据上面的两个思想，可以对代码进行改进：
    <example>
     <title>更安全的文件名检查</title>
     <programlisting role="php">
<![CDATA[
<?php
// 只允许 PHP 用户在权限范围之内删除文件
$username = $_SERVER['REMOTE_USER']; // 使用验证机制

$homedir = "/home/$username";

$file_to_delete = basename("$userfile"); // 去除变量中的路径
unlink ($homedir/$file_to_delete);

$fp = fopen("/home/logging/filedelete.log","+a"); // 记录删除动作
$logstring = "$username $homedir $file_to_delete";
fwrite ($fp, $logstring);
fclose($fp);

echo "$file_to_delete has been deleted!";
?>
]]>
     </programlisting>
    </example>
    然而，这样做仍然是有缺陷的。如果你的身份验证系统允许用户自行登陆，那么用户可以提交“../etc/”之类的变量，系统又一次沦陷了。所以，你需要加强检查：
    <example>
     <title>更安全的文件名检查</title>
     <programlisting role="php">
<![CDATA[
<?php
$username = $_SERVER['REMOTE_USER']; // 使用验证机制
$homedir = "/home/$username";

if (!ereg('^[^./][^/]*$', $userfile))
     die('bad filename'); // 停止执行代码

if (!ereg('^[^./][^/]*$', $username))
     die('bad username'); // 停止执行代码
//后略……
?>
]]>
     </programlisting>
    </example>
   </para>
   <para>
    在您的系统上，存在着各钟各样需要注意的文件，包括联系到系统的设备（/dev/ 或者 COM1）、配置文件（/ect/ 和 .ini文件）、常用的存储区域（/home/ 或者 My Documents）等等。了解这些信息以后，你就可以制定相关的策略来开放或禁止某些东西了。
   </para>
  </chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
